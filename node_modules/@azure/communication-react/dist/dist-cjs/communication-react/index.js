'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var communicationCommon = require('@azure/communication-common');
var reselect = require('reselect');
var communicationCalling = require('@azure/communication-calling');
var memoizeOne = require('memoize-one');
var React = require('react');
var react = require('@fluentui/react');
var reactNorthstar = require('@fluentui/react-northstar');
var reactIcons = require('@fluentui/react-icons');
var reactAriaLive = require('react-aria-live');
var reactFileTypeIcons = require('@fluentui/react-file-type-icons');
var htmlToReact = require('html-to-react');
var Linkify = require('react-linkify');
var reactHooks = require('@fluentui/react-hooks');
var reactWindowProvider = require('@fluentui/react-window-provider');
var copy = require('copy-to-clipboard');
var logger = require('@azure/logger');
var EventEmitter = require('events');
var produce = require('immer');
var communicationChat = require('@azure/communication-chat');
var nanoid = require('nanoid');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var reselect__namespace = /*#__PURE__*/_interopNamespace(reselect);
var memoizeOne__default = /*#__PURE__*/_interopDefaultLegacy(memoizeOne);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var Linkify__default = /*#__PURE__*/_interopDefaultLegacy(Linkify);
var copy__default = /*#__PURE__*/_interopDefaultLegacy(copy);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);
var produce__default = /*#__PURE__*/_interopDefaultLegacy(produce);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const argsCmp = (args1, args2, objCmp) => {
    return args1.length === args2.length && args1.every((arg1, index) => objCmp(args2[index], arg1));
};
/**
 * The function memoize a series of function calls in a single pass,
 * it memoizes all the args and return in a single run of the callback function, and read it in the next round of execution
 * note: this is a memory opimized function which will only memoize one round of bulk calls
 * @param  fnToMemoize - the function needs to be bulk memorized and a key key paramter needs to be provided as cache id
 * @param  shouldCacheUpdate - the validate function for comparing 2 argument, return true when 2 args are equal
 * @returns callback function includes a series calls of memoizedFn, and each call will get cache result if args are the same(according to shouldCacheUpdate fn)
 * @example
 * ```ts
 * const items = [{id:1, value:3}];
 * const heavyFn = (_key, value) => { // key is not used in the function, but it is a cache id
 *   // assume this is a heavy caculation
 *   return value+1;
 * }
 *
 * const memoizeHeavyFnAll = memoizeFnAll(heavyFn);
 * const generateValueArray = (memoizedHeavyFn) => (
 *   items.map(item => {
 *     memoizedHeavyFn(item.id, item.value);
 *   })
 * );
 *
 * const result = memoizeHeavyFnAll(generateValueArray); // Cache: {}, nextCache: {1: 4 *new}, heavyFn call times: 1
 *
 * // Argument changed
 * items[0].value = 2
 * const result0 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 4}, nextCache: {1: 3 *new}, heavyFn call times: 1
 *
 * // Cache added
 * items.push({id:3, value:4});
 * const result1 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3 *hit}, nextCache: {1: 3, 3: 5 *new}, heavyFn call times: 1
 *
 * // Cache removed
 * delete items[0];
 * const result2 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3, 3: 5 *hit}, nextCache: {3: 5}, heavyFn call times: 0
 * ```
 *
 * @public
 */
const memoizeFnAll = (fnToMemoize, shouldCacheUpdate = Object.is) => {
    let cache = new Map();
    let nextCache = new Map();
    return (callback) => {
        const memoizedFn = (key, ...args) => {
            const value = cache.get(key);
            if (value) {
                const [preArgs, ret] = value;
                if (argsCmp(preArgs, args, shouldCacheUpdate)) {
                    nextCache.set(key, [args, ret]);
                    return ret;
                }
            }
            const ret = fnToMemoize(key, ...args);
            nextCache.set(key, [args, ret]);
            return ret;
        };
        const retValue = callback(memoizedFn);
        cache = nextCache;
        nextCache = new Map();
        return retValue;
    };
};

// Copyright (c) Microsoft Corporation.
const COMMUNICATION_USER_PREFIX = '8:acs:';
const PHONE_NUMBER_PREFIX = '4:';
const TEAMS_DOD_PREFIX = '8:dod:';
const TEAMS_GCCH_PREFIX = '8:gcch:';
const TEAMS_USER_PREFIX = '8:origid:';
const TEAMS_VISITOR_PREFIX = '8:teamsvisitor:';
/**
 * A string representation of a {@link @azure/communication-common#CommunicationIdentifier}.
 *
 * This string representation of CommunicationIdentifier is guaranteed to be stable for
 * a unique Communication user. Thus,
 * - it can be used to persist a user's identity in external databases.
 * - it can be used as keys into a Map to store data for the user.
 *
 * @public
 */
const toFlatCommunicationIdentifier = (identifier) => {
    if (communicationCommon.isCommunicationUserIdentifier(identifier)) {
        return identifier.communicationUserId;
    }
    if (communicationCommon.isMicrosoftTeamsUserIdentifier(identifier)) {
        if (identifier.isAnonymous) {
            return TEAMS_VISITOR_PREFIX + identifier.microsoftTeamsUserId;
        }
        if (identifier.cloud === 'dod') {
            return TEAMS_DOD_PREFIX + identifier.microsoftTeamsUserId;
        }
        if (identifier.cloud === 'gcch') {
            return TEAMS_GCCH_PREFIX + identifier.microsoftTeamsUserId;
        }
        return TEAMS_USER_PREFIX + identifier.microsoftTeamsUserId;
    }
    if (communicationCommon.isPhoneNumberIdentifier(identifier)) {
        return PHONE_NUMBER_PREFIX + identifier.phoneNumber;
    }
    return identifier.id;
};
/**
 * Reverse operation of {@link toFlatCommunicationIdentifier}.
 *
 * @public
 */
const fromFlatCommunicationIdentifier = (id) => {
    if (id.startsWith(COMMUNICATION_USER_PREFIX)) {
        // The prefix is preserved for this variant of the identifier.
        return {
            communicationUserId: id
        };
    }
    if (id.startsWith(PHONE_NUMBER_PREFIX) || id.startsWith('+')) {
        const isPhoneNumber = id.startsWith(PHONE_NUMBER_PREFIX) ? id.replace(PHONE_NUMBER_PREFIX, '') : id;
        return {
            phoneNumber: isPhoneNumber
        };
    }
    if (id.startsWith(TEAMS_USER_PREFIX)) {
        return {
            microsoftTeamsUserId: id.replace(TEAMS_USER_PREFIX, '')
        };
    }
    if (id.startsWith(TEAMS_DOD_PREFIX)) {
        return {
            microsoftTeamsUserId: id.replace(TEAMS_DOD_PREFIX, ''),
            cloud: 'dod'
        };
    }
    if (id.startsWith(TEAMS_GCCH_PREFIX)) {
        return {
            microsoftTeamsUserId: id.replace(TEAMS_GCCH_PREFIX, ''),
            cloud: 'gcch'
        };
    }
    if (id.startsWith(TEAMS_VISITOR_PREFIX)) {
        return {
            microsoftTeamsUserId: id.replace(TEAMS_VISITOR_PREFIX, ''),
            isAnonymous: true
        };
    }
    return {
        id
    };
};
/**
 * Returns a CommunicationIdentifier.
 * @internal
 */
const _toCommunicationIdentifier = (id) => {
    if (typeof id === 'string') {
        return fromFlatCommunicationIdentifier(id);
    }
    return id;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// GENERATED FILE. DO NOT EDIT MANUALLY.
var telemetryVersion = '1.4.1';

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// Removes long suffixes that don't fit the constraints for telemetry application ID.
// e.g., the build suffix is dropped for alpha package versions.
const sanitize = (version) => {
    const alphaIndex = version.search(/alpha/);
    if (alphaIndex >= 0) {
        return version.substring(0, alphaIndex + 5);
    }
    return version;
};
/**
 * Application ID to be included in telemetry data from the UI library.
 *
 * @internal
 */
const _getApplicationId = () => {
    const version = telemetryVersion;
    return sanitize(`acr/${version}`);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 *
 * Replace the pattern "\{\}" in str with the values passed in as vars
 *
 * @example
 * ```ts
 *   _formatString("hello {name}. '{name}' is a rare name.", {name: "Foo"});
 *   // returns "hello Foo. 'Foo' is a rare name."
 * ```
 * @param str - The string to be formatted
 * @param variables - Variables to use to format the string
 * @returns a formatted string
 */
const _formatString = (str, vars) => {
    if (!str) {
        return '';
    }
    if (!vars) {
        return str;
    } // regex to search for the pattern "\{\}"
    const placeholdersRegex = /{(\w+)}/g;
    return str.replace(placeholdersRegex, (_, k) => vars[k] || `{${k}}`);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Wrap JSON.stringify in a try-catch as JSON.stringify throws an exception if it fails.
 *
 * Use this only in areas where the JSON.stringify is non-critical and OK for the JSON.stringify to fail, such as logging.
 *
 * @internal
 */
const _safeJSONStringify = (value, replacer = createSafeReplacer(), space) => {
    try {
        return JSON.stringify(value, replacer, space);
    }
    catch (e) {
        console.error(e);
        return undefined;
    }
}; // Log all visited refs to avoid circular ref
const createSafeReplacer = () => {
    const visited = new Set();
    return function replacer(key, value) {
        if (typeof value !== 'object') {
            return value;
        }
        if (visited.has(value)) {
            return 'Visited-Ref';
        }
        else {
            visited.add(value);
            return value;
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Converts units of rem to units of pixels
 * @param rem - units of rem
 * @returns units of pixels
 */
const _convertRemToPx = (rem) => {
    return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
};
/**
 * @internal
 * Disable dismiss on resize to work around a couple Fluent UI bugs
 * - The Callout is dismissed whenever *any child of window (inclusive)* is resized. In practice, this
 * happens when we change the VideoGallery layout, or even when the video stream element is internally resized
 * by the headless SDK.
 * - We also want to prevent dismiss when chat pane is scrolling especially a new message is added.
 * A side effect of this workaround is that the context menu stays open when window is resized, and may
 * get detached from original target visually. That bug is preferable to the bug when this value is not set -
 * The Callout (frequently) gets dismissed automatically.
 */
const _preventDismissOnEvent = (ev) => {
    return ev.type === 'resize' || ev.type === 'scroll';
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Converts px value to rem value.
 * For example, an input of `16` will return `1rem`.
 */
const _pxToRem = (px) => `${px / 16}rem`;

/**
 * @internal
 * This is a log function to log structural data for easier parse in telemetry
 */
const _logEvent = (logger, event) => {
    logger[event.level](_safeJSONStringify(event));
};

/**
 * @private
 */
const getDeviceManager$1 = (state) => state.deviceManager;
/**
 * @private
 */
const getCallExists = (state, props) => !!state.calls[props.callId];
/**
 * @private
 */
const getDominantSpeakers = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.dominantSpeakers; };
/**
 * @private
 */
const getRemoteParticipants$1 = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.remoteParticipants;
};
/**
 * @private
 */
const getIsScreenSharingOn = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn; };
/**
 * @private
 */
const getIsMuted = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.isMuted; };
/**
 * @private
 */
const getLocalVideoStreams$1 = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.localVideoStreams; };
/**
 * @private
 */
const getScreenShareRemoteParticipant = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.screenShareRemoteParticipant; };
/**
 * @private
 */
const getDisplayName$2 = (state) => { var _a; return (_a = state.callAgent) === null || _a === void 0 ? void 0 : _a.displayName; };
/**
 * @private
 */
const getIdentifier = (state) => toFlatCommunicationIdentifier(state.userId);
/**
 * @private
 */
const getLatestErrors$1 = (state) => state.latestErrors;
/**
 * @private
 */
const getDiagnostics = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.diagnostics; };

var __awaiter$u = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Check if the call state represents being in the call
 *
 * @internal
 */
const _isInCall = (callStatus) => !!callStatus && !['None', 'Disconnected', 'Connecting', 'Ringing', 'EarlyMedia'].includes(callStatus);
/**
 * Check if the call state represents being in the lobby or waiting to be admitted.
 *
 * @internal
 */
const _isInLobbyOrConnecting = (callStatus) => !!callStatus && ['Connecting', 'Ringing', 'InLobby'].includes(callStatus);
/**
 * Check if the device manager local video is on when not part of a call
 * i.e. do unparented views exist.
 *
 * @internal
 */
const _isPreviewOn = (deviceManager) => {
    // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
    // handle cases where 'Preview' view is in progress and not necessary completed.
    return deviceManager.unparentedViews.length > 0 && deviceManager.unparentedViews[0].view !== undefined;
};
/**
 * Dispose of all preview views
 * We assume all unparented views are local preview views.
 *
 * @private
 */
const disposeAllLocalPreviewViews = (callClient) => __awaiter$u(void 0, void 0, void 0, function* () {
    const unparentedViews = callClient.getState().deviceManager.unparentedViews;
    for (const view of unparentedViews) {
        yield callClient.disposeView(undefined, undefined, view);
    }
});

/**
 * Selector for {@link MicrophoneButton} component.
 *
 * @public
 */
const microphoneButtonSelector = reselect__namespace.createSelector([getCallExists, getIsMuted, getDeviceManager$1], (callExists, isMuted, deviceManager) => {
    const permission = deviceManager.deviceAccess ? deviceManager.deviceAccess.audio : true;
    return {
        disabled: !callExists || !permission,
        checked: callExists ? !isMuted : false,
        microphones: deviceManager.microphones,
        speakers: deviceManager.speakers,
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker
    };
});
/**
 * Selector for {@link CameraButton} component.
 *
 * @public
 */
const cameraButtonSelector = reselect__namespace.createSelector([getLocalVideoStreams$1, getDeviceManager$1], (localVideoStreams, deviceManager) => {
    const previewOn = _isPreviewOn(deviceManager);
    const localVideoFromCall = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
    const permission = deviceManager.deviceAccess ? deviceManager.deviceAccess.video : true;
    return {
        disabled: !deviceManager.selectedCamera || !permission || !deviceManager.cameras.length,
        checked: localVideoStreams !== undefined && localVideoStreams.length > 0 ? !!localVideoFromCall : previewOn,
        cameras: deviceManager.cameras,
        selectedCamera: deviceManager.selectedCamera
    };
});
/**
 * Selector for {@link ScreenShareButton} component.
 *
 * @public
 */
const screenShareButtonSelector = reselect__namespace.createSelector([getIsScreenSharingOn], (isScreenSharingOn, 
/* @conditional-compile-remove(PSTN-calls) */
callState) => {
    return {
        checked: isScreenSharingOn
    };
});
/**
 * Selector for {@link DevicesButton} component.
 *
 * @public
 */
const devicesButtonSelector = reselect__namespace.createSelector([getDeviceManager$1], deviceManager => {
    return {
        microphones: deviceManager.microphones,
        speakers: deviceManager.speakers,
        cameras: deviceManager.cameras,
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker,
        selectedCamera: deviceManager.selectedCamera
    };
});

var __awaiter$t = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const areStreamsEqual = (prevStream, newStream) => {
    return !!prevStream && !!newStream && prevStream.source.id === newStream.source.id;
};
/**
 * Create the default implementation of {@link CallingHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const createDefaultCallingHandlers = memoizeOne__default['default']((callClient, callAgent, deviceManager, call) => {
    const onStartLocalVideo = () => __awaiter$t(void 0, void 0, void 0, function* () {
        // Before the call object creates a stream, dispose of any local preview streams.
        // @TODO: is there any way to parent the unparented view to the call object instead
        // of disposing and creating a new stream?
        yield disposeAllLocalPreviewViews(callClient);
        const callId = call === null || call === void 0 ? void 0 : call.id;
        let videoDeviceInfo = callClient.getState().deviceManager.selectedCamera;
        if (!videoDeviceInfo) {
            const cameras = yield (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.getCameras());
            videoDeviceInfo = cameras && cameras.length > 0 ? cameras[0] : undefined;
            videoDeviceInfo && (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.selectCamera(videoDeviceInfo));
        }
        if (!callId || !videoDeviceInfo) {
            return;
        }
        const stream = new communicationCalling.LocalVideoStream(videoDeviceInfo);
        if (call && !call.localVideoStreams.find(s => areStreamsEqual(s, stream))) {
            yield call.startVideo(stream);
        }
    });
    const onStopLocalVideo = (stream) => __awaiter$t(void 0, void 0, void 0, function* () {
        const callId = call === null || call === void 0 ? void 0 : call.id;
        if (!callId) {
            return;
        }
        if (call && call.localVideoStreams.find(s => areStreamsEqual(s, stream))) {
            yield call.stopVideo(stream);
            yield callClient.disposeView(callId, undefined, {
                source: stream.source,
                mediaStreamType: stream.mediaStreamType
            });
        }
    });
    const onToggleCamera = (options) => __awaiter$t(void 0, void 0, void 0, function* () {
        const previewOn = _isPreviewOn(callClient.getState().deviceManager);
        if (previewOn && call && call.state === 'Connecting') {
            // This is to workaround: https://skype.visualstudio.com/SPOOL/_workitems/edit/3030558.
            // The root cause of the issue is caused by never transitioning the unparented view to the
            // call object when going from configuration page (disconnected call state) to connecting.
            //
            // Currently the only time the local video stream is moved from unparented view to the call
            // object is when we transition from connecting -> call state. If the camera was on,
            // inside the MediaGallery we trigger toggleCamera. This triggers onStartLocalVideo which
            // destroys the unparentedView and creates a new stream in the call - so all looks well.
            //
            // However, if someone turns off their camera during the lobbyOrConnecting screen, the
            // call.localVideoStreams will be empty (as the stream is currently stored in the unparented
            // views and was never transitioned to the call object) and thus we incorrectly try to create
            // a new video stream for the call object, instead of only stopping the unparented view.
            //
            // The correct fix for this is to ensure that callAgent.onStartCall is called with the
            // localvideostream as a videoOption. That will mean call.onLocalVideoStreamsUpdated will
            // be triggered when the call is in connecting state, which we can then transition the
            // local video stream to the stateful call client and get into a clean state.
            yield onDisposeLocalStreamView();
            return;
        }
        if (call && (_isInCall(call.state) || _isInLobbyOrConnecting(call.state))) {
            const stream = call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
            if (stream) {
                yield onStopLocalVideo(stream);
            }
            else {
                yield onStartLocalVideo();
            }
        }
        else {
            const selectedCamera = callClient.getState().deviceManager.selectedCamera;
            if (selectedCamera) {
                if (previewOn) {
                    yield onDisposeLocalStreamView();
                }
                else {
                    yield callClient.createView(undefined, undefined, {
                        source: selectedCamera,
                        mediaStreamType: 'Video'
                    }, options);
                }
            }
        }
    });
    const onStartCall = (participants, options) => {
        return callAgent ? callAgent.startCall(participants, options) : undefined;
    };
    const onSelectMicrophone = (device) => __awaiter$t(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectMicrophone(device);
    });
    const onSelectSpeaker = (device) => __awaiter$t(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectSpeaker(device);
    });
    const onSelectCamera = (device, options) => __awaiter$t(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        if (call && _isInCall(call.state)) {
            deviceManager.selectCamera(device);
            const stream = call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
            return stream === null || stream === void 0 ? void 0 : stream.switchSource(device);
        }
        else {
            const previewOn = _isPreviewOn(callClient.getState().deviceManager);
            if (!previewOn) {
                deviceManager.selectCamera(device);
                return;
            }
            yield onDisposeLocalStreamView();
            deviceManager.selectCamera(device);
            yield callClient.createView(undefined, undefined, {
                source: device,
                mediaStreamType: 'Video'
            }, options);
        }
    });
    const onToggleMicrophone = () => __awaiter$t(void 0, void 0, void 0, function* () {
        if (!call || !_isInCall(call.state)) {
            throw new Error(`Please invoke onToggleMicrophone after call is started`);
        }
        return call.isMuted ? yield call.unmute() : yield call.mute();
    });
    const onStartScreenShare = () => __awaiter$t(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.startScreenSharing()); });
    const onStopScreenShare = () => __awaiter$t(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.stopScreenSharing()); });
    const onToggleScreenShare = () => __awaiter$t(void 0, void 0, void 0, function* () { return (call === null || call === void 0 ? void 0 : call.isScreenSharingOn) ? yield onStopScreenShare() : yield onStartScreenShare(); });
    const onHangUp = (forEveryone) => __awaiter$t(void 0, void 0, void 0, function* () {
        return yield (call === null || call === void 0 ? void 0 : call.hangUp({
            forEveryone: forEveryone === true ? true : false
        }));
    });
    const onCreateLocalStreamView = (options = {
        scalingMode: 'Crop',
        isMirrored: true
    }) => __awaiter$t(void 0, void 0, void 0, function* () {
        var _a;
        if (!call || call.localVideoStreams.length === 0) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            return;
        }
        const localStream = callState.localVideoStreams.find(item => item.mediaStreamType === 'Video');
        if (!localStream) {
            return;
        }
        const { view } = (_a = (yield callClient.createView(call.id, undefined, localStream, options))) !== null && _a !== void 0 ? _a : {};
        return view ? {
            view
        } : undefined;
    });
    const onCreateRemoteStreamView = (userId, options = {
        scalingMode: 'Crop'
    }) => __awaiter$t(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find(participant => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const remoteVideoStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'ScreenSharing');
        let createViewResult = undefined;
        if (remoteVideoStream && remoteVideoStream.isAvailable && !remoteVideoStream.view) {
            createViewResult = yield callClient.createView(call.id, participant.identifier, remoteVideoStream, options);
        }
        if (screenShareStream && screenShareStream.isAvailable && !screenShareStream.view) {
            // Hardcoded `scalingMode` since it is highly unlikely that CONTOSO would ever want to use a different scaling mode for screenshare.
            // Using `Crop` would crop the contents of screenshare and `Stretch` would warp it.
            // `Fit` is the only mode that maintains the integrity of the screen being shared.
            createViewResult = yield callClient.createView(call.id, participant.identifier, screenShareStream, {
                scalingMode: 'Fit'
            });
        }
        return (createViewResult === null || createViewResult === void 0 ? void 0 : createViewResult.view) ? {
            view: createViewResult === null || createViewResult === void 0 ? void 0 : createViewResult.view
        } : undefined;
    });
    const onDisposeRemoteStreamView = (userId) => __awaiter$t(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find(participant => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const remoteVideoStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'ScreenSharing');
        if (remoteVideoStream && remoteVideoStream.view) {
            callClient.disposeView(call.id, participant.identifier, remoteVideoStream);
        }
        if (screenShareStream && screenShareStream.view) {
            callClient.disposeView(call.id, participant.identifier, screenShareStream);
        }
    });
    const onDisposeLocalStreamView = () => __awaiter$t(void 0, void 0, void 0, function* () {
        // If the user is currently in a call, dispose of the local stream view attached to that call.
        const callState = call && callClient.getState().calls[call.id];
        const localStream = callState === null || callState === void 0 ? void 0 : callState.localVideoStreams.find(item => item.mediaStreamType === 'Video');
        if (call && callState && localStream) {
            callClient.disposeView(call.id, undefined, localStream);
        } // If the user is not in a call we currently assume any unparented view is a LocalPreview and stop all
        // since those are only used for LocalPreview currently.
        // TODO: we need to remember which LocalVideoStream was used for LocalPreview and dispose that one.
        yield disposeAllLocalPreviewViews(callClient);
    });
    const onRemoveParticipant = (userId) => __awaiter$t(void 0, void 0, void 0, function* () {
        const participant = _toCommunicationIdentifier(userId);
        yield (call === null || call === void 0 ? void 0 : call.removeParticipant(participant));
    });
    return {
        onHangUp,
        onSelectCamera,
        onSelectMicrophone,
        onSelectSpeaker,
        onStartCall,
        onStartScreenShare,
        onStopScreenShare,
        onToggleCamera,
        onToggleMicrophone,
        onToggleScreenShare,
        onCreateLocalStreamView,
        onCreateRemoteStreamView,
        onRemoveParticipant,
        onStartLocalVideo,
        onDisposeRemoteStreamView,
        onDisposeLocalStreamView
    };
});
/**
 * Create a set of default handlers for given component. Memoization is applied to the result. Multiple invocations with
 * the same arguments will return the same handler instances. DeclarativeCallAgent, DeclarativeDeviceManager, and
 * DeclarativeCall may be undefined. If undefined, their associated handlers will not be created and returned.
 *
 * @param callClient - StatefulCallClient returned from
 *   {@link @azure/communication-react#createStatefulCallClient}.
 * @param callAgent - Instance of {@link @azure/communication-calling#CallClient}.
 * @param deviceManager - Instance of {@link @azure/communication-calling#DeviceManager}.
 * @param call - Instance of {@link @azure/communication-calling#Call}.
 * @param _ - React component that you want to generate handlers for.
 *
 * @public
 */
const createDefaultCallingHandlersForComponent = (callClient, callAgent, deviceManager, call, _Component) => {
    return createDefaultCallingHandlers(callClient, callAgent, deviceManager, call);
};

/**
 * @private
 */
const CallAgentContext = React.createContext(undefined);
const CallAgentProviderBase = (props) => {
    const { callAgent } = props;
    const initialState = {
        callAgent
    };
    return React__default['default'].createElement(CallAgentContext.Provider, { value: initialState }, props.children);
};
/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#CallAgent}.
 *
 * Calling components from this package must be wrapped with a {@link CallAgentProvider}.
 *
 * @public
 */
const CallAgentProvider = (props) => React__default['default'].createElement(CallAgentProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link @azure/communication-calling#CallAgent} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCallAgent = () => { var _a; return (_a = React.useContext(CallAgentContext)) === null || _a === void 0 ? void 0 : _a.callAgent; };

/**
 * @private
 */
const CallClientContext = React.createContext(undefined);
/**
 * @private
 */
const CallClientProviderBase = (props) => {
    const { callClient } = props;
    const [deviceManager, setDeviceManager] = React.useState(undefined);
    /**
     * Initialize the DeviceManager inside CallClientState
     */
    React.useEffect(() => {
        callClient.getDeviceManager().then(manager => {
            manager.getCameras();
            manager.getMicrophones();
            manager.getSpeakers();
            setDeviceManager(manager);
        }).catch(error => {
            throw new Error(error);
        });
    }, [callClient]);
    const initialState = {
        callClient,
        deviceManager
    };
    return React__default['default'].createElement(CallClientContext.Provider, { value: initialState }, props.children);
};
/**
 * A {@link React.Context} that stores a {@link StatefulCallClient}.
 *
 * Calling components from this package must be wrapped with a {@link CallClientProvider}.
 *
 * @public
 */
const CallClientProvider = (props) => React__default['default'].createElement(CallClientProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link StatefulCallClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCallClient = () => {
    const context = React.useContext(CallClientContext);
    if (context === undefined) {
        throw new Error('CallClient Context is undefined');
    }
    return context.callClient;
};
/**
 * Hook to obtain {@link StatefulDeviceManager} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useDeviceManager = () => {
    var _a;
    return (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.deviceManager;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallContext$2 = React.createContext(undefined);
/**
 * @private
 */
const CallProviderBase = (props) => {
    const { children, call } = props;
    const initialState = {
        call
    };
    return React__default['default'].createElement(CallContext$2.Provider, { value: initialState }, children);
};
/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#Call}.
 *
 * Calling components from this package must be wrapped with a {@link CallProvider}.
 *
 * @public
 */
const CallProvider = (props) => React__default['default'].createElement(CallProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link @azure/communication-calling#Call} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCall = () => {
    var _a;
    return (_a = React.useContext(CallContext$2)) === null || _a === void 0 ? void 0 : _a.call;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const typingIndicatorContainerStyle = react.mergeStyles({
    minHeight: '2.125rem',
    // flexFlow set to column-reverse to align the text to the bottom of the container
    flexFlow: 'column-reverse'
});
/**
 * @private
 */
const typingIndicatorStringStyle = react.mergeStyles({
    fontWeight: 400,
    width: '100%',
    alignSelf: 'center',
    wordBreak: 'break-word'
});

var participantItem$d={isMeText:"(you)",menuTitle:"More Options",removeButtonLabel:"Remove",sharingIconLabel:"Sharing",mutedIconLabel:"Muted",displayNamePlaceholder:"Unnamed Participant",participantStateConnecting:"Calling...",participantStateRinging:"Calling...",participantStateHold:"On hold"};var typingIndicator$d={singleUser:"{user} is typing ...",multipleUsers:"{users} are typing ...",multipleUsersAbbreviateOne:"{users} and 1 other are typing ...",multipleUsersAbbreviateMany:"{users} and {numOthers} others are typing ...",delimiter:", "};var sendBox$d={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit.",sendButtonAriaLabel:"Send message",fileUploadsPendingError:"Uploading... Please wait.",removeFile:"Remove file",uploading:"Uploading",uploadCompleted:"Upload completed"};var messageStatusIndicator$d={deliveredAriaLabel:"Message sent",deliveredTooltipText:"Sent",seenAriaLabel:"Message seen by others",seenTooltipText:"Seen",readByTooltipText:"Read by {messageThreadReadCount} of {remoteParticipantsCount}",sendingAriaLabel:"Message sending",sendingTooltipText:"Sending",failedToSendAriaLabel:"Message failed to send",failedToSendTooltipText:"Failed to send"};var endCallButton$d={label:"Leave",tooltipContent:"Leave call"};var cameraButton$d={onLabel:"Turn off",offLabel:"Turn on",tooltipDisabledContent:"Camera is disabled",tooltipOnContent:"Turn off camera",tooltipOffContent:"Turn on camera",tooltipVideoLoadingContent:"Video is loading",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",cameraButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Turn off camera and camera options",offSplitButtonAriaLabel:"Turn on camera and camera options",cameraActionTurnedOnAnnouncement:"Your camera has been turned on",cameraActionTurnedOffAnnouncement:"Your camera has been turned off"};var microphoneButton$d={onLabel:"Mute",offLabel:"Unmute",tooltipDisabledContent:"Microphone is disabled",tooltipOnContent:"Mute microphone",tooltipOffContent:"Unmute microphone",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker",microphoneButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Mute microphone and audio options",offSplitButtonAriaLabel:"Unmute microphone and audio options",microphoneActionTurnedOnAnnouncement:"Your microphone has been turned on",microphoneActionTurnedOffAnnouncement:"Your microphone has been turned off"};var devicesButton$d={label:"Devices",tooltipContent:"Manage devices",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",audioDeviceMenuTitle:"Audio Device",audioDeviceMenuTooltip:"Choose audio device",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker"};var participantsButton$d={label:"People",tooltipContent:"Show participants",menuHeader:"In this call",participantsListButtonLabel:"{numParticipants} people",muteAllButtonLabel:"Mute all",copyInviteLinkButtonLabel:"Copy invite link"};var screenShareButton$d={onLabel:"Stop presenting",offLabel:"Present",tooltipDisabledContent:"Presenting is disabled",tooltipOnContent:"Presenting your screen",tooltipOffContent:"Present your screen"};var messageThread$d={yesterday:"Yesterday",sunday:"Sunday",monday:"Monday",tuesday:"Tuesday",wednesday:"Wednesday",thursday:"Thursday",friday:"Friday",saturday:"Saturday",participantJoined:"joined the chat.",participantLeft:"left the chat.",editMessage:"Edit",removeMessage:"Delete",resendMessage:"Try sending again",failToSendTag:"Failed to send",editedTag:"Edited",liveAuthorIntro:"{author} says",messageContentAriaText:"{author} said {message}",messageContentMineAriaText:"You said {message}",editBoxTextLimit:"Your message is over the limit of {limitNumber} characters",editBoxPlaceholderText:"Edit your message",newMessagesIndicator:"New messages",noDisplayNameSub:"No name",editBoxCancelButton:"Cancel",editBoxSubmitButton:"Submit",messageReadCount:"Read by {messageReadByCount} of {remoteParticipantsCount}",actionMenuMoreOptions:"More Options",downloadFile:"Download file"};var errorBar$d={unableToReachChatService:"You are offline",accessDenied:"Unable to access chat services - please check the user credentials provided",userNotInChatThread:"You are no longer in this chat thread",sendMessageNotInChatThread:"Failed to send message because you are no longer in this chat thread",sendMessageGeneric:"Failed to send message",callingNetworkFailure:"Troubling connecting call - you seem to be offline",startVideoGeneric:"Failed to start video",stopVideoGeneric:"Failed to stop video",muteGeneric:"Failed to mute microphone",unmuteGeneric:"Failed to unmute microphone",speakingWhileMuted:"Your microphone is muted",startScreenShareGeneric:"Failed to start screen sharing",stopScreenShareGeneric:"Failed to stop screen sharing",callNetworkQualityLow:"Network quality is low.",callNoSpeakerFound:"No speakers or headphones found. Connect an audio device to hear the call.",callNoMicrophoneFound:"No microphones found. Connect an audio input device.",callMicrophoneAccessDenied:"Unable to access microphone. Click the lock in the address bar to grant permission to this webpage.",callMicrophoneMutedBySystem:"You are muted by your system.",callMicrophoneUnmutedBySystem:"Your microphone recovered and you were unmuted by your system.",callMacOsMicrophoneAccessDenied:"Unable to access microphone. Grant microphone permission in your macOS privacy settings.",callLocalVideoFreeze:"Network bandwidth is poor. Your video may appear paused for others on the call.",callCameraAccessDenied:"Unable to access camera. Click the lock in the address bar to grant permission to this webpage.",callCameraAlreadyInUse:"Unable to access camera. It may already be in use by another application.",callVideoStoppedBySystem:"Your video has been stopped by your system.",callVideoRecoveredBySystem:"Your video has resumed.",callMacOsCameraAccessDenied:"MacOS is blocking access to your camera. Update your privacy settings to allow this browser to access your camera.",callMacOsScreenShareAccessDenied:"MacOS is blocking screen sharing. Update your privacy settings to allow this browser to record your screen.",dismissButtonAriaLabel:"Close",failedToJoinCallGeneric:"Failed to join call.",failedToJoinCallInvalidMeetingLink:"Unable to join Meeting. Invalid Link."};var videoGallery$d={screenIsBeingSharedMessage:"You are sharing your screen",screenShareLoadingMessage:"Loading {participant}'s screen",localVideoLabel:"You",localVideoCameraSwitcherLabel:"Switch camera",localVideoMovementLabel:"Movable Local Video Tile",localVideoSelectedDescription:"{cameraName} selected",displayNamePlaceholder:"Unnamed Participant"};var dialpad$d={placeholderText:"Enter phone number",deleteButtonAriaLabel:"Delete"};var holdButton$d={onLabel:"Resume",offLabel:"Hold",tooltipOnContent:"Resume call",tooltipOffContent:"Hold call"};var videoTile$d={participantStateConnecting:"Calling...",participantStateRinging:"Calling...",participantStateHold:"On hold"};var DomainPermissions$d={primaryText:"Allow {appName} to use your camera and microphone",secondaryText:"This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Allow Access"};var UnsupportedBrowser$d={primaryText:"Browser not supported",secondaryText:"Please join this call using a compatible browser.",moreHelpLink:"More help"};var BrowserPermissionDenied$d={primaryText:"Can't use your camera or microphone",secondaryText:"Your browser might not have access to your camera or microphone. To fix this, open System Preferences.",primaryButtonText:"Try again",linkText:"Need help? Get troubleshooting help"};var BrowserPermissionDeniedIOS$d={primaryText:"Allow microphone access to continue",secondaryText:"So other participants can hear you.",primaryButtonText:"Try again",imageAltText:"Microphone and camera device permission location for iOS",linkText:"Need help? Get troubleshooting help",step1Text:"Go to the Settings app",step2Text:"Scroll down to settings for this browser",step3Text:"Turn on Microphone (Camera optional)",step4Text:"Try joining the call again",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var en_US$1 = {participantItem:participantItem$d,typingIndicator:typingIndicator$d,sendBox:sendBox$d,messageStatusIndicator:messageStatusIndicator$d,endCallButton:endCallButton$d,cameraButton:cameraButton$d,microphoneButton:microphoneButton$d,devicesButton:devicesButton$d,participantsButton:participantsButton$d,screenShareButton:screenShareButton$d,messageThread:messageThread$d,errorBar:errorBar$d,videoGallery:videoGallery$d,dialpad:dialpad$d,holdButton:holdButton$d,videoTile:videoTile$d,DomainPermissions:DomainPermissions$d,UnsupportedBrowser:UnsupportedBrowser$d,BrowserPermissionDenied:BrowserPermissionDenied$d,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$d};

var participantItem$c={isMeText:"(you)",menuTitle:"More Options",removeButtonLabel:"Remove",sharingIconLabel:"Sharing",mutedIconLabel:"Muted",displayNamePlaceholder:"Unnamed Participant",participantStateConnecting:"Calling...",participantStateRinging:"Calling...",participantStateHold:"On hold"};var typingIndicator$c={singleUser:"{user} is typing ...",multipleUsers:"{users} are typing ...",multipleUsersAbbreviateOne:"{users} and 1 other are typing ...",multipleUsersAbbreviateMany:"{users} and {numOthers} others are typing ...",delimiter:", "};var sendBox$c={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit.",sendButtonAriaLabel:"Send message",fileUploadsPendingError:"Uploading... Please wait.",removeFile:"Remove file",uploading:"Uploading",uploadCompleted:"Upload completed"};var messageStatusIndicator$c={deliveredAriaLabel:"Message sent",deliveredTooltipText:"Sent",seenAriaLabel:"Message seen by others",seenTooltipText:"Seen",readByTooltipText:"Read by {messageThreadReadCount} of {remoteParticipantsCount}",sendingAriaLabel:"Message sending",sendingTooltipText:"Sending",failedToSendAriaLabel:"Message failed to send",failedToSendTooltipText:"Failed to send"};var endCallButton$c={label:"Leave",tooltipContent:"Leave call"};var cameraButton$c={onLabel:"Turn off",offLabel:"Turn on",tooltipDisabledContent:"Camera is disabled",tooltipOnContent:"Turn off camera",tooltipOffContent:"Turn on camera",tooltipVideoLoadingContent:"Video is loading",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",cameraButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Turn off camera and camera options",offSplitButtonAriaLabel:"Turn on camera and camera options",cameraActionTurnedOnAnnouncement:"Your camera has been turned on",cameraActionTurnedOffAnnouncement:"Your camera has been turned off"};var microphoneButton$c={onLabel:"Mute",offLabel:"Unmute",tooltipDisabledContent:"Microphone is disabled",tooltipOnContent:"Mute microphone",tooltipOffContent:"Unmute microphone",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker",microphoneButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Mute microphone and audio options",offSplitButtonAriaLabel:"Unmute microphone and audio options",microphoneActionTurnedOnAnnouncement:"Your microphone has been turned on",microphoneActionTurnedOffAnnouncement:"Your microphone has been turned off"};var devicesButton$c={label:"Devices",tooltipContent:"Manage devices",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",audioDeviceMenuTitle:"Audio Device",audioDeviceMenuTooltip:"Choose audio device",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker"};var participantsButton$c={label:"People",tooltipContent:"Show participants",menuHeader:"In this call",participantsListButtonLabel:"{numParticipants} people",muteAllButtonLabel:"Mute all",copyInviteLinkButtonLabel:"Copy invite link"};var screenShareButton$c={onLabel:"Stop presenting",offLabel:"Present",tooltipDisabledContent:"Presenting is disabled",tooltipOnContent:"Presenting your screen",tooltipOffContent:"Present your screen"};var messageThread$c={yesterday:"Yesterday",sunday:"Sunday",monday:"Monday",tuesday:"Tuesday",wednesday:"Wednesday",thursday:"Thursday",friday:"Friday",saturday:"Saturday",participantJoined:"joined the chat.",participantLeft:"left the chat.",editMessage:"Edit",removeMessage:"Delete",resendMessage:"Try sending again",failToSendTag:"Failed to send",editedTag:"Edited",liveAuthorIntro:"{author} says",messageContentAriaText:"{author} said {message}",messageContentMineAriaText:"You said {message}",editBoxTextLimit:"Your message is over the limit of {limitNumber} characters",editBoxPlaceholderText:"Edit your message",newMessagesIndicator:"New messages",noDisplayNameSub:"No name",editBoxCancelButton:"Cancel",editBoxSubmitButton:"Submit",messageReadCount:"Read by {messageReadByCount} of {remoteParticipantsCount}",actionMenuMoreOptions:"More Options",downloadFile:"Download file"};var errorBar$c={unableToReachChatService:"You are offline",accessDenied:"Unable to access chat services - please check the user credentials provided",userNotInChatThread:"You are no longer in this chat thread",sendMessageNotInChatThread:"Failed to send message because you are no longer in this chat thread",sendMessageGeneric:"Failed to send message",callingNetworkFailure:"Troubling connecting call - you seem to be offline",startVideoGeneric:"Failed to start video",stopVideoGeneric:"Failed to stop video",muteGeneric:"Failed to mute microphone",unmuteGeneric:"Failed to unmute microphone",speakingWhileMuted:"Your microphone is muted",startScreenShareGeneric:"Failed to start screen sharing",stopScreenShareGeneric:"Failed to stop screen sharing",callNetworkQualityLow:"Network quality is low.",callNoSpeakerFound:"No speakers or headphones found. Connect an audio device to hear the call.",callNoMicrophoneFound:"No microphones found. Connect an audio input device.",callMicrophoneAccessDenied:"Unable to access microphone. Click the lock in the address bar to grant permission to this webpage.",callMicrophoneMutedBySystem:"You are muted by your system.",callMicrophoneUnmutedBySystem:"Your microphone recovered and you were unmuted by your system.",callMacOsMicrophoneAccessDenied:"Unable to access microphone. Grant microphone permission in your macOS privacy settings.",callLocalVideoFreeze:"Network bandwidth is poor. Your video may appear paused for others on the call.",callCameraAccessDenied:"Unable to access camera. Click the lock in the address bar to grant permission to this webpage.",callCameraAlreadyInUse:"Unable to access camera. It may already be in use by another application.",callVideoStoppedBySystem:"Your video has been stopped by your system.",callVideoRecoveredBySystem:"Your video has resumed.",callMacOsCameraAccessDenied:"MacOS is blocking access to your camera. Update your privacy settings to allow this browser to access your camera.",callMacOsScreenShareAccessDenied:"MacOS is blocking screen sharing. Update your privacy settings to allow this browser to record your screen.",dismissButtonAriaLabel:"Close",failedToJoinCallGeneric:"Failed to join call.",failedToJoinCallInvalidMeetingLink:"Unable to join Meeting. Invalid Link."};var videoGallery$c={screenIsBeingSharedMessage:"You are sharing your screen",screenShareLoadingMessage:"Loading {participant}'s screen",localVideoLabel:"You",localVideoCameraSwitcherLabel:"Switch camera",localVideoMovementLabel:"Movable Local Video Tile",localVideoSelectedDescription:"{cameraName} selected",displayNamePlaceholder:"Unnamed Participant"};var dialpad$c={placeholderText:"Enter phone number",deleteButtonAriaLabel:"Delete"};var holdButton$c={onLabel:"Resume",offLabel:"Hold",tooltipOnContent:"Resume call",tooltipOffContent:"Hold call"};var videoTile$c={participantStateConnecting:"Calling...",participantStateRinging:"Calling...",participantStateHold:"On hold"};var DomainPermissions$c={primaryText:"Allow {appName} to use your camera and microphone",secondaryText:"This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Allow Access"};var UnsupportedBrowser$c={primaryText:"Browser not supported",secondaryText:"Please join this call using a compatible browser.",moreHelpLink:"More help"};var BrowserPermissionDenied$c={primaryText:"Can't use your camera or microphone",secondaryText:"Your browser might not have access to your camera or microphone. To fix this, open System Preferences.",primaryButtonText:"Try again",linkText:"Need help? Get troubleshooting help"};var BrowserPermissionDeniedIOS$c={primaryText:"Allow microphone access to continue",secondaryText:"So other participants can hear you.",primaryButtonText:"Try again",imageAltText:"Microphone and camera device permission location for iOS",linkText:"Need help? Get troubleshooting help",step1Text:"Go to the Settings app",step2Text:"Scroll down to settings for this browser",step3Text:"Turn on Microphone (Camera optional)",step4Text:"Try joining the call again",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var en_GB$1 = {participantItem:participantItem$c,typingIndicator:typingIndicator$c,sendBox:sendBox$c,messageStatusIndicator:messageStatusIndicator$c,endCallButton:endCallButton$c,cameraButton:cameraButton$c,microphoneButton:microphoneButton$c,devicesButton:devicesButton$c,participantsButton:participantsButton$c,screenShareButton:screenShareButton$c,messageThread:messageThread$c,errorBar:errorBar$c,videoGallery:videoGallery$c,dialpad:dialpad$c,holdButton:holdButton$c,videoTile:videoTile$c,DomainPermissions:DomainPermissions$c,UnsupportedBrowser:UnsupportedBrowser$c,BrowserPermissionDenied:BrowserPermissionDenied$c,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$c};

var participantItem$b={isMeText:"(Sie)",menuTitle:"Weitere Optionen",removeButtonLabel:"Entfernen",sharingIconLabel:"Teilen",mutedIconLabel:"Stumm geschaltet",displayNamePlaceholder:"Unbenannter Teilnehmer",participantStateConnecting:"Anrufen...",participantStateRinging:"Anrufen...",participantStateHold:"In der Warteschleife"};var typingIndicator$b={singleUser:"{user} schreibt ...",multipleUsers:"{users} schreiben ...",multipleUsersAbbreviateOne:"{users} und 1 andere Person schreiben ...",multipleUsersAbbreviateMany:"{users} und {numOthers} andere schreiben ...",delimiter:", "};var sendBox$b={placeholderText:"Nachricht eingeben",textTooLong:"Ihre Nachrichtenlnge berschreitet den maximalen Grenzwert.",sendButtonAriaLabel:"Nachricht senden",fileUploadsPendingError:"Wird hochgeladen... Bitte warten.",removeFile:"Datei entfernen",uploading:"Hochladen",uploadCompleted:"Upload abgeschlossen"};var messageStatusIndicator$b={deliveredAriaLabel:"Nachricht gesendet",deliveredTooltipText:"Gesendet",seenAriaLabel:"Nachricht von anderen gesehen",seenTooltipText:"Gesehen",readByTooltipText:"Gelesen von {messageThreadReadCount} von {remoteParticipantsCount}",sendingAriaLabel:"Nachricht wird gesendet",sendingTooltipText:"Wird gesendet",failedToSendAriaLabel:"Nachricht konnte nicht gesendet werden",failedToSendTooltipText:"Fehler beim Senden"};var endCallButton$b={label:"Verlassen",tooltipContent:"Anruf verlassen"};var cameraButton$b={onLabel:"Deaktivieren",offLabel:"Aktivieren",tooltipDisabledContent:"Kamera ist deaktiviert",tooltipOnContent:"Kamera ausschalten",tooltipOffContent:"Kamera einschalten",tooltipVideoLoadingContent:"Video wird geladen",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera auswhlen",cameraButtonSplitRoleDescription:"Unterteilte Schaltflche",onSplitButtonAriaLabel:"Kamera und Kameraoptionen deaktivieren",offSplitButtonAriaLabel:"Kamera und Kameraoptionen aktivieren",cameraActionTurnedOnAnnouncement:"Ihre Kamera wurde eingeschaltet.",cameraActionTurnedOffAnnouncement:"Ihre Kamera wurde ausgeschaltet."};var microphoneButton$b={onLabel:"Stumm schalten",offLabel:"Stummschaltung aufheben",tooltipDisabledContent:"Mikrofon ist deaktiviert",tooltipOnContent:"Mikrofon stummschalten",tooltipOffContent:"Mikrofonstummschaltung aufheben",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon auswhlen",speakerMenuTitle:"Lautsprecher",speakerMenuTooltip:"Lautsprecher auswhlen",microphoneButtonSplitRoleDescription:"Unterteilte Schaltflche",onSplitButtonAriaLabel:"Mikrofon- und Audiooptionen stummschalten",offSplitButtonAriaLabel:"Stummschaltung von Mikrofon- und Audiooptionen aufheben",microphoneActionTurnedOnAnnouncement:"Ihr Mikrofon wurde eingeschaltet.",microphoneActionTurnedOffAnnouncement:"Ihr Mikrofon wurde ausgeschaltet."};var devicesButton$b={label:"Gerte",tooltipContent:"Gerte verwalten",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera auswhlen",audioDeviceMenuTitle:"Audiogert",audioDeviceMenuTooltip:"Audiogert auswhlen",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon auswhlen",speakerMenuTitle:"Lautsprecher",speakerMenuTooltip:"Lautsprecher auswhlen"};var participantsButton$b={label:"Personen",tooltipContent:"Teilnehmende anzeigen",menuHeader:"In diesem Anruf",participantsListButtonLabel:"{numParticipants}Personen",muteAllButtonLabel:"Alle stumm schalten",copyInviteLinkButtonLabel:"Einladungslink kopieren"};var screenShareButton$b={onLabel:"Prsentation beenden",offLabel:"Prsentieren",tooltipDisabledContent:"Prsentieren ist deaktiviert",tooltipOnContent:"Ihr Bildschirm wird prsentiert",tooltipOffContent:"Prsentieren Sie Ihren Bildschirm"};var messageThread$b={yesterday:"Gestern",sunday:"Sonntag",monday:"Montag",tuesday:"Dienstag",wednesday:"Mittwoch",thursday:"Donnerstag",friday:"Freitag",saturday:"Samstag",participantJoined:"ist dem Chat beigetreten.",participantLeft:"hat den Chat verlassen.",editMessage:"Bearbeiten",removeMessage:"Lschen",resendMessage:"Erneut senden",failToSendTag:"Fehler beim Senden",editedTag:"Bearbeitet",liveAuthorIntro:"{author} sagt",messageContentAriaText:"{author} hat {message} gesagt",messageContentMineAriaText:"Sie sagten {message}",editBoxTextLimit:"Ihre Nachricht berschreitet das Limit von {limitNumber} Zeichen.",editBoxPlaceholderText:"Bearbeiten Sie Ihre Nachricht",newMessagesIndicator:"Neue Nachrichten",noDisplayNameSub:"Kein Name",editBoxCancelButton:"Abbrechen",editBoxSubmitButton:"bermitteln",messageReadCount:"Gelesen von {messageReadByCount} von {remoteParticipantsCount}",actionMenuMoreOptions:"Weitere Optionen",downloadFile:"Datei herunterladen"};var errorBar$b={unableToReachChatService:"Sie sind offline.",accessDenied:"Auf die Chatdienste kann nicht zugegriffen werden. berprfen Sie die angegebenen Benutzeranmeldeinformationen.",userNotInChatThread:"Sie sind nicht mehr in diesem Chatthread vertreten.",sendMessageNotInChatThread:"Fehler beim Senden der Nachricht, weil Sie sich nicht mehr in diesem Chatthread befinden.",sendMessageGeneric:"Fehler beim Senden der Nachricht",callingNetworkFailure:"Problematische Anrufverbindung  Sie scheinen offline zu sein",startVideoGeneric:"Video konnte nicht gestartet werden",stopVideoGeneric:"Video konnte nicht beendet werden",muteGeneric:"Mikrofon konnte nicht stummgeschaltet werden",unmuteGeneric:"Stummschaltung des Mikrofons konnte nicht beendet werden",speakingWhileMuted:"Ihr Mikrofon ist stummgeschaltet",startScreenShareGeneric:"Bildschirmfreigabe konnte nicht gestartet werden",stopScreenShareGeneric:"Bildschirmfreigabe konnte nicht beendet werden",callNetworkQualityLow:"Die Netzwerkqualitt ist niedrig.",callNoSpeakerFound:"Keine Lautsprecher oder Kopfhrer gefunden. Schlieen Sie ein Audiogert an, um den Anruf zu hren.",callNoMicrophoneFound:"Es wurden keine Mikrofone gefunden. Schlieen Sie ein Audioeingabegert an.",callMicrophoneAccessDenied:"Auf das Mikrofon kann nicht zugegriffen werden. Klicken Sie auf die Sperre in der Adressleiste, um dieser Webseite Berechtigungen zu erteilen.",callMicrophoneMutedBySystem:"Sie werden von Ihrem System stummgeschaltet.",callMicrophoneUnmutedBySystem:"Ihr Mikrofon wurde wiederhergestellt, und Ihr System hat die Stummschaltung aufgehoben.",callMacOsMicrophoneAccessDenied:"Auf das Mikrofon kann nicht zugegriffen werden. Erteilen Sie die Mikrofonberechtigung in Ihren macOS-Datenschutzeinstellungen.",callLocalVideoFreeze:"Die Netzwerkbandbreite ist schlecht. Ihr Video wird mglicherweise fr andere Personen whrend des Anrufs angehalten angezeigt.",callCameraAccessDenied:"Auf die Kamera kann nicht zugegriffen werden. Klicken Sie auf die Sperre in der Adressleiste, um dieser Webseite Berechtigungen zu erteilen.",callCameraAlreadyInUse:"Auf die Kamera kann nicht zugegriffen werden. Sie wird mglicherweise bereits von einer anderen Anwendung verwendet.",callVideoStoppedBySystem:"Ihr Video wurde von Ihrem System beendet.",callVideoRecoveredBySystem:"Ihr Video wurde fortgesetzt.",callMacOsCameraAccessDenied:"MacOS blockiert den Zugriff auf Ihre Kamera. Aktualisieren Sie Ihre Datenschutzeinstellungen, damit dieser Browser auf Ihre Kamera zugreifen kann.",callMacOsScreenShareAccessDenied:"MacOS blockiert die Bildschirmfreigabe. Aktualisieren Sie Ihre Datenschutzeinstellungen, damit dieser Browser Ihren Bildschirm aufzeichnen kann.",dismissButtonAriaLabel:"Schlieen",failedToJoinCallGeneric:"Fehler bei der Teilnahme am Anruf.",failedToJoinCallInvalidMeetingLink:"Teilnahme an Besprechung nicht mglich. Ungltiger Link."};var videoGallery$b={screenIsBeingSharedMessage:"Sie teilen Ihren Bildschirm",screenShareLoadingMessage:"Der Bildschirm von {participant} wird geladen",localVideoLabel:"Sie",localVideoCameraSwitcherLabel:"Kamera wechseln",localVideoMovementLabel:"Verschiebbare lokale Videokachel",localVideoSelectedDescription:"{cameraName} ausgewhlt",displayNamePlaceholder:"Unbenannter Teilnehmer"};var dialpad$b={placeholderText:"Telefonnummer eingeben",deleteButtonAriaLabel:"Lschen"};var holdButton$b={onLabel:"Fortsetzen",offLabel:"Halten",tooltipOnContent:"Anruf fortsetzen",tooltipOffContent:"Anruf halten"};var videoTile$b={participantStateConnecting:"Anrufen...",participantStateRinging:"Anrufen...",participantStateHold:"In der Warteschleife"};var DomainPermissions$b={primaryText:"Zulassen, dass {appName} Ihre Kamera und Ihr Mikrofon verwendet",secondaryText:"So knnen die Teilnehmer Sie sehen und hren.",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Zugriff erlauben"};var UnsupportedBrowser$b={primaryText:"Der Browser wird nicht untersttzt.",secondaryText:"Bitte nehmen Sie ber einen kompatiblen Browser an diesem Anruf teil.",moreHelpLink:"Weitere Hilfe"};var BrowserPermissionDenied$b={primaryText:"Kamera oder Mikrofon kann nicht verwendet werden",secondaryText:"Ihr Browser hat mglicherweise keinen Zugriff auf Ihre Kamera oder Ihr Mikrofon. ffnen Sie die Systemeinstellungen, um dieses Problem zu beheben.",primaryButtonText:"Erneut versuchen",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung"};var BrowserPermissionDeniedIOS$b={primaryText:"Mikrofonzugriff zulassen, um fortzufahren",secondaryText:"Damit andere Teilnehmer Sie hren knnen.",primaryButtonText:"Erneut versuchen",imageAltText:"Berechtigungsspeicherort fr Mikrofon- und Kameragerte fr iOS",linkText:"Bentigen Sie Hilfe? Hilfe zur Problembehandlung",step1Text:"Zur Einstellungs-App wechseln",step2Text:"Scrollen Sie nach unten zu den Einstellungen dieses Browsers",step3Text:"Mikrofon einschalten (Kamera optional)",step4Text:"Versuchen Sie erneut, dem Anruf beizutreten",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var de_DE$1 = {participantItem:participantItem$b,typingIndicator:typingIndicator$b,sendBox:sendBox$b,messageStatusIndicator:messageStatusIndicator$b,endCallButton:endCallButton$b,cameraButton:cameraButton$b,microphoneButton:microphoneButton$b,devicesButton:devicesButton$b,participantsButton:participantsButton$b,screenShareButton:screenShareButton$b,messageThread:messageThread$b,errorBar:errorBar$b,videoGallery:videoGallery$b,dialpad:dialpad$b,holdButton:holdButton$b,videoTile:videoTile$b,DomainPermissions:DomainPermissions$b,UnsupportedBrowser:UnsupportedBrowser$b,BrowserPermissionDenied:BrowserPermissionDenied$b,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$b};

var participantItem$a={isMeText:"(t)",menuTitle:"Ms opciones",removeButtonLabel:"Quitar",sharingIconLabel:"Compartiendo",mutedIconLabel:"Silenciado",displayNamePlaceholder:"Participante sin nombre",participantStateConnecting:"Llamando...",participantStateRinging:"Llamando...",participantStateHold:"En espera"};var typingIndicator$a={singleUser:"{user} est escribiendo...",multipleUsers:"{users} estn escribiendo...",multipleUsersAbbreviateOne:"{users} y 1 usuario ms estn escribiendo...",multipleUsersAbbreviateMany:"{users} y {numOthers} usuarios ms estn escribiendo...",delimiter:", "};var sendBox$a={placeholderText:"Escribir un mensaje",textTooLong:"La longitud del mensaje supera el lmite mximo.",sendButtonAriaLabel:"Enviar mensaje",fileUploadsPendingError:"Cargando... Espere.",removeFile:"Quitar archivo",uploading:"Cargando",uploadCompleted:"Carga completada"};var messageStatusIndicator$a={deliveredAriaLabel:"Mensaje enviado",deliveredTooltipText:"Enviado",seenAriaLabel:"Mensaje visto por otros usuarios",seenTooltipText:"Visto",readByTooltipText:"Ledo por {messageThreadReadCount} de {remoteParticipantsCount}",sendingAriaLabel:"Envo de mensajes",sendingTooltipText:"Enviando",failedToSendAriaLabel:"Error al enviar el mensaje",failedToSendTooltipText:"Error al enviar"};var endCallButton$a={label:"Baja",tooltipContent:"Abandonar llamada"};var cameraButton$a={onLabel:"Desactivar",offLabel:"Activar",tooltipDisabledContent:"La cmara est deshabilitada",tooltipOnContent:"Desconectar la cmara",tooltipOffContent:"Activar la cmara",tooltipVideoLoadingContent:"El vdeo se est cargando",cameraMenuTitle:"Cmara",cameraMenuTooltip:"Elegir cmara",cameraButtonSplitRoleDescription:"Botn de expansin",onSplitButtonAriaLabel:"Desactivar la cmara y las opciones de cmara",offSplitButtonAriaLabel:"Activar la cmara y las opciones de cmara",cameraActionTurnedOnAnnouncement:"La cmara se ha activado",cameraActionTurnedOffAnnouncement:"La cmara se ha desactivado"};var microphoneButton$a={onLabel:"Silenciar",offLabel:"Reactivar audio",tooltipDisabledContent:"Micrfono deshabilitado",tooltipOnContent:"Silenciar micrfono",tooltipOffContent:"Reactivar micrfono",microphoneMenuTitle:"Micrfono",microphoneMenuTooltip:"Elegir micrfono",speakerMenuTitle:"Altavoz",speakerMenuTooltip:"Elegir altavoz",microphoneButtonSplitRoleDescription:"Botn de expansin",onSplitButtonAriaLabel:"Silenciar opciones de micrfono y audio",offSplitButtonAriaLabel:"Reactivar el micrfono y las opciones de audio",microphoneActionTurnedOnAnnouncement:"El micrfono se ha activado",microphoneActionTurnedOffAnnouncement:"El micrfono se ha desactivado"};var devicesButton$a={label:"Dispositivos",tooltipContent:"Administrar dispositivos",cameraMenuTitle:"Cmara",cameraMenuTooltip:"Elegir cmara",audioDeviceMenuTitle:"Dispositivo de audio",audioDeviceMenuTooltip:"Elegir dispositivo de audio",microphoneMenuTitle:"Micrfono",microphoneMenuTooltip:"Elegir micrfono",speakerMenuTitle:"Altavoz",speakerMenuTooltip:"Elegir altavoz"};var participantsButton$a={label:"Contactos",tooltipContent:"Mostrar participantes",menuHeader:"En esta llamada",participantsListButtonLabel:"{numParticipants} personas",muteAllButtonLabel:"Silenciar a todos",copyInviteLinkButtonLabel:"Copiar vnculo de invitacin"};var screenShareButton$a={onLabel:"Dejar de presentar",offLabel:"Presentar",tooltipDisabledContent:"La presentacin est deshabilitada",tooltipOnContent:"Presentando su pantalla",tooltipOffContent:"Presentar la pantalla"};var messageThread$a={yesterday:"Ayer",sunday:"Domingo",monday:"Lunes",tuesday:"Martes",wednesday:"Mircoles",thursday:"Jueves",friday:"Viernes",saturday:"Sbado",participantJoined:"se uni al chat.",participantLeft:"abandon el chat.",editMessage:"Editar",removeMessage:"Eliminar",resendMessage:"Intente enviar de nuevo",failToSendTag:"Error al enviar",editedTag:"Editado",liveAuthorIntro:"{author} dice",messageContentAriaText:"{author} dijo {message}",messageContentMineAriaText:"Has dicho {message}",editBoxTextLimit:"El mensaje supera el lmite de {limitNumber} caracteres",editBoxPlaceholderText:"Editar el mensaje",newMessagesIndicator:"Mensajes nuevos",noDisplayNameSub:"Sin nombre",editBoxCancelButton:"Cancelar",editBoxSubmitButton:"Enviar",messageReadCount:"Ledo por {messageReadByCount} de {remoteParticipantsCount}",actionMenuMoreOptions:"Ms opciones",downloadFile:"Descargar archivo"};var errorBar$a={unableToReachChatService:"Sin conexin",accessDenied:"No se puede acceder a los servicios de chat. Compruebe las credenciales de usuario proporcionadas.",userNotInChatThread:"Ya no est en este hilo de chat",sendMessageNotInChatThread:"No se pudo enviar el mensaje porque ya no est en este hilo de chat",sendMessageGeneric:"Error al enviar el mensaje",callingNetworkFailure:"Problema al conectar la llamada; parece que no hay conexin",startVideoGeneric:"No se pudo iniciar el vdeo",stopVideoGeneric:"No se pudo detener el vdeo",muteGeneric:"No se pudo silenciar el micrfono",unmuteGeneric:"No se pudo reactivar el micrfono",speakingWhileMuted:"El micrfono est desactivado",startScreenShareGeneric:"No se pudo iniciar la pantalla compartida",stopScreenShareGeneric:"No se pudo detener la pantalla compartida",callNetworkQualityLow:"La calidad de la red es baja.",callNoSpeakerFound:"No se encontraron altavoces ni auriculares. Conecta un dispositivo de audio para escuchar la llamada.",callNoMicrophoneFound:"No se encontraron micrfonos. Conecta un dispositivo de entrada de audio.",callMicrophoneAccessDenied:"No se puede acceder al micrfono. Haga clic en el bloqueo de la barra de direcciones para conceder permiso a esta pgina web.",callMicrophoneMutedBySystem:"Su sistema ha silenciado su audio.",callMicrophoneUnmutedBySystem:"Su micrfono se ha recuperado y el sistema ha activado el audio.",callMacOsMicrophoneAccessDenied:"No se puede acceder al micrfono. Conceda permiso al micrfono en la configuracin de privacidad de macOS.",callLocalVideoFreeze:"El ancho de banda de red es deficiente. Es posible que el vdeo aparezca pausado para otros usuarios en la llamada.",callCameraAccessDenied:"No se puede acceder a la cmara. Haga clic en el bloqueo de la barra de direcciones para conceder permiso a esta pgina web.",callCameraAlreadyInUse:"No se puede acceder a la cmara. Puede que ya la est usando otra aplicacin.",callVideoStoppedBySystem:"El sistema ha detenido el vdeo.",callVideoRecoveredBySystem:"El vdeo se ha reanudado.",callMacOsCameraAccessDenied:"MacOS est bloqueando el acceso a la cmara. Actualiza la configuracin de privacidad para permitir que este explorador acceda a la cmara.",callMacOsScreenShareAccessDenied:"MacOS est bloqueando el uso compartido de la pantalla. Actualice la configuracin de privacidad para permitir que este explorador grabe la pantalla.",dismissButtonAriaLabel:"Cerrar",failedToJoinCallGeneric:"No se pudo unir a la llamada.",failedToJoinCallInvalidMeetingLink:"No se puede unir a la reunin. Vnculo no vlido."};var videoGallery$a={screenIsBeingSharedMessage:"Est compartiendo su pantalla",screenShareLoadingMessage:"Cargando la pantalla de {participant}",localVideoLabel:"T",localVideoCameraSwitcherLabel:"Cambiar de cmara",localVideoMovementLabel:"Mosaico de vdeo local movible",localVideoSelectedDescription:"{cameraName} seleccionada",displayNamePlaceholder:"Participante sin nombre"};var dialpad$a={placeholderText:"Introduzca el nmero de telfono",deleteButtonAriaLabel:"Eliminar"};var holdButton$a={onLabel:"Reanudar",offLabel:"En espera",tooltipOnContent:"Reanudar llamada",tooltipOffContent:"Poner llamada en espera"};var videoTile$a={participantStateConnecting:"Llamando...",participantStateRinging:"Llamando...",participantStateHold:"En espera"};var DomainPermissions$a={primaryText:"Permitir que {appName} usen la cmara y el micrfono",secondaryText:"Esto es para que los participantes puedan verle y orle.",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas",primaryButtonText:"Permitir acceso"};var UnsupportedBrowser$a={primaryText:"Explorador no compatible",secondaryText:"nase a esta llamada con un explorador compatible.",moreHelpLink:"Ms ayuda"};var BrowserPermissionDenied$a={primaryText:"No se puede usar la cmara o el micrfono",secondaryText:"Es posible que el explorador no tenga acceso a la cmara o al micrfono. Para solucionar este problema, abra Preferencias del sistema.",primaryButtonText:"Intentar de nuevo",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas"};var BrowserPermissionDeniedIOS$a={primaryText:"Permite el acceso al micrfono para continuar",secondaryText:"Para que otros participantes puedan orte.",primaryButtonText:"Intentar de nuevo",imageAltText:"Ubicacin de permisos del dispositivo de micrfono y cmara para iOS",linkText:"Necesitas ayuda? Obtn ayuda para la solucin de problemas",step1Text:"Ve a la aplicacin de Configuracin",step2Text:"Desplzate hacia abajo hasta la configuracin de este explorador",step3Text:"Activar micrfono (cmara opcional)",step4Text:"Intenta unirte de nuevo a la llamada",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var es_ES$1 = {participantItem:participantItem$a,typingIndicator:typingIndicator$a,sendBox:sendBox$a,messageStatusIndicator:messageStatusIndicator$a,endCallButton:endCallButton$a,cameraButton:cameraButton$a,microphoneButton:microphoneButton$a,devicesButton:devicesButton$a,participantsButton:participantsButton$a,screenShareButton:screenShareButton$a,messageThread:messageThread$a,errorBar:errorBar$a,videoGallery:videoGallery$a,dialpad:dialpad$a,holdButton:holdButton$a,videoTile:videoTile$a,DomainPermissions:DomainPermissions$a,UnsupportedBrowser:UnsupportedBrowser$a,BrowserPermissionDenied:BrowserPermissionDenied$a,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$a};

var participantItem$9={isMeText:"(vous)",menuTitle:"Plus doptions",removeButtonLabel:"Supprimer",sharingIconLabel:"Partage",mutedIconLabel:"Muet activ",displayNamePlaceholder:"Participant non identifi",participantStateConnecting:"Appel en cours...",participantStateRinging:"Appel en cours...",participantStateHold:"En attente"};var typingIndicator$9={singleUser:"{user} en train dcrire...",multipleUsers:"{users} sont en train d'crire...",multipleUsersAbbreviateOne:"{users} et 1 autre en train d'crire...",multipleUsersAbbreviateMany:"{users} et {numOthers} autres en train dcrire...",delimiter:", "};var sendBox$9={placeholderText:"Saisir un message",textTooLong:"La longueur de votre message dpasse la limite maximale.",sendButtonAriaLabel:"Envoyer un message",fileUploadsPendingError:"Chargement en cours... Veuillez patienter.",removeFile:"Supprimer un fichier",uploading:"Chargement",uploadCompleted:"Tlchargement termin"};var messageStatusIndicator$9={deliveredAriaLabel:"Message envoy",deliveredTooltipText:"Envoy",seenAriaLabel:"Message vu par dautres personnes",seenTooltipText:"Vu",readByTooltipText:"Lu par {messageThreadReadCount} participants sur {remoteParticipantsCount}",sendingAriaLabel:"Envoi du message",sendingTooltipText:"Envoi",failedToSendAriaLabel:"chec d'envoi du message",failedToSendTooltipText:"chec de l'envoi"};var endCallButton$9={label:"Quitter",tooltipContent:"Quitter l'appel"};var cameraButton$9={onLabel:"Dsactiver",offLabel:"Activer",tooltipDisabledContent:"La camra est dsactive.",tooltipOnContent:"Dsactiver la camra",tooltipOffContent:"Activer la camra",tooltipVideoLoadingContent:"Chargement de la vido",cameraMenuTitle:"Camra",cameraMenuTooltip:"Choisissez l'appareil photo",cameraButtonSplitRoleDescription:"Bouton partag",onSplitButtonAriaLabel:"Dsactiver les options dappareil photo et dappareil photo",offSplitButtonAriaLabel:"Activer les options dappareil photo et dappareil photo",cameraActionTurnedOnAnnouncement:"Votre camra a t active",cameraActionTurnedOffAnnouncement:"Votre camra a t dsactive"};var microphoneButton$9={onLabel:"Dsactiver le son",offLabel:"Ractiver le son",tooltipDisabledContent:"Le microphone est dsactiv.",tooltipOnContent:"Dsactiver le micro",tooltipOffContent:"Activer le micro",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choisissez le micro",speakerMenuTitle:"Haut-parleur",speakerMenuTooltip:"Choisissez le haut-parleur",microphoneButtonSplitRoleDescription:"Bouton partag",onSplitButtonAriaLabel:"Dsactiver le micro et les options audio",offSplitButtonAriaLabel:"Activer le son du microphone et des options audio",microphoneActionTurnedOnAnnouncement:"Votre micro a t activ",microphoneActionTurnedOffAnnouncement:"Votre micro a t dsactiv"};var devicesButton$9={label:"Appareils",tooltipContent:"Grer les appareils",cameraMenuTitle:"Appareil photo",cameraMenuTooltip:"Choisissez l'appareil photo",audioDeviceMenuTitle:"Priphrique audio",audioDeviceMenuTooltip:"Choisissez un priphrique audio",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choisissez le micro",speakerMenuTitle:"Haut-parleur",speakerMenuTooltip:"Choisissez le haut-parleur"};var participantsButton$9={label:"Personnes",tooltipContent:"Afficher les participants",menuHeader:"Pendant cet appel",participantsListButtonLabel:"{numParticipants} contacts",muteAllButtonLabel:"Dsactiver tous les micros",copyInviteLinkButtonLabel:"Copier le lien d'invitation"};var screenShareButton$9={onLabel:"Arrter la prsentation",offLabel:"Prsenter",tooltipDisabledContent:"La prsentation est dsactive.",tooltipOnContent:"Prsentation de votre cran",tooltipOffContent:"Prsenter votre cran"};var messageThread$9={yesterday:"Hier",sunday:"Dimanche",monday:"Lundi",tuesday:"Mardi",wednesday:"Mercredi",thursday:"Jeudi",friday:"Vendredi",saturday:"Samedi",participantJoined:"a rejoint la conversation.",participantLeft:"a quitt le conversation.",editMessage:"Modifier",removeMessage:"Supprimer",resendMessage:"Ressayer l'envoi",failToSendTag:"chec de l'envoi",editedTag:"Modifi",liveAuthorIntro:"{author} dit",messageContentAriaText:"{author} a dit {message}",messageContentMineAriaText:"Vous avez dit {message}",editBoxTextLimit:"Votre message dpasse la limite de {limitNumber} caractres",editBoxPlaceholderText:"Modifier votre message",newMessagesIndicator:"Nouveaux messages",noDisplayNameSub:"Sans nom",editBoxCancelButton:"Annuler",editBoxSubmitButton:"Envoyer",messageReadCount:"Lu par {messageReadByCount} participants sur {remoteParticipantsCount}",actionMenuMoreOptions:"Plus doptions",downloadFile:"Tlcharger un fichier"};var errorBar$9={unableToReachChatService:"Vous tes hors connexion",accessDenied:"Impossible daccder aux services de conversation. Vrifiez les informations didentification de lutilisateur fournies",userNotInChatThread:"Vous nest plus dans ce thread de conversation",sendMessageNotInChatThread:"chec de lenvoi du message car vous ntes plus dans ce thread de conversation",sendMessageGeneric:"chec de lenvoi du message",callingNetworkFailure:"Perturbation de lappel de connexion : vous semblez tre hors connexion",startVideoGeneric:"chec du dmarrage de la vido",stopVideoGeneric:"chec de larrt de la vido",muteGeneric:"chec de la dsactivation du son du microphone",unmuteGeneric:"chec de lactivation du son du microphone",speakingWhileMuted:"Votre micro est dsactiv",startScreenShareGeneric:"chec du dmarrage du partage dcran",stopScreenShareGeneric:"chec de larrt du partage dcran",callNetworkQualityLow:"La qualit de rseau est faible.",callNoSpeakerFound:"Aucun haut-parleur ou casque na t trouv. Connectez un priphrique audio pour entendre lappel.",callNoMicrophoneFound:"Aucun micro na t trouv. Connectez un priphrique dentre audio.",callMicrophoneAccessDenied:"Impossible daccder au microphone. Cliquez sur le verrou dans la barre dadresses pour accorder lautorisation  cette page Web.",callMicrophoneMutedBySystem:"Votre micro est dsactiv par votre systme.",callMicrophoneUnmutedBySystem:"Votre micro a t rcupr et la son a t activ par votre systme.",callMacOsMicrophoneAccessDenied:"Impossible daccder au microphone. Accordez lautorisation de microphone dans vos paramtres de confidentialit macOS.",callLocalVideoFreeze:"La bande passante rseau est mdiocre. Votre vido peut apparatre suspendue pour les autres participants  lappel.",callCameraAccessDenied:"Impossible daccder  la camra. Cliquez sur le verrou dans la barre dadresses pour accorder lautorisation  cette page Web.",callCameraAlreadyInUse:"Impossible daccder  la camra. Il est peut-tre dj utilis par une autre application.",callVideoStoppedBySystem:"Votre vido a t arrte par votre systme.",callVideoRecoveredBySystem:"Votre vido a repris.",callMacOsCameraAccessDenied:"MacOS bloque laccs  votre camra. Mettez  jour vos paramtres de confidentialit pour autoriser ce navigateur  accder  votre camra.",callMacOsScreenShareAccessDenied:"MacOS bloque le partage dcran. Mettez  jour vos paramtres de confidentialit pour permettre  ce navigateur denregistrer votre cran.",dismissButtonAriaLabel:"Fermer",failedToJoinCallGeneric:"Nous navons pas pu rejoindre lappel.",failedToJoinCallInvalidMeetingLink:"Impossible de rejoindre la runion. Lien non valide."};var videoGallery$9={screenIsBeingSharedMessage:"Vous partagez votre cran.",screenShareLoadingMessage:"Chargement de lcran de {participant}",localVideoLabel:"Vous",localVideoCameraSwitcherLabel:"Changer de camra",localVideoMovementLabel:"Vignette de vido locale dplaable",localVideoSelectedDescription:"{cameraName} slectionne",displayNamePlaceholder:"Participant non identifi"};var dialpad$9={placeholderText:"Entrer un numro de tlphone",deleteButtonAriaLabel:"Supprimer"};var holdButton$9={onLabel:"Reprendre",offLabel:"Mettre en attente",tooltipOnContent:"Reprendre lappel",tooltipOffContent:"Mettre lappel en attente"};var videoTile$9={participantStateConnecting:"Appel en cours...",participantStateRinging:"Appel en cours...",participantStateHold:"En attente"};var DomainPermissions$9={primaryText:"Autoriser {appName}  utiliser votre camra et votre microphone",secondaryText:"Cela permet aux participants de vous voir et de vous entendre.",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes",primaryButtonText:"Autoriser laccs"};var UnsupportedBrowser$9={primaryText:"Navigateur non pris en charge",secondaryText:"Rejoignez cet appel  laide dun navigateur compatible.",moreHelpLink:"Plus d'aide"};var BrowserPermissionDenied$9={primaryText:"Impossible dutiliser votre camra ou votre micro",secondaryText:"Votre navigateur na peut-tre pas accs  votre camra ou  votre micro. Pour rsoudre ce problme, ouvrez Prfrences systme.",primaryButtonText:"Ressayer",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes"};var BrowserPermissionDeniedIOS$9={primaryText:"Autoriser laccs au microphone pour continuer",secondaryText:"Ainsi, les autres participants peuvent vous entendre.",primaryButtonText:"Ressayer",imageAltText:"Emplacement des autorisations pour le microphone et la camra pour iOS",linkText:"Besoin daide? Obtenir de laide sur la rsolution des problmes",step1Text:"Accder  lapplication Paramtres",step2Text:"Faites dfiler vers le bas pour accder aux paramtres de ce navigateur",step3Text:"Activer le microphone (camra facultative)",step4Text:"Ressayez de rejoindre lappel",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var fr_FR$1 = {participantItem:participantItem$9,typingIndicator:typingIndicator$9,sendBox:sendBox$9,messageStatusIndicator:messageStatusIndicator$9,endCallButton:endCallButton$9,cameraButton:cameraButton$9,microphoneButton:microphoneButton$9,devicesButton:devicesButton$9,participantsButton:participantsButton$9,screenShareButton:screenShareButton$9,messageThread:messageThread$9,errorBar:errorBar$9,videoGallery:videoGallery$9,dialpad:dialpad$9,holdButton:holdButton$9,videoTile:videoTile$9,DomainPermissions:DomainPermissions$9,UnsupportedBrowser:UnsupportedBrowser$9,BrowserPermissionDenied:BrowserPermissionDenied$9,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$9};

var participantItem$8={isMeText:"(tu)",menuTitle:"Altre opzioni",removeButtonLabel:"Rimuovi",sharingIconLabel:"Condivisione",mutedIconLabel:"Disattivato",displayNamePlaceholder:"Partecipante senza nome",participantStateConnecting:"Chiamata in corso...",participantStateRinging:"Chiamata in corso...",participantStateHold:"Per l'attesa"};var typingIndicator$8={singleUser:"{user} sta scrivendo ...",multipleUsers:"{users} stanno scrivendo ...",multipleUsersAbbreviateOne:"{users} e 1 altro stanno scrivendo ...",multipleUsersAbbreviateMany:"{users} e {numOthers} altri stanno scrivendo ...",delimiter:", "};var sendBox$8={placeholderText:"Immetti un messaggio",textTooLong:"La lunghezza del messaggio supera il limite massimo.",sendButtonAriaLabel:"Invio messaggio",fileUploadsPendingError:"Caricamento in corso... Attendere.",removeFile:"Rimuovi file",uploading:"Caricamento in corso",uploadCompleted:"Caricamento completato"};var messageStatusIndicator$8={deliveredAriaLabel:"Il messaggio  stato inviato",deliveredTooltipText:"Inviato",seenAriaLabel:"Messaggio visualizzato da altri utenti",seenTooltipText:"Visualizzato",readByTooltipText:"Letto da {messageThreadReadCount} di {remoteParticipantsCount}",sendingAriaLabel:"Invio del messaggio",sendingTooltipText:"Invio in corso",failedToSendAriaLabel:"Invio messaggio non riuscito",failedToSendTooltipText:"Invio non riuscito"};var endCallButton$8={label:"Permesso",tooltipContent:"Abbandona chiamata"};var cameraButton$8={onLabel:"Disabilita",offLabel:"Abilita",tooltipDisabledContent:"La videocamera  disabilitata",tooltipOnContent:"Spegni la videocamera",tooltipOffContent:"Accendi la videocamera",tooltipVideoLoadingContent:"Il video  in corso di caricamento",cameraMenuTitle:"Fotocamera",cameraMenuTooltip:"Scegli fotocamera",cameraButtonSplitRoleDescription:"Pulsante di menu combinato",onSplitButtonAriaLabel:"Disattiva fotocamera e le opzioni della fotocamera",offSplitButtonAriaLabel:"Attiva fotocamera e le opzioni della fotocamera",cameraActionTurnedOnAnnouncement:"La videocamera  stata attivata",cameraActionTurnedOffAnnouncement:"La videocamera  stata disattivata"};var microphoneButton$8={onLabel:"Disattiva audio",offLabel:"Riattiva audio",tooltipDisabledContent:"Il microfono  disabilitato",tooltipOnContent:"Disattiva microfono",tooltipOffContent:"Riattiva microfono",microphoneMenuTitle:"Microfono",microphoneMenuTooltip:"Scegli microfono",speakerMenuTitle:"Altoparlante",speakerMenuTooltip:"Scegli altoparlante",microphoneButtonSplitRoleDescription:"Pulsante di menu combinato",onSplitButtonAriaLabel:"Disattiva microfono e opzioni audio",offSplitButtonAriaLabel:"Attiva microfono e opzioni audio",microphoneActionTurnedOnAnnouncement:"Il microfono  stato attivato",microphoneActionTurnedOffAnnouncement:"Il microfono  stato disattivato"};var devicesButton$8={label:"Dispositivi",tooltipContent:"Gestisci dispositivi",cameraMenuTitle:"Fotocamera",cameraMenuTooltip:"Scegli fotocamera",audioDeviceMenuTitle:"Dispositivo audio",audioDeviceMenuTooltip:"Scegli dispositivo audio",microphoneMenuTitle:"Microfono",microphoneMenuTooltip:"Scegli microfono",speakerMenuTitle:"Altoparlante",speakerMenuTooltip:"Scegli altoparlante"};var participantsButton$8={label:"Persone",tooltipContent:"Mostra partecipanti",menuHeader:"In questa chiamata",participantsListButtonLabel:"{numParticipants} persone",muteAllButtonLabel:"Disattiva l'audio di tutti",copyInviteLinkButtonLabel:"Copia il collegamento dellinvito"};var screenShareButton$8={onLabel:"Interrompi presentazione",offLabel:"Presentazione",tooltipDisabledContent:"La presentazione  disabilitata.",tooltipOnContent:"Presentazione dello schermo",tooltipOffContent:"Presenta lo schermo"};var messageThread$8={yesterday:"Ieri",sunday:"Domenica",monday:"Luned",tuesday:"Marted",wednesday:"Mercoled",thursday:"Gioved",friday:"Venerd",saturday:"Sabato",participantJoined:"si  unito alla chat.",participantLeft:"ha abbandonato la chat.",editMessage:"Modifica",removeMessage:"Elimina",resendMessage:"Riprova a inviare",failToSendTag:"Invio non riuscito",editedTag:"Modificato",liveAuthorIntro:"{author} dice",messageContentAriaText:"{author} ha detto {message}",messageContentMineAriaText:"Hai detto {message}",editBoxTextLimit:"Il messaggio ha superato il limite di caratteri {limitNumber}",editBoxPlaceholderText:"Modifica il messaggio",newMessagesIndicator:"Nuovi messaggi",noDisplayNameSub:"Nessun nome",editBoxCancelButton:"Annulla",editBoxSubmitButton:"Invia",messageReadCount:"Letto da {messageReadByCount} di {remoteParticipantsCount}",actionMenuMoreOptions:"Altre opzioni",downloadFile:"Scarica file"};var errorBar$8={unableToReachChatService:"Sei offline",accessDenied:"Non  possibile accedere ai servizi di chat. Controllare le credenziali utente specificate",userNotInChatThread:"Non fai pi parte di questo thread di chat",sendMessageNotInChatThread:"Non  stato possibile inviare il messaggio perch non sei pi in questo thread di chat",sendMessageGeneric:"Impossibile inviare il messaggio",callingNetworkFailure:"Problema di connessione della chiamata: sembra che tu sia offline",startVideoGeneric:"Non  stato possibile avviare il video",stopVideoGeneric:"Non  stato possibile arrestare il video",muteGeneric:"Non  stato possibile disattivare l'audio del microfono",unmuteGeneric:"Non  stato possibile riattivare l'audio del microfono",speakingWhileMuted:"Il microfono  disattivato",startScreenShareGeneric:"Non  stato possibile avviare la condivisione dello schermo",stopScreenShareGeneric:"Non  stato possibile arrestare la condivisione dello schermo",callNetworkQualityLow:"La qualit della rete  bassa.",callNoSpeakerFound:"Non sono stati trovati altoparlanti o cuffie. Connetti un dispositivo audio per ascoltare la chiamata.",callNoMicrophoneFound:"Nessun microfono trovato. Connetti un dispositivo di input audio.",callMicrophoneAccessDenied:"Impossibile accedere al microfono. Fare clic sul blocco nella barra degli indirizzi per concedere l'autorizzazione a questa pagina Web.",callMicrophoneMutedBySystem:"Il sistema disattiva l'audio.",callMicrophoneUnmutedBySystem:"Il microfono  stato ripristinato e il sistema ha riattivato l'audio.",callMacOsMicrophoneAccessDenied:"Impossibile accedere al microfono. Concedi l'autorizzazione al microfono nelle impostazioni di privacy di macOS.",callLocalVideoFreeze:"Larghezza di banda di rete insufficiente. Il video potrebbe essere sospeso per gli altri partecipanti alla chiamata.",callCameraAccessDenied:"Non  possibile accedere alla fotocamera. Fare clic sul blocco nella barra degli indirizzi per concedere l'autorizzazione a questa pagina Web.",callCameraAlreadyInUse:"Non  possibile accedere alla fotocamera. Potrebbe essere gi in uso da un'altra applicazione.",callVideoStoppedBySystem:"Il video  stato arrestato dal sistema.",callVideoRecoveredBySystem:"Il video  ripreso.",callMacOsCameraAccessDenied:"MacOS sta bloccando l'accesso alla fotocamera. Aggiorna le impostazioni di privacy per consentire a questo browser di accedere alla fotocamera.",callMacOsScreenShareAccessDenied:"MacOS sta bloccando la condivisione dello schermo. Aggiorna le impostazioni di privacy per consentire a questo browser di registrare lo schermo.",dismissButtonAriaLabel:"Chiudi",failedToJoinCallGeneric:"Non  stato possibile partecipare alla chiamata.",failedToJoinCallInvalidMeetingLink:"Impossibile partecipare alla riunione. Collegamento non valido."};var videoGallery$8={screenIsBeingSharedMessage:"Stai condividendo lo schermo",screenShareLoadingMessage:"Caricamento dello schermo di {participant}",localVideoLabel:"Tu",localVideoCameraSwitcherLabel:"Cambia videocamera",localVideoMovementLabel:"Riquadro video locale mobile",localVideoSelectedDescription:"{cameraName} selezionata",displayNamePlaceholder:"Partecipante senza nome"};var dialpad$8={placeholderText:"Inserisci numero di telefono",deleteButtonAriaLabel:"Elimina"};var holdButton$8={onLabel:"Riprendi",offLabel:"Mantenere",tooltipOnContent:"Riprendi chiamata",tooltipOffContent:"Metti in attesa chiamata"};var videoTile$8={participantStateConnecting:"Chiamata in corso...",participantStateRinging:"Chiamata in corso...",participantStateHold:"Per l'attesa"};var DomainPermissions$8={primaryText:"Consenti a {appName} di usare la fotocamera e il microfono",secondaryText:"In questo modo i partecipanti possono vederti e sentirti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Consenti l'accesso"};var UnsupportedBrowser$8={primaryText:"Browser non supportato",secondaryText:"Partecipa alla chiamata utilizzando un browser compatibile.",moreHelpLink:"Ulteriore assistenza"};var BrowserPermissionDenied$8={primaryText:"Non  possibile usare la fotocamera o il microfono",secondaryText:"Il browser potrebbe non avere accesso alla fotocamera o al microfono. Per risolvere il problema, aprire Preferenze di sistema.",primaryButtonText:"Riprova",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var BrowserPermissionDeniedIOS$8={primaryText:"Consenti l'accesso al microfono per continuare",secondaryText:"Cos gli altri partecipanti possono sentirti.",primaryButtonText:"Riprova",imageAltText:"Posizione dell'autorizzazione del microfono e della fotocamera per iOS",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",step1Text:"Vai alle impostazioni dell'app",step2Text:"Scorri verso il basso fino alle impostazioni per questo browser",step3Text:"Attiva microfono (fotocamera facoltativa)",step4Text:"Prova a partecipare di nuovo alla chiamata",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var it_IT$1 = {participantItem:participantItem$8,typingIndicator:typingIndicator$8,sendBox:sendBox$8,messageStatusIndicator:messageStatusIndicator$8,endCallButton:endCallButton$8,cameraButton:cameraButton$8,microphoneButton:microphoneButton$8,devicesButton:devicesButton$8,participantsButton:participantsButton$8,screenShareButton:screenShareButton$8,messageThread:messageThread$8,errorBar:errorBar$8,videoGallery:videoGallery$8,dialpad:dialpad$8,holdButton:holdButton$8,videoTile:videoTile$8,DomainPermissions:DomainPermissions$8,UnsupportedBrowser:UnsupportedBrowser$8,BrowserPermissionDenied:BrowserPermissionDenied$8,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$8};

var participantItem$7={isMeText:"()",menuTitle:"",removeButtonLabel:"",sharingIconLabel:"",mutedIconLabel:"",displayNamePlaceholder:"",participantStateConnecting:"...",participantStateRinging:"...",participantStateHold:""};var typingIndicator$7={singleUser:"{user} ...",multipleUsers:"{users} ...",multipleUsersAbbreviateOne:"{users}  1 ...",multipleUsersAbbreviateMany:"{users}  {numOthers} ...",delimiter:","};var sendBox$7={placeholderText:"",textTooLong:"",sendButtonAriaLabel:"",fileUploadsPendingError:"... ",removeFile:"",uploading:"",uploadCompleted:""};var messageStatusIndicator$7={deliveredAriaLabel:"",deliveredTooltipText:"",seenAriaLabel:"",seenTooltipText:"",readByTooltipText:"{remoteParticipantsCount}  {messageThreadReadCount} ",sendingAriaLabel:"",sendingTooltipText:"",failedToSendAriaLabel:"",failedToSendTooltipText:""};var endCallButton$7={label:"",tooltipContent:""};var cameraButton$7={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",tooltipVideoLoadingContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",cameraButtonSplitRoleDescription:"",onSplitButtonAriaLabel:" ",offSplitButtonAriaLabel:" ",cameraActionTurnedOnAnnouncement:"",cameraActionTurnedOffAnnouncement:""};var microphoneButton$7={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:"",microphoneButtonSplitRoleDescription:"",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",microphoneActionTurnedOnAnnouncement:"",microphoneActionTurnedOffAnnouncement:""};var devicesButton$7={label:"",tooltipContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",audioDeviceMenuTitle:" ",audioDeviceMenuTooltip:" ",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:""};var participantsButton$7={label:"",tooltipContent:"",menuHeader:"",participantsListButtonLabel:"{numParticipants} ",muteAllButtonLabel:"",copyInviteLinkButtonLabel:""};var screenShareButton$7={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:""};var messageThread$7={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:"",participantLeft:"",editMessage:"",removeMessage:"",resendMessage:"",failToSendTag:"",editedTag:"",liveAuthorIntro:"{author} ",messageContentAriaText:"{author}  {message} ",messageContentMineAriaText:"{message} ",editBoxTextLimit:"{limitNumber}",editBoxPlaceholderText:"",newMessagesIndicator:"",noDisplayNameSub:"",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:"{remoteParticipantsCount}  {messageReadByCount} ",actionMenuMoreOptions:"",downloadFile:""};var errorBar$7={unableToReachChatService:"",accessDenied:" - ",userNotInChatThread:" ",sendMessageNotInChatThread:" ",sendMessageGeneric:"",callingNetworkFailure:"",startVideoGeneric:"",stopVideoGeneric:"",muteGeneric:"",unmuteGeneric:"",speakingWhileMuted:"",startScreenShareGeneric:"",stopScreenShareGeneric:"",callNetworkQualityLow:"",callNoSpeakerFound:"",callNoMicrophoneFound:"",callMicrophoneAccessDenied:"  Web ",callMicrophoneMutedBySystem:"",callMicrophoneUnmutedBySystem:"",callMacOsMicrophoneAccessDenied:"macOS ",callLocalVideoFreeze:"",callCameraAccessDenied:"  Web ",callCameraAlreadyInUse:"",callVideoStoppedBySystem:"",callVideoRecoveredBySystem:"",callMacOsCameraAccessDenied:"MacOS ",callMacOsScreenShareAccessDenied:"MacOS ",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"",failedToJoinCallInvalidMeetingLink:""};var videoGallery$7={screenIsBeingSharedMessage:"",screenShareLoadingMessage:"{participant} ",localVideoLabel:"",localVideoCameraSwitcherLabel:"",localVideoMovementLabel:"  ",localVideoSelectedDescription:"{cameraName} ",displayNamePlaceholder:""};var dialpad$7={placeholderText:"",deleteButtonAriaLabel:""};var holdButton$7={onLabel:"",offLabel:"",tooltipOnContent:"",tooltipOffContent:""};var videoTile$7={participantStateConnecting:"...",participantStateRinging:"...",participantStateHold:""};var DomainPermissions$7={primaryText:"{appName}",secondaryText:"",linkText:"? ",primaryButtonText:""};var UnsupportedBrowser$7={primaryText:"",secondaryText:"",moreHelpLink:""};var BrowserPermissionDenied$7={primaryText:"",secondaryText:"[] ",primaryButtonText:"",linkText:"? "};var BrowserPermissionDeniedIOS$7={primaryText:"",secondaryText:"",primaryButtonText:"",imageAltText:"iOS  ",linkText:"? ",step1Text:"",step2Text:"",step3Text:" ()",step4Text:"",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var ja_JP$1 = {participantItem:participantItem$7,typingIndicator:typingIndicator$7,sendBox:sendBox$7,messageStatusIndicator:messageStatusIndicator$7,endCallButton:endCallButton$7,cameraButton:cameraButton$7,microphoneButton:microphoneButton$7,devicesButton:devicesButton$7,participantsButton:participantsButton$7,screenShareButton:screenShareButton$7,messageThread:messageThread$7,errorBar:errorBar$7,videoGallery:videoGallery$7,dialpad:dialpad$7,holdButton:holdButton$7,videoTile:videoTile$7,DomainPermissions:DomainPermissions$7,UnsupportedBrowser:UnsupportedBrowser$7,BrowserPermissionDenied:BrowserPermissionDenied$7,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$7};

var participantItem$6={isMeText:"()",menuTitle:" ",removeButtonLabel:"",sharingIconLabel:" ",mutedIconLabel:"",displayNamePlaceholder:"  ",participantStateConnecting:"  ...",participantStateRinging:"  ...",participantStateHold:" "};var typingIndicator$6={singleUser:"{user}   ...",multipleUsers:"{users}   ...",multipleUsersAbbreviateOne:"{users}   1  ...",multipleUsersAbbreviateMany:"{users}   {numOthers}   ...",delimiter:"   "};var sendBox$6={placeholderText:" ",textTooLong:"    .",sendButtonAriaLabel:" ",fileUploadsPendingError:" ...   .",removeFile:" ",uploading:" ",uploadCompleted:" "};var messageStatusIndicator$6={deliveredAriaLabel:" ",deliveredTooltipText:"",seenAriaLabel:"   ",seenTooltipText:"",readByTooltipText:"{messageThreadReadCount}/{remoteParticipantsCount} ",sendingAriaLabel:"  ",sendingTooltipText:" ",failedToSendAriaLabel:"  ",failedToSendTooltipText:" "};var endCallButton$6={label:"",tooltipContent:" "};var cameraButton$6={onLabel:"",offLabel:"",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:" ",tooltipVideoLoadingContent:"  .",cameraMenuTitle:"",cameraMenuTooltip:" ",cameraButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"      ",offSplitButtonAriaLabel:"    ",cameraActionTurnedOnAnnouncement:"  .",cameraActionTurnedOffAnnouncement:"  ."};var microphoneButton$6={onLabel:"",offLabel:" ",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:"  ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" ",microphoneButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"    ",offSplitButtonAriaLabel:"     ",microphoneActionTurnedOnAnnouncement:"  .",microphoneActionTurnedOffAnnouncement:"  ."};var devicesButton$6={label:"",tooltipContent:" ",cameraMenuTitle:"",cameraMenuTooltip:" ",audioDeviceMenuTitle:" ",audioDeviceMenuTooltip:"  ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" "};var participantsButton$6={label:"",tooltipContent:" ",menuHeader:" ",participantsListButtonLabel:"{numParticipants}",muteAllButtonLabel:" ",copyInviteLinkButtonLabel:"  "};var screenShareButton$6={onLabel:" ",offLabel:"",tooltipDisabledContent:"   ",tooltipOnContent:"  ",tooltipOffContent:" "};var messageThread$6={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:" .",participantLeft:"  .",editMessage:"",removeMessage:"",resendMessage:"  ",failToSendTag:" ",editedTag:"",liveAuthorIntro:"{author}  .",messageContentAriaText:"{author}  {message}() .",messageContentMineAriaText:" {message}() .",editBoxTextLimit:" {limitNumber}   .",editBoxPlaceholderText:" ",newMessagesIndicator:" ",noDisplayNameSub:" ",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:"{messageReadByCount}/{remoteParticipantsCount} ",actionMenuMoreOptions:" ",downloadFile:" "};var errorBar$6={unableToReachChatService:" .",accessDenied:"    .     .",userNotInChatThread:"     .",sendMessageNotInChatThread:"         .",sendMessageGeneric:"  ",callingNetworkFailure:"   -    .",startVideoGeneric:"  ",stopVideoGeneric:"  ",muteGeneric:"  ",unmuteGeneric:"   ",speakingWhileMuted:" ",startScreenShareGeneric:"   ",stopScreenShareGeneric:"   ",callNetworkQualityLow:"  .",callNoSpeakerFound:"     .       .",callNoMicrophoneFound:"   .    .",callMicrophoneAccessDenied:"   .         .",callMicrophoneMutedBySystem:"  .",callMicrophoneUnmutedBySystem:"    .",callMacOsMicrophoneAccessDenied:"   . macOS      .",callLocalVideoFreeze:"  .          .",callCameraAccessDenied:"   .         .",callCameraAlreadyInUse:"   .        .",callVideoStoppedBySystem:"   .",callVideoRecoveredBySystem:"  .",callMacOsCameraAccessDenied:"MacOS     .          .",callMacOsScreenShareAccessDenied:"MacOS    .          .",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"  .",failedToJoinCallInvalidMeetingLink:"   .  ."};var videoGallery$6={screenIsBeingSharedMessage:"  .",screenShareLoadingMessage:"{participant}    ",localVideoLabel:"",localVideoCameraSwitcherLabel:" ",localVideoMovementLabel:"    ",localVideoSelectedDescription:"{cameraName} ",displayNamePlaceholder:"  "};var dialpad$6={placeholderText:"  .",deleteButtonAriaLabel:""};var holdButton$6={onLabel:"",offLabel:"",tooltipOnContent:" ",tooltipOffContent:" "};var videoTile$6={participantStateConnecting:"  ...",participantStateRinging:"  ...",participantStateHold:" "};var DomainPermissions$6={primaryText:"{appName}     ",secondaryText:"      .",linkText:" ?    ",primaryButtonText:" "};var UnsupportedBrowser$6={primaryText:"  ",secondaryText:"     .",moreHelpLink:" "};var BrowserPermissionDenied$6={primaryText:"     ",secondaryText:"        .       .",primaryButtonText:" ",linkText:" ?    "};var BrowserPermissionDeniedIOS$6={primaryText:"   ",secondaryText:"       .",primaryButtonText:" ",imageAltText:"iOS      ",linkText:" ?    ",step1Text:"  .",step2Text:"   Scroll down",step3Text:" (  )",step4Text:"   .",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var ko_KR$1 = {participantItem:participantItem$6,typingIndicator:typingIndicator$6,sendBox:sendBox$6,messageStatusIndicator:messageStatusIndicator$6,endCallButton:endCallButton$6,cameraButton:cameraButton$6,microphoneButton:microphoneButton$6,devicesButton:devicesButton$6,participantsButton:participantsButton$6,screenShareButton:screenShareButton$6,messageThread:messageThread$6,errorBar:errorBar$6,videoGallery:videoGallery$6,dialpad:dialpad$6,holdButton:holdButton$6,videoTile:videoTile$6,DomainPermissions:DomainPermissions$6,UnsupportedBrowser:UnsupportedBrowser$6,BrowserPermissionDenied:BrowserPermissionDenied$6,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$6};

var participantItem$5={isMeText:"(jij)",menuTitle:"Meer opties",removeButtonLabel:"Verwijderen",sharingIconLabel:"Delen",mutedIconLabel:"Gedempt",displayNamePlaceholder:"Naamloze deelnemer",participantStateConnecting:"Bellen...",participantStateRinging:"Bellen...",participantStateHold:"In de wacht"};var typingIndicator$5={singleUser:"{user} typt ...",multipleUsers:"{users} typen ...",multipleUsersAbbreviateOne:"{users} en 1 andere persoon typen ...",multipleUsersAbbreviateMany:"{users} en {numOthers} anderen typen ...",delimiter:", "};var sendBox$5={placeholderText:"Een bericht invoeren",textTooLong:"De lengte van uw bericht overschrijdt de maximumlimiet.",sendButtonAriaLabel:"Bericht verzenden",fileUploadsPendingError:"Uploaden.... Een ogenblik geduld.",removeFile:"Bestand verwijderen",uploading:"Uploaden",uploadCompleted:"Upload voltooid"};var messageStatusIndicator$5={deliveredAriaLabel:"Bericht verzonden",deliveredTooltipText:"Verzonden",seenAriaLabel:"Bericht gezien door anderen",seenTooltipText:"Gezien",readByTooltipText:"Gelezen door {messageThreadReadCount} van {remoteParticipantsCount}",sendingAriaLabel:"Bericht verzenden",sendingTooltipText:"Verzenden",failedToSendAriaLabel:"Het bericht is niet verzonden",failedToSendTooltipText:"Kan niet verzenden"};var endCallButton$5={label:"Verlaten",tooltipContent:"Gesprek verlaten"};var cameraButton$5={onLabel:"Uitschakelen",offLabel:"Inschakelen",tooltipDisabledContent:"Camera is uitgeschakeld",tooltipOnContent:"Camera uitschakelen",tooltipOffContent:"Camera inschakelen",tooltipVideoLoadingContent:"Video wordt geladen",cameraMenuTitle:"Camera",cameraMenuTooltip:"Camera kiezen",cameraButtonSplitRoleDescription:"Knop Splitsen",onSplitButtonAriaLabel:"Camera- en cameraopties uitschakelen",offSplitButtonAriaLabel:"Camera- en cameraopties inschakelen",cameraActionTurnedOnAnnouncement:"Uw camera is ingeschakeld",cameraActionTurnedOffAnnouncement:"Uw camera is uitgeschakeld"};var microphoneButton$5={onLabel:"Dempen",offLabel:"Dempen opheffen",tooltipDisabledContent:"Microfoon is uitgeschakeld",tooltipOnContent:"Microfoon uitschakelen",tooltipOffContent:"Microfoon inschakelen",microphoneMenuTitle:"Microfoon",microphoneMenuTooltip:"Microfoon kiezen",speakerMenuTitle:"Luidspreker",speakerMenuTooltip:"Luidspreker kiezen",microphoneButtonSplitRoleDescription:"Knop Splitsen",onSplitButtonAriaLabel:"Microfoon- en audioopties dempen",offSplitButtonAriaLabel:"Microfoon- en audioopties dempen opheffen",microphoneActionTurnedOnAnnouncement:"Uw microfoon is ingeschakeld",microphoneActionTurnedOffAnnouncement:"Uw microfoon is uitgeschakeld"};var devicesButton$5={label:"Apparaten",tooltipContent:"Apparaten beheren",cameraMenuTitle:"Camera",cameraMenuTooltip:"Camera kiezen",audioDeviceMenuTitle:"Audioapparaat",audioDeviceMenuTooltip:"Audioapparaat kiezen",microphoneMenuTitle:"Microfoon",microphoneMenuTooltip:"Microfoon kiezen",speakerMenuTitle:"Spreker",speakerMenuTooltip:"Luidspreker kiezen"};var participantsButton$5={label:"Personen",tooltipContent:"Deelnemers weergeven",menuHeader:"In dit gesprek",participantsListButtonLabel:"{numParticipants} personen",muteAllButtonLabel:"Alles dempen",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiren"};var screenShareButton$5={onLabel:"Presenteren stoppen",offLabel:"Presenteren",tooltipDisabledContent:"Presenteren is uitgeschakeld",tooltipOnContent:"Uw scherm presenteren",tooltipOffContent:"Uw scherm presenteren"};var messageThread$5={yesterday:"Gisteren",sunday:"Zondag",monday:"Maandag",tuesday:"Dinsdag",wednesday:"Woensdag",thursday:"Donderdag",friday:"Vrijdag",saturday:"Zaterdag",participantJoined:"neemt nu deel aan de chat.",participantLeft:"heeft de chat verlaten.",editMessage:"Bewerken",removeMessage:"Verwijderen",resendMessage:"Probeer opnieuw te verzenden",failToSendTag:"Verzenden mislukt",editedTag:"Bewerkt",liveAuthorIntro:"{author} zegt",messageContentAriaText:"{author} zei {message}",messageContentMineAriaText:"U zei: {message}",editBoxTextLimit:"Uw bericht heeft de limiet van {limitNumber} tekens overschreden",editBoxPlaceholderText:"Uw bericht bewerken",newMessagesIndicator:"Nieuwe berichten",noDisplayNameSub:"Geen naam",editBoxCancelButton:"Annuleren",editBoxSubmitButton:"Verzenden",messageReadCount:"Gelezen door {messageReadByCount} van {remoteParticipantsCount}",actionMenuMoreOptions:"Meer opties",downloadFile:"Bestand downloaden"};var errorBar$5={unableToReachChatService:"U bent offline",accessDenied:"Kan geen toegang krijgen tot chatservices. Controleer de opgegeven gebruikersreferenties",userNotInChatThread:"U bent niet meer aanwezig in deze chatthread",sendMessageNotInChatThread:"Verzenden van bericht is mislukt omdat u zich niet meer in deze chatthread bevindt",sendMessageGeneric:"Kan bericht niet verzenden",callingNetworkFailure:"Er zijn problemen met het verbinden van een gesprek - Het lijkt erop dat u offline bent",startVideoGeneric:"Kan video niet starten",stopVideoGeneric:"Kan video niet stoppen",muteGeneric:"Kan microfoon niet dempen",unmuteGeneric:"Kan dempen van microfoon niet opheffen",speakingWhileMuted:"De microfoon is gedempt",startScreenShareGeneric:"Kan scherm delen niet starten",stopScreenShareGeneric:"Kan scherm delen niet stoppen",callNetworkQualityLow:"De netwerkkwaliteit is laag.",callNoSpeakerFound:"Geen luidsprekers of hoofdtelefoon gevonden. Sluit een audioapparaat aan om het gesprek te beluisteren.",callNoMicrophoneFound:"Geen microfoons gevonden. Sluit een audio-invoerapparaat aan.",callMicrophoneAccessDenied:"Kan geen toegang krijgen tot de microfoon. Klik op de vergrendeling in de adresbalk om toestemming te verlenen aan deze webpagina.",callMicrophoneMutedBySystem:"U bent gedempt door jouw systeem.",callMicrophoneUnmutedBySystem:"De microfoon is hersteld en het dempen van de microfoon is door het systeem opgeheven.",callMacOsMicrophoneAccessDenied:"Kan geen toegang krijgen tot de microfoon. Verleen microfoonmachtiging in de privacyinstellingen voor macOS.",callLocalVideoFreeze:"De netwerkbandbreedte is slecht. Je video wordt mogelijk onderbroken weergegeven voor anderen in het gesprek.",callCameraAccessDenied:"Kan geen toegang krijgen tot de camera. Klik op de vergrendeling in de adresbalk om toestemming te verlenen aan deze webpagina.",callCameraAlreadyInUse:"Kan geen toegang krijgen tot de camera. Het wordt mogelijk al gebruikt door een andere toepassing.",callVideoStoppedBySystem:"Uw video is gestopt door uw systeem.",callVideoRecoveredBySystem:"Uw video is hervat.",callMacOsCameraAccessDenied:"MacOS blokkeert de toegang tot jouw camera. Werk je privacyinstellingen bij, zodat deze browser toegang heeft tot jouw camera.",callMacOsScreenShareAccessDenied:"MacOS blokkeert scherm delen. Werk je privacyinstellingen bij, zodat deze browser jouw scherm kan opnemen.",dismissButtonAriaLabel:"Sluiten",failedToJoinCallGeneric:"Deelnemen aan gesprek mislukt.",failedToJoinCallInvalidMeetingLink:"Kan niet deelnemen aan vergadering. Ongeldige koppeling."};var videoGallery$5={screenIsBeingSharedMessage:"U deelt uw scherm",screenShareLoadingMessage:"Scherm van {participant} laden",localVideoLabel:"U",localVideoCameraSwitcherLabel:"Camera wisselen",localVideoMovementLabel:"Tegel voor verwisselbare lokale video",localVideoSelectedDescription:"{cameraName} geselecteerd",displayNamePlaceholder:"Naamloze deelnemer"};var dialpad$5={placeholderText:"Telefoonnummer invoeren",deleteButtonAriaLabel:"Verwijderen"};var holdButton$5={onLabel:"Hervatten",offLabel:"Pauze",tooltipOnContent:"Gesprek hervatten",tooltipOffContent:"Gesprek in wachtrij plaatsen"};var videoTile$5={participantStateConnecting:"Bellen...",participantStateRinging:"Bellen...",participantStateHold:"In de wacht"};var DomainPermissions$5={primaryText:"Toestaan dat {appName} uw camera en microfoon gebruikt",secondaryText:"Dit is zodat deelnemers u kunnen zien en horen.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Toegang verlenen"};var UnsupportedBrowser$5={primaryText:"Browser wordt niet ondersteund",secondaryText:"Neem deel aan dit gesprek via een compatibele browser.",moreHelpLink:"Meer hulp"};var BrowserPermissionDenied$5={primaryText:"Kan uw camera of microfoon niet gebruiken",secondaryText:"Uw browser heeft mogelijk geen toegang tot uw camera of microfoon. Open Systeemvoorkeuren om dit op te lossen.",primaryButtonText:"Opnieuw proberen",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var BrowserPermissionDeniedIOS$5={primaryText:"Microfoontoegang toestaan om door te gaan",secondaryText:"Zodat andere deelnemers u kunnen horen.",primaryButtonText:"Opnieuw proberen",imageAltText:"Machtigingslocatie voor microfoon en cameraapparaat voor iOS",linkText:"Hulp nodig? Hulp bij probleemoplossing",step1Text:"Ga naar de app Instellingen",step2Text:"Schuif omlaag naar instellingen voor deze browser",step3Text:"Microfoon inschakelen (camera optioneel)",step4Text:"Probeer opnieuw deel te nemen aan het gesprek",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var nl_NL$1 = {participantItem:participantItem$5,typingIndicator:typingIndicator$5,sendBox:sendBox$5,messageStatusIndicator:messageStatusIndicator$5,endCallButton:endCallButton$5,cameraButton:cameraButton$5,microphoneButton:microphoneButton$5,devicesButton:devicesButton$5,participantsButton:participantsButton$5,screenShareButton:screenShareButton$5,messageThread:messageThread$5,errorBar:errorBar$5,videoGallery:videoGallery$5,dialpad:dialpad$5,holdButton:holdButton$5,videoTile:videoTile$5,DomainPermissions:DomainPermissions$5,UnsupportedBrowser:UnsupportedBrowser$5,BrowserPermissionDenied:BrowserPermissionDenied$5,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$5};

var participantItem$4={isMeText:"(voc)",menuTitle:"Mais opes",removeButtonLabel:"Remover",sharingIconLabel:"Compartilhamento",mutedIconLabel:"Silenciado",displayNamePlaceholder:"Participante Sem Nome",participantStateConnecting:"Chamando...",participantStateRinging:"Chamando...",participantStateHold:"Em espera"};var typingIndicator$4={singleUser:"{user} est digitando ...",multipleUsers:"{users} esto digitando ...",multipleUsersAbbreviateOne:"{users} e 1 outro esto digitando...",multipleUsersAbbreviateMany:"{users} e {numOthers} outros esto digitando ...",delimiter:", "};var sendBox$4={placeholderText:"Inserir uma mensagem",textTooLong:"O comprimento da mensagem est acima do limite mximo.",sendButtonAriaLabel:"Enviar mensagem",fileUploadsPendingError:"Carregando... Aguarde.",removeFile:"Remover arquivo",uploading:"Carregando",uploadCompleted:"Carregamento concludo"};var messageStatusIndicator$4={deliveredAriaLabel:"Mensagem enviada",deliveredTooltipText:"Enviado",seenAriaLabel:"Mensagem vista por outras pessoas",seenTooltipText:"Visto",readByTooltipText:"Lido por {messageThreadReadCount} de {remoteParticipantsCount}",sendingAriaLabel:"Envio de mensagem",sendingTooltipText:"Enviando",failedToSendAriaLabel:"Falha ao enviar mensagem",failedToSendTooltipText:"Falha ao enviar"};var endCallButton$4={label:"Sair",tooltipContent:"Sair da chamada"};var cameraButton$4={onLabel:"Desabilitar",offLabel:"Habilitar",tooltipDisabledContent:"A cmera est desabilitada",tooltipOnContent:"Desabilitar a cmera",tooltipOffContent:"Ligar a cmera",tooltipVideoLoadingContent:"O vdeo est carregando",cameraMenuTitle:"Cmera",cameraMenuTooltip:"Escolher cmera",cameraButtonSplitRoleDescription:"Boto de diviso",onSplitButtonAriaLabel:"Desabilitar a cmera e as opes da cmera",offSplitButtonAriaLabel:"Habilitar a cmera e as opes da cmera",cameraActionTurnedOnAnnouncement:"A cmera foi ligada",cameraActionTurnedOffAnnouncement:"A cmera foi desligada"};var microphoneButton$4={onLabel:"Mudo",offLabel:"Desativar mudo",tooltipDisabledContent:"O microfone est desabilitado",tooltipOnContent:"Ativar mudo do microfone",tooltipOffContent:"Desativar mudo do microfone",microphoneMenuTitle:"Microfone",microphoneMenuTooltip:"Escolher microfone",speakerMenuTitle:"Alto-falante",speakerMenuTooltip:"Escolher alto-falante",microphoneButtonSplitRoleDescription:"Boto de diviso",onSplitButtonAriaLabel:"Ativar mudo das opes de microfone e udio",offSplitButtonAriaLabel:"Desativar mudo do microfone e opes de udio",microphoneActionTurnedOnAnnouncement:"O microfone foi ligado",microphoneActionTurnedOffAnnouncement:"O microfone foi desligado"};var devicesButton$4={label:"Dispositivos",tooltipContent:"Gerenciar dispositivos",cameraMenuTitle:"Cmera",cameraMenuTooltip:"Escolher cmera",audioDeviceMenuTitle:"Dispositivo de udio",audioDeviceMenuTooltip:"Escolher dispositivo de udio",microphoneMenuTitle:"Microfone",microphoneMenuTooltip:"Escolher microfone",speakerMenuTitle:"Alto-falante",speakerMenuTooltip:"Escolher alto-falante"};var participantsButton$4={label:"Pessoas",tooltipContent:"Mostrar participantes",menuHeader:"Nesta chamada",participantsListButtonLabel:"{numParticipants} pessoas",muteAllButtonLabel:"Silenciar todos",copyInviteLinkButtonLabel:"Copiar o link de convite"};var screenShareButton$4={onLabel:"Interromper apresentao",offLabel:"Apresentao",tooltipDisabledContent:"A apresentao est desabilitada.",tooltipOnContent:"Apresentando sua tela",tooltipOffContent:"Apresentar sua tela"};var messageThread$4={yesterday:"Ontem",sunday:"Domingo",monday:"Segunda",tuesday:"Tera-feira",wednesday:"Quarta-feira",thursday:"quinta-feira",friday:"Sexta-feira",saturday:"Sbado",participantJoined:"ingressou no chat.",participantLeft:"saiu do chat.",editMessage:"Editar",removeMessage:"Excluir",resendMessage:"Tente enviar novamente",failToSendTag:"Falha ao enviar",editedTag:"Editado",liveAuthorIntro:"{author} disse",messageContentAriaText:"{author} disse {message}",messageContentMineAriaText:"Voc disse {message}",editBoxTextLimit:"Sua mensagem est acima do limite de {limitNumber} caracteres",editBoxPlaceholderText:"Edite sua mensagem",newMessagesIndicator:"Novas mensagens",noDisplayNameSub:"Sem nome",editBoxCancelButton:"Cancelar",editBoxSubmitButton:"Enviar",messageReadCount:"Lido por {messageReadByCount} de {remoteParticipantsCount}",actionMenuMoreOptions:"Mais opes",downloadFile:"Baixar arquivo"};var errorBar$4={unableToReachChatService:"Voc est offline",accessDenied:"No  possvel acessar os servios de chat - verifique as credenciais do usurio fornecidas",userNotInChatThread:"Voc no est mais neste tpico de chat",sendMessageNotInChatThread:"Falha ao enviar mensagem porque voc no est mais neste thread de chat",sendMessageGeneric:"Falha ao enviar mensagem",callingNetworkFailure:"Chamada de conexo desabilitar - parece que voc est offline",startVideoGeneric:"Falha ao iniciar o vdeo",stopVideoGeneric:"Falha ao interromper o vdeo",muteGeneric:"Falha ao ativar mudo do microfone",unmuteGeneric:"Falha ao desativar mudo do microfone",speakingWhileMuted:"O microfone est com o mudo ativado",startScreenShareGeneric:"Falha ao iniciar o compartilhamento de tela",stopScreenShareGeneric:"Falha ao interromper o compartilhamento de tela",callNetworkQualityLow:"A qualidade da rede  baixa.",callNoSpeakerFound:"Nenhum alto-falante ou fone de ouvido encontrado. Conecte um dispositivo de udio para ouvir a chamada.",callNoMicrophoneFound:"Nenhum microfone encontrado. Conecte um dispositivo de entrada de udio.",callMicrophoneAccessDenied:"No  possvel acessar o microfone. Clique no bloqueio na barra de endereos para conceder permisso a esta pgina da Web.",callMicrophoneMutedBySystem:"Voc est com as notificaes desativada pelo sistema.",callMicrophoneUnmutedBySystem:"Seu microfone se recuperou e voc foi desativado pelo sistema.",callMacOsMicrophoneAccessDenied:"No  possvel acessar o microfone. Conceda permisso ao microfone nas configuraes de privacidade do macOS.",callLocalVideoFreeze:"A largura de banda da rede  ruim. Seu vdeo pode aparecer em pausa para outras pessoas na chamada.",callCameraAccessDenied:"No  possvel acessar a cmera. Clique no bloqueio na barra de endereos para conceder permisso a esta pgina da Web.",callCameraAlreadyInUse:"No  possvel acessar a cmera. Talvez ele j esteja em uso por outro aplicativo.",callVideoStoppedBySystem:"Seu vdeo foi interrompido pelo sistema.",callVideoRecoveredBySystem:"Seu vdeo foi retomado.",callMacOsCameraAccessDenied:"O MacOS est bloqueando o acesso  sua cmera. Atualize suas configuraes de privacidade para permitir que este navegador acesse sua cmera.",callMacOsScreenShareAccessDenied:"O MacOS est bloqueando o compartilhamento de tela. Atualize suas configuraes de privacidade para permitir que este navegador grave sua tela.",dismissButtonAriaLabel:"Fechar",failedToJoinCallGeneric:"Ocorreu um erro ao ingressar na chamada.",failedToJoinCallInvalidMeetingLink:"No  possvel ingressar na Reunio. Link Invlido."};var videoGallery$4={screenIsBeingSharedMessage:"Voc est compartilhando suatela",screenShareLoadingMessage:"Carregando a tela do {participant}",localVideoLabel:"Voc",localVideoCameraSwitcherLabel:"Alternar cmera",localVideoMovementLabel:"Bloco de Vdeo Local Removvel",localVideoSelectedDescription:"{cameraName} selecionado",displayNamePlaceholder:"Participante Sem Nome"};var dialpad$4={placeholderText:"Inserir o nmero do telefone",deleteButtonAriaLabel:"Excluir"};var holdButton$4={onLabel:"Retomar",offLabel:"Reteno",tooltipOnContent:"Retomar chamada",tooltipOffContent:"Manter chamada em espera"};var videoTile$4={participantStateConnecting:"Chamando...",participantStateRinging:"Chamando...",participantStateHold:"Em espera"};var DomainPermissions$4={primaryText:"Permitir {appName} usar a cmera e o microfone",secondaryText:"Isso  para que os participantes possam ver e ouvir voc.",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas",primaryButtonText:"Permitir Acesso"};var UnsupportedBrowser$4={primaryText:"Navegador sem suporte",secondaryText:"Ingresse nesta chamada usando um navegador compatvel.",moreHelpLink:"Mais ajuda"};var BrowserPermissionDenied$4={primaryText:"No  possvel usar sua cmera ou microfone",secondaryText:"Seu navegador pode no ter acesso  cmera ou ao microfone. Para corrigir isso, abra as Preferncias do Sistema.",primaryButtonText:"Tentar novamente",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas"};var BrowserPermissionDeniedIOS$4={primaryText:"Permitir acesso ao microfone para continuar",secondaryText:"Para que outros participantes possam ouvi-lo.",primaryButtonText:"Tentar novamente",imageAltText:"Localizao da permisso do microfone e do dispositivo da cmera para iOS",linkText:"Preciso de ajuda? Obtenha ajuda para soluo de problemas",step1Text:"Acessar o aplicativo Configuraes",step2Text:"Rolar para baixo at as configuraes deste navegador",step3Text:"Ligar o microfone (Cmera opcional)",step4Text:"Tentar ingressar na chamada novamente",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var pt_BR$1 = {participantItem:participantItem$4,typingIndicator:typingIndicator$4,sendBox:sendBox$4,messageStatusIndicator:messageStatusIndicator$4,endCallButton:endCallButton$4,cameraButton:cameraButton$4,microphoneButton:microphoneButton$4,devicesButton:devicesButton$4,participantsButton:participantsButton$4,screenShareButton:screenShareButton$4,messageThread:messageThread$4,errorBar:errorBar$4,videoGallery:videoGallery$4,dialpad:dialpad$4,holdButton:holdButton$4,videoTile:videoTile$4,DomainPermissions:DomainPermissions$4,UnsupportedBrowser:UnsupportedBrowser$4,BrowserPermissionDenied:BrowserPermissionDenied$4,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$4};

var participantItem$3={isMeText:"()",menuTitle:" ",removeButtonLabel:"",sharingIconLabel:" ",mutedIconLabel:" ",displayNamePlaceholder:"  ",participantStateConnecting:" ...",participantStateRinging:" ...",participantStateHold:" "};var typingIndicator$3={singleUser:"{user}  ...",multipleUsers:"{users}  ...",multipleUsersAbbreviateOne:"{users}   1  ...",multipleUsersAbbreviateMany:"{users}   {numOthers}  ...",delimiter:"; "};var sendBox$3={placeholderText:" ",textTooLong:"    .",sendButtonAriaLabel:" ",fileUploadsPendingError:" . ...",removeFile:" ",uploading:"",uploadCompleted:" "};var messageStatusIndicator$3={deliveredAriaLabel:" ",deliveredTooltipText:"",seenAriaLabel:"   ",seenTooltipText:"",readByTooltipText:": {messageThreadReadCount}  {remoteParticipantsCount}",sendingAriaLabel:" ",sendingTooltipText:"",failedToSendAriaLabel:"   ",failedToSendTooltipText:"  "};var endCallButton$3={label:"",tooltipContent:" "};var cameraButton$3={onLabel:"",offLabel:"",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:" ",tooltipVideoLoadingContent:" ",cameraMenuTitle:"",cameraMenuTooltip:" ",cameraButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"    ",offSplitButtonAriaLabel:"    ",cameraActionTurnedOnAnnouncement:" ",cameraActionTurnedOffAnnouncement:" "};var microphoneButton$3={onLabel:" ",offLabel:" ",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:" ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" ",microphoneButtonSplitRoleDescription:" ",onSplitButtonAriaLabel:"    ",offSplitButtonAriaLabel:"    ",microphoneActionTurnedOnAnnouncement:"  ",microphoneActionTurnedOffAnnouncement:"  "};var devicesButton$3={label:"",tooltipContent:" ",cameraMenuTitle:"",cameraMenuTooltip:" ",audioDeviceMenuTitle:" ",audioDeviceMenuTooltip:"  ",microphoneMenuTitle:"",microphoneMenuTooltip:" ",speakerMenuTitle:"",speakerMenuTooltip:" "};var participantsButton$3={label:"",tooltipContent:" ",menuHeader:"  ",participantsListButtonLabel:": {numParticipants}",muteAllButtonLabel:"  ",copyInviteLinkButtonLabel:"   "};var screenShareButton$3={onLabel:" ",offLabel:"",tooltipDisabledContent:" ",tooltipOnContent:" ",tooltipOffContent:" "};var messageThread$3={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:"  .",participantLeft:" .",editMessage:"",removeMessage:"",resendMessage:"  ",failToSendTag:"  ",editedTag:"",liveAuthorIntro:"{author} ",messageContentAriaText:"{author}  {message}",messageContentMineAriaText:"  {message}",editBoxTextLimit:"     {limitNumber} ",editBoxPlaceholderText:" ",newMessagesIndicator:" ",noDisplayNameSub:" ",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:": {messageReadByCount}  {remoteParticipantsCount}",actionMenuMoreOptions:" ",downloadFile:" "};var errorBar$3={unableToReachChatService:"   ",accessDenied:"      .     ",userNotInChatThread:"       ",sendMessageNotInChatThread:"   ,          ",sendMessageGeneric:"   ",callingNetworkFailure:"    ,    ",startVideoGeneric:"   ",stopVideoGeneric:"   ",muteGeneric:"   ",unmuteGeneric:"   ",speakingWhileMuted:" ",startScreenShareGeneric:"    ",stopScreenShareGeneric:"    ",callNetworkQualityLow:"  : .",callNoSpeakerFound:"    .   ,   .",callNoMicrophoneFound:"  .    .",callMicrophoneAccessDenied:"     .     ,      -.",callMicrophoneMutedBySystem:"   .",callMicrophoneUnmutedBySystem:" ,     .",callMacOsMicrophoneAccessDenied:"     .          macOS.",callLocalVideoFreeze:"   .          .",callCameraAccessDenied:"     .     ,      -.",callCameraAlreadyInUse:"     . ,     .",callVideoStoppedBySystem:"   .",callVideoRecoveredBySystem:"  .",callMacOsCameraAccessDenied:"MacOS    .   ,       .",callMacOsScreenShareAccessDenied:"MacOS   .   ,       .",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"    .",failedToJoinCallInvalidMeetingLink:"    .  ."};var videoGallery$3={screenIsBeingSharedMessage:"   ",screenShareLoadingMessage:"   {participant}",localVideoLabel:"",localVideoCameraSwitcherLabel:" ",localVideoMovementLabel:"   ",localVideoSelectedDescription:"  {cameraName}",displayNamePlaceholder:"  "};var dialpad$3={placeholderText:"  ",deleteButtonAriaLabel:""};var holdButton$3={onLabel:"",offLabel:"",tooltipOnContent:" ",tooltipOffContent:"   "};var videoTile$3={participantStateConnecting:" ...",participantStateRinging:" ...",participantStateHold:" "};var DomainPermissions$3={primaryText:" {appName}    ",secondaryText:"   ,       .",linkText:" ?     ",primaryButtonText:" "};var UnsupportedBrowser$3={primaryText:"  ",secondaryText:"       .",moreHelpLink:" "};var BrowserPermissionDenied$3={primaryText:"     ",secondaryText:",         .    ,   .",primaryButtonText:" ",linkText:" ?     "};var BrowserPermissionDeniedIOS$3={primaryText:"   ,  ",secondaryText:" ,     .",primaryButtonText:" ",imageAltText:"        iOS",linkText:" ?     ",step1Text:"   \"\"",step2Text:"      ",step3Text:"  ( )",step4Text:"     ",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var ru_RU$1 = {participantItem:participantItem$3,typingIndicator:typingIndicator$3,sendBox:sendBox$3,messageStatusIndicator:messageStatusIndicator$3,endCallButton:endCallButton$3,cameraButton:cameraButton$3,microphoneButton:microphoneButton$3,devicesButton:devicesButton$3,participantsButton:participantsButton$3,screenShareButton:screenShareButton$3,messageThread:messageThread$3,errorBar:errorBar$3,videoGallery:videoGallery$3,dialpad:dialpad$3,holdButton:holdButton$3,videoTile:videoTile$3,DomainPermissions:DomainPermissions$3,UnsupportedBrowser:UnsupportedBrowser$3,BrowserPermissionDenied:BrowserPermissionDenied$3,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$3};

var participantItem$2={isMeText:"(siz)",menuTitle:"Dier Seenekler",removeButtonLabel:"Kaldr",sharingIconLabel:"Paylam",mutedIconLabel:"Ses kapatld",displayNamePlaceholder:"Adsz Katlmc",participantStateConnecting:"Aranyor...",participantStateRinging:"Aryor...",participantStateHold:"Beklemede"};var typingIndicator$2={singleUser:"{user} yazyor...",multipleUsers:"{users} yazyor ...",multipleUsersAbbreviateOne:"{users} ve 1 kii daha yazyor...",multipleUsersAbbreviateMany:"{users} ve {numOthers} kii daha yazyor...",delimiter:", "};var sendBox$2={placeholderText:"Bir mesaj girin",textTooLong:"letinizin uzunluu st snr ayor.",sendButtonAriaLabel:"leti gnder",fileUploadsPendingError:"Karya ykleniyor... Ltfen bekleyin.",removeFile:"Dosyay kaldr",uploading:"Karya ykleniyor",uploadCompleted:"Karya ykleme tamamland"};var messageStatusIndicator$2={deliveredAriaLabel:"leti gnderildi",deliveredTooltipText:"Gnderilen",seenAriaLabel:"leti bakalar tarafndan grld",seenTooltipText:"Grld",readByTooltipText:"{messageThreadReadCount} / {remoteParticipantsCount} katlmc tarafndan okundu",sendingAriaLabel:"leti gnderiliyor",sendingTooltipText:"Gnderiliyor",failedToSendAriaLabel:"leti gnderilemedi",failedToSendTooltipText:"Gnderilemedi"};var endCallButton$2={label:"Ayrl",tooltipContent:"Aramadan ayrl"};var cameraButton$2={onLabel:"Kapat",offLabel:"A",tooltipDisabledContent:"Kamera devre d",tooltipOnContent:"Kameray kapat",tooltipOffContent:"Kameray a",tooltipVideoLoadingContent:"Video ykleniyor",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera se",cameraButtonSplitRoleDescription:"Blnm dme",onSplitButtonAriaLabel:"Kameray ve kamera seeneklerini devre d brak",offSplitButtonAriaLabel:"Kameray ve kamera seeneklerini etkinletir",cameraActionTurnedOnAnnouncement:"Kameranz ald",cameraActionTurnedOffAnnouncement:"Kameranz kapatld"};var microphoneButton$2={onLabel:"Sesi kapat",offLabel:"Sesi a",tooltipDisabledContent:"Mikrofon devre d",tooltipOnContent:"Mikrofonun sesini kapat",tooltipOffContent:"Mikrofonun sesini a",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon se",speakerMenuTitle:"Hoparlr",speakerMenuTooltip:"Hoparlr se",microphoneButtonSplitRoleDescription:"Blnm dme",onSplitButtonAriaLabel:"Mikrofonun ve ses seeneklerinin sesini kapat",offSplitButtonAriaLabel:"Mikrofonun ve ses seeneklerinin sesini a",microphoneActionTurnedOnAnnouncement:"Mikrofonunuz ald",microphoneActionTurnedOffAnnouncement:"Mikrofonunuz kapatld"};var devicesButton$2={label:"Cihazlar",tooltipContent:"Cihazlar ynet",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera se",audioDeviceMenuTitle:"Ses Cihaz",audioDeviceMenuTooltip:"Ses cihaz se",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon se",speakerMenuTitle:"Hoparlr",speakerMenuTooltip:"Hoparlr se"};var participantsButton$2={label:"Kiiler",tooltipContent:"Katlmclar gster",menuHeader:"Bu aramada",participantsListButtonLabel:"{numParticipants} kiiler",muteAllButtonLabel:"Tmnn sesini kapat",copyInviteLinkButtonLabel:"Davet balantsn kopyala"};var screenShareButton$2={onLabel:"Sunumu Durdur",offLabel:"Sun",tooltipDisabledContent:"Sunu devre d brakld.",tooltipOnContent:"Ekrannz sunuluyor",tooltipOffContent:"Ekrannz sunun"};var messageThread$2={yesterday:"Dn",sunday:"Pazar",monday:"Pazartesi",tuesday:"Sal",wednesday:"aramba",thursday:"Perembe",friday:"Cuma",saturday:"Cumartesi",participantJoined:"sohbete katld.",participantLeft:"sohbetten ayrld.",editMessage:"Dzenle",removeMessage:"Sil",resendMessage:"Yeniden gndermeyi deneyin",failToSendTag:"Gnderilemedi",editedTag:"Dzenlendi",liveAuthorIntro:"{author} yle diyor:",messageContentAriaText:"{author} iletisinde unu yazd: {message}",messageContentMineAriaText:"{message}dediniz",editBoxTextLimit:"letiniz en fazla {limitNumber} ayor",editBoxPlaceholderText:"letinizi dzenleyin",newMessagesIndicator:"Yeni iletiler",noDisplayNameSub:"Ad yok",editBoxCancelButton:"ptal",editBoxSubmitButton:"Gnder",messageReadCount:"{messageReadByCount} / {remoteParticipantsCount} katlmc tarafndan okundu",actionMenuMoreOptions:"Dier Seenekler",downloadFile:"Dosyay indir"};var errorBar$2={unableToReachChatService:"evrimdsnz",accessDenied:"Sohbet hizmetlerine eriilemedi. Ltfen salanan kullanc kimlik bilgilerini denetleyin",userNotInChatThread:"Artk bu sohbet yazmas iinde deilsiniz",sendMessageNotInChatThread:"Artk bu sohbet yazmas iinde olmadnz iin ileti gnderilemedi",sendMessageGeneric:"leti gnderilemedi",callingNetworkFailure:"Arama balanrken sorun olutu; evrimd grnyorsunuz",startVideoGeneric:"Video balatlamad",stopVideoGeneric:"Video durdurulamad",muteGeneric:"Mikrofonun sesi kapatlamad",unmuteGeneric:"Mikrofonun sesi alamad",speakingWhileMuted:"Mikrofonunuzun sesi kapal",startScreenShareGeneric:"Ekran paylam balatlamad",stopScreenShareGeneric:"Ekran paylam durdurulamad",callNetworkQualityLow:"A kalitesi dk.",callNoSpeakerFound:"Hoparlr veya kulaklk bulunamad. Aramay dinlemek iin bir ses aygt balayn.",callNoMicrophoneFound:"Mikrofon bulunamad. Ses giri cihaz balan.",callMicrophoneAccessDenied:"Mikrofona eriemiyor. Bu web sayfas iin izin vermek iin adres ubuundaki kilidi tklatn.",callMicrophoneMutedBySystem:"Sisteminiz tarafndan sessize alndnz.",callMicrophoneUnmutedBySystem:"Mikrofonunuz kurtarld ve sisteminiz tarafndan sesiniz ald.",callMacOsMicrophoneAccessDenied:"Mikrofona eriilemiyor. macOS gizlilik ayarlarnzda mikrofon izni verin.",callLocalVideoFreeze:"A bant genilii dk. Grntl aramada bakalar iin duraklatlm grnyor olabilir.",callCameraAccessDenied:"Kameraya eriemiyor. Bu web sayfas iin izin vermek iin adres ubuundaki kilidi tklatn.",callCameraAlreadyInUse:"Kameraya eriemiyor. Baka bir uygulama tarafndan zaten kullanlyor olabilir.",callVideoStoppedBySystem:"Videonuz sisteminiz tarafndan durduruldu.",callVideoRecoveredBySystem:"Videonuz devam ediyor.",callMacOsCameraAccessDenied:"MacOS kameranza eriimi engelliyor. Bu taraycnn kameranza erimesine izin vermek iin gizlilik ayarlarnz gncelletirin.",callMacOsScreenShareAccessDenied:"MacOS ekran paylamn engelliyor. Bu taraycnn ekrannz kaydetmesini izin vermek iin gizlilik ayarlarnz gncelletirin.",dismissButtonAriaLabel:"Kapat",failedToJoinCallGeneric:"Aramaya katlnamad.",failedToJoinCallInvalidMeetingLink:"Toplantya katlnamyor. Geersiz Balant."};var videoGallery$2={screenIsBeingSharedMessage:"Ekrannz paylayorsunuz.",screenShareLoadingMessage:"{participant} adl katlmcnn ekrann ykleme",localVideoLabel:"Siz",localVideoCameraSwitcherLabel:"Kameray deitir",localVideoMovementLabel:"Tanabilir Yerel Video Kutucuu",localVideoSelectedDescription:"{cameraName} seildi",displayNamePlaceholder:"Adsz Katlmc"};var dialpad$2={placeholderText:"Telefon numaras gir",deleteButtonAriaLabel:"Sil"};var holdButton$2={onLabel:"Devam et",offLabel:"Beklet",tooltipOnContent:"Grmeye devam etme",tooltipOffContent:"Aramay bekletme"};var videoTile$2={participantStateConnecting:"Aranyor...",participantStateRinging:"Aranyor...",participantStateHold:"Beklemede"};var DomainPermissions$2={primaryText:"{appName} uygulamasnn kameranz ve mikrofonunuzu kullanmasna izin verin",secondaryText:"Bu, katlmclarn sizi grebilmesi ve duyabilmesi iindir.",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln",primaryButtonText:"Eriime zin Ver"};var UnsupportedBrowser$2={primaryText:"Tarayc desteklenmiyor",secondaryText:"Ltfen uyumlu bir tarayc kullanarak bu aramaya katln.",moreHelpLink:"Daha fazla yardm"};var BrowserPermissionDenied$2={primaryText:"Kameranz veya mikrofonunuzu kullanamazsnz",secondaryText:"Taraycnzn kameranza veya mikrofonunuza eriimi olmayabilir. Bunu dzeltmek iin Sistem Tercihleri'ni an.",primaryButtonText:"Yeniden dene",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln"};var BrowserPermissionDeniedIOS$2={primaryText:"Devam etmek iin mikrofon eriimine izin ver",secondaryText:"Bylece dier katlmclar sizi duyabilir.",primaryButtonText:"Yeniden dene",imageAltText:"iOS iin mikrofon ve kamera cihaz izin konumu",linkText:"Yardma m ihtiyacnz var? Sorun giderme yardm aln",step1Text:"Ayarlar uygulamasna gidin",step2Text:"Bu taraycnn ayarlarna ilerleyin",step3Text:"Mikrofonu A (stee bal kamera)",step4Text:"Aramaya tekrar katlmay deneyin",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var tr_TR$1 = {participantItem:participantItem$2,typingIndicator:typingIndicator$2,sendBox:sendBox$2,messageStatusIndicator:messageStatusIndicator$2,endCallButton:endCallButton$2,cameraButton:cameraButton$2,microphoneButton:microphoneButton$2,devicesButton:devicesButton$2,participantsButton:participantsButton$2,screenShareButton:screenShareButton$2,messageThread:messageThread$2,errorBar:errorBar$2,videoGallery:videoGallery$2,dialpad:dialpad$2,holdButton:holdButton$2,videoTile:videoTile$2,DomainPermissions:DomainPermissions$2,UnsupportedBrowser:UnsupportedBrowser$2,BrowserPermissionDenied:BrowserPermissionDenied$2,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$2};

var participantItem$1={isMeText:"()",menuTitle:"",removeButtonLabel:"",sharingIconLabel:"",mutedIconLabel:"",displayNamePlaceholder:"",participantStateConnecting:"...",participantStateRinging:"...",participantStateHold:""};var typingIndicator$1={singleUser:"{user} ...",multipleUsers:"{users} ...",multipleUsersAbbreviateOne:"{users}  1 ...",multipleUsersAbbreviateMany:"{users}  {numOthers} ...",delimiter:" "};var sendBox$1={placeholderText:"",textTooLong:"",sendButtonAriaLabel:"",fileUploadsPendingError:"...",removeFile:"",uploading:"",uploadCompleted:""};var messageStatusIndicator$1={deliveredAriaLabel:"",deliveredTooltipText:"",seenAriaLabel:"",seenTooltipText:"",readByTooltipText:"{messageThreadReadCount}/{remoteParticipantsCount} ",sendingAriaLabel:"",sendingTooltipText:"",failedToSendAriaLabel:"",failedToSendTooltipText:""};var endCallButton$1={label:"",tooltipContent:""};var cameraButton$1={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",tooltipVideoLoadingContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",cameraButtonSplitRoleDescription:"",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",cameraActionTurnedOnAnnouncement:"",cameraActionTurnedOffAnnouncement:""};var microphoneButton$1={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:"",microphoneButtonSplitRoleDescription:"",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",microphoneActionTurnedOnAnnouncement:"",microphoneActionTurnedOffAnnouncement:""};var devicesButton$1={label:"",tooltipContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",audioDeviceMenuTitle:"",audioDeviceMenuTooltip:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:""};var participantsButton$1={label:"",tooltipContent:"",menuHeader:"",participantsListButtonLabel:"{numParticipants} ",muteAllButtonLabel:"",copyInviteLinkButtonLabel:""};var screenShareButton$1={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:""};var messageThread$1={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:"",participantLeft:"",editMessage:"",removeMessage:"",resendMessage:"",failToSendTag:"",editedTag:"",liveAuthorIntro:"{author} ",messageContentAriaText:"{author}  {message}",messageContentMineAriaText:" {message}",editBoxTextLimit:"{limitNumber}",editBoxPlaceholderText:"",newMessagesIndicator:"",noDisplayNameSub:"",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:"{messageReadByCount}/{remoteParticipantsCount} ",actionMenuMoreOptions:"",downloadFile:""};var errorBar$1={unableToReachChatService:"",accessDenied:" - ",userNotInChatThread:"",sendMessageNotInChatThread:"",sendMessageGeneric:"",callingNetworkFailure:" - ",startVideoGeneric:"",stopVideoGeneric:"",muteGeneric:"",unmuteGeneric:"",speakingWhileMuted:"",startScreenShareGeneric:"",stopScreenShareGeneric:"",callNetworkQualityLow:"",callNoSpeakerFound:"",callNoMicrophoneFound:"",callMicrophoneAccessDenied:"",callMicrophoneMutedBySystem:"",callMicrophoneUnmutedBySystem:"",callMacOsMicrophoneAccessDenied:" macOS ",callLocalVideoFreeze:"",callCameraAccessDenied:"",callCameraAlreadyInUse:"",callVideoStoppedBySystem:"",callVideoRecoveredBySystem:"",callMacOsCameraAccessDenied:"MacOS ",callMacOsScreenShareAccessDenied:"MacOS ",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"",failedToJoinCallInvalidMeetingLink:""};var videoGallery$1={screenIsBeingSharedMessage:"",screenShareLoadingMessage:" {participant} ",localVideoLabel:"",localVideoCameraSwitcherLabel:"",localVideoMovementLabel:"",localVideoSelectedDescription:" {cameraName}",displayNamePlaceholder:""};var dialpad$1={placeholderText:"",deleteButtonAriaLabel:""};var holdButton$1={onLabel:"",offLabel:"",tooltipOnContent:"",tooltipOffContent:""};var videoTile$1={participantStateConnecting:"...",participantStateRinging:"...",participantStateHold:""};var DomainPermissions$1={primaryText:"{appName}",secondaryText:"",linkText:"? ",primaryButtonText:""};var UnsupportedBrowser$1={primaryText:"",secondaryText:"",moreHelpLink:""};var BrowserPermissionDenied$1={primaryText:"",secondaryText:"",primaryButtonText:"",linkText:"? "};var BrowserPermissionDeniedIOS$1={primaryText:"",secondaryText:"",primaryButtonText:"",imageAltText:"iOS ",linkText:"? ",step1Text:"",step2Text:"",step3Text:"()",step4Text:"",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var zh_CN$1 = {participantItem:participantItem$1,typingIndicator:typingIndicator$1,sendBox:sendBox$1,messageStatusIndicator:messageStatusIndicator$1,endCallButton:endCallButton$1,cameraButton:cameraButton$1,microphoneButton:microphoneButton$1,devicesButton:devicesButton$1,participantsButton:participantsButton$1,screenShareButton:screenShareButton$1,messageThread:messageThread$1,errorBar:errorBar$1,videoGallery:videoGallery$1,dialpad:dialpad$1,holdButton:holdButton$1,videoTile:videoTile$1,DomainPermissions:DomainPermissions$1,UnsupportedBrowser:UnsupportedBrowser$1,BrowserPermissionDenied:BrowserPermissionDenied$1,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$1};

var participantItem={isMeText:"()",menuTitle:"",removeButtonLabel:"",sharingIconLabel:"",mutedIconLabel:"",displayNamePlaceholder:"",participantStateConnecting:"...",participantStateRinging:"...",participantStateHold:""};var typingIndicator={singleUser:"{user} ...",multipleUsers:"{users} ...",multipleUsersAbbreviateOne:"{users}  1 ...",multipleUsersAbbreviateMany:"{users}  {numOthers} ...",delimiter:" "};var sendBox={placeholderText:"",textTooLong:"",sendButtonAriaLabel:"",fileUploadsPendingError:"... ",removeFile:"",uploading:"",uploadCompleted:""};var messageStatusIndicator={deliveredAriaLabel:"",deliveredTooltipText:"",seenAriaLabel:"",seenTooltipText:"",readByTooltipText:" {messageThreadReadCount} / {remoteParticipantsCount}",sendingAriaLabel:"",sendingTooltipText:"",failedToSendAriaLabel:"",failedToSendTooltipText:""};var endCallButton={label:"",tooltipContent:""};var cameraButton={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",tooltipVideoLoadingContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",cameraButtonSplitRoleDescription:"[] ",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",cameraActionTurnedOnAnnouncement:"",cameraActionTurnedOffAnnouncement:""};var microphoneButton={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:"",microphoneButtonSplitRoleDescription:"[] ",onSplitButtonAriaLabel:"",offSplitButtonAriaLabel:"",microphoneActionTurnedOnAnnouncement:"",microphoneActionTurnedOffAnnouncement:""};var devicesButton={label:"",tooltipContent:"",cameraMenuTitle:"",cameraMenuTooltip:"",audioDeviceMenuTitle:"",audioDeviceMenuTooltip:"",microphoneMenuTitle:"",microphoneMenuTooltip:"",speakerMenuTitle:"",speakerMenuTooltip:""};var participantsButton={label:"",tooltipContent:"",menuHeader:"",participantsListButtonLabel:"{numParticipants} ",muteAllButtonLabel:"",copyInviteLinkButtonLabel:""};var screenShareButton={onLabel:"",offLabel:"",tooltipDisabledContent:"",tooltipOnContent:"",tooltipOffContent:""};var messageThread={yesterday:"",sunday:"",monday:"",tuesday:"",wednesday:"",thursday:"",friday:"",saturday:"",participantJoined:"",participantLeft:"",editMessage:"",removeMessage:"",resendMessage:"",failToSendTag:"",editedTag:"",liveAuthorIntro:"{author} ",messageContentAriaText:"{author}  {message}",messageContentMineAriaText:" {message}",editBoxTextLimit:" {limitNumber} ",editBoxPlaceholderText:"",newMessagesIndicator:"",noDisplayNameSub:"",editBoxCancelButton:"",editBoxSubmitButton:"",messageReadCount:" {messageReadByCount} / {remoteParticipantsCount}",actionMenuMoreOptions:"",downloadFile:""};var errorBar={unableToReachChatService:"",accessDenied:" - ",userNotInChatThread:"",sendMessageNotInChatThread:"",sendMessageGeneric:"",callingNetworkFailure:" - ",startVideoGeneric:"",stopVideoGeneric:"",muteGeneric:"",unmuteGeneric:"",speakingWhileMuted:"",startScreenShareGeneric:"",stopScreenShareGeneric:"",callNetworkQualityLow:"",callNoSpeakerFound:"",callNoMicrophoneFound:"",callMicrophoneAccessDenied:"",callMicrophoneMutedBySystem:"",callMicrophoneUnmutedBySystem:"",callMacOsMicrophoneAccessDenied:" MacOS ",callLocalVideoFreeze:"",callCameraAccessDenied:"",callCameraAlreadyInUse:"",callVideoStoppedBySystem:"",callVideoRecoveredBySystem:"",callMacOsCameraAccessDenied:"MacOS ",callMacOsScreenShareAccessDenied:"MacOS ",dismissButtonAriaLabel:"",failedToJoinCallGeneric:"",failedToJoinCallInvalidMeetingLink:""};var videoGallery={screenIsBeingSharedMessage:"",screenShareLoadingMessage:" {participant} ",localVideoLabel:"",localVideoCameraSwitcherLabel:"",localVideoMovementLabel:"",localVideoSelectedDescription:" {cameraName}",displayNamePlaceholder:""};var dialpad={placeholderText:"",deleteButtonAriaLabel:""};var holdButton={onLabel:"",offLabel:"",tooltipOnContent:"",tooltipOffContent:""};var videoTile={participantStateConnecting:"...",participantStateRinging:"...",participantStateHold:""};var DomainPermissions={primaryText:" {appName} ",secondaryText:"",linkText:"? ",primaryButtonText:""};var UnsupportedBrowser={primaryText:"",secondaryText:"",moreHelpLink:""};var BrowserPermissionDenied={primaryText:"",secondaryText:" []",primaryButtonText:"",linkText:"? "};var BrowserPermissionDeniedIOS={primaryText:"",secondaryText:"",primaryButtonText:"",imageAltText:"iOS ",linkText:"? ",step1Text:" [] ",step2Text:"",step3Text:" ()",step4Text:"",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var zh_TW$1 = {participantItem:participantItem,typingIndicator:typingIndicator,sendBox:sendBox,messageStatusIndicator:messageStatusIndicator,endCallButton:endCallButton,cameraButton:cameraButton,microphoneButton:microphoneButton,devicesButton:devicesButton,participantsButton:participantsButton,screenShareButton:screenShareButton,messageThread:messageThread,errorBar:errorBar,videoGallery:videoGallery,dialpad:dialpad,holdButton:holdButton,videoTile:videoTile,DomainPermissions:DomainPermissions,UnsupportedBrowser:UnsupportedBrowser,BrowserPermissionDenied:BrowserPermissionDenied,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS};

const createComponentStrings = (localizedStrings) => {
    const strings = Object.assign({}, en_US$1);
    Object.keys(localizedStrings).forEach((key) => {
        strings[key] = Object.assign(Object.assign({}, strings[key]), localizedStrings[key]);
    });
    return strings;
};
/**
 * Locale for English (US).
 *
 * @public
 */
const COMPONENT_LOCALE_EN_US = {
    strings: en_US$1
};
/**
 * Locale for English (GB).
 *
 * @public
 */
const COMPONENT_LOCALE_EN_GB = {
    strings: createComponentStrings(en_GB$1)
};
/**
 * Locale for  German (Germany).
 *
 * @public
 */
const COMPONENT_LOCALE_DE_DE = {
    strings: createComponentStrings(de_DE$1)
};
/**
 * Locale for Spanish (Spain).
 *
 * @public
 */
const COMPONENT_LOCALE_ES_ES = {
    strings: createComponentStrings(es_ES$1)
};
/**
 * Locale for French (France).
 *
 * @public
 */
const COMPONENT_LOCALE_FR_FR = {
    strings: createComponentStrings(fr_FR$1)
};
/**
 * Locale for Italian (Italy).
 *
 * @public
 */
const COMPONENT_LOCALE_IT_IT = {
    strings: createComponentStrings(it_IT$1)
};
/**
 * Locale for Japanese (Japan).
 *
 * @public
 */
const COMPONENT_LOCALE_JA_JP = {
    strings: createComponentStrings(ja_JP$1)
};
/**
 * Locale for Korean (South Korea).
 *
 * @public
 */
const COMPONENT_LOCALE_KO_KR = {
    strings: createComponentStrings(ko_KR$1)
};
/**
 * Locale for Dutch (Netherlands).
 *
 * @public
 */
const COMPONENT_LOCALE_NL_NL = {
    strings: createComponentStrings(nl_NL$1)
};
/**
 * Locale for Portuguese (Brazil).
 *
 * @public
 */
const COMPONENT_LOCALE_PT_BR = {
    strings: createComponentStrings(pt_BR$1)
};
/**
 * Locale for Russian (Russia).
 *
 * @public
 */
const COMPONENT_LOCALE_RU_RU = {
    strings: createComponentStrings(ru_RU$1)
};
/**
 * Locale for Turkish (Turkey).
 *
 * @public
 */
const COMPONENT_LOCALE_TR_TR = {
    strings: createComponentStrings(tr_TR$1)
};
/**
 * Locale for Chinese (Mainland China).
 *
 * @public
 */
const COMPONENT_LOCALE_ZH_CN = {
    strings: createComponentStrings(zh_CN$1)
};
/**
 * Locale for Chinese (Taiwan).
 *
 * @public
 */
const COMPONENT_LOCALE_ZH_TW = {
    strings: createComponentStrings(zh_TW$1)
};

// Copyright (c) Microsoft Corporation.
/**
 * Context for providing localized strings to components exported from this library.
 *
 * @public
 */
const LocaleContext$1 = React.createContext(COMPONENT_LOCALE_EN_US);
/**
 * Provider to provide localized strings for this library's react components.
 *
 * @remarks Components will be provided localized strings in English (US) by default if this
 * provider is not used.
 *
 * @public
 */
const LocalizationProvider$1 = (props) => {
    const { locale, children } = props;
    return React__default['default'].createElement(LocaleContext$1.Provider, { value: locale }, children);
};
/** React hook to access locale */
const useLocale$1 = () => React.useContext(LocaleContext$1);

// Copyright (c) Microsoft Corporation.
const defaultIdentifiers = {
    sendboxTextField: 'sendbox-textfield',
    participantButtonPeopleMenuItem: 'participant-button-people-menu-item',
    participantItemMenuButton: 'participant-item-menu-button',
    participantList: 'participant-list',
    participantListPeopleButton: 'participant-list-people-button',
    participantListRemoveParticipantButton: 'participant-list-remove-participant-button',
    messageContent: 'message-content',
    messageTimestamp: 'message-timestamp',
    typingIndicator: 'typing-indicator',
    videoGallery: 'video-gallery',
    videoTile: 'video-tile',
    horizontalGalleryLeftNavButton: 'horizontal-gallery-left-nav-button',
    horizontalGalleryRightNavButton: 'horizontal-gallery-right-nav-button'
};
/**
 * @private
 */
const IdentifierContext = React.createContext(defaultIdentifiers);
/**
 * React Context provider for {@link _Identifiers}.
 *
 * @experimental
 *
 * See documentation for {@link _Identifiers}.
 *
 * @internal
 */
const _IdentifierProvider = (props) => {
    const { identifiers, children } = props;
    return React__default['default'].createElement(IdentifierContext.Provider, { value: identifiers !== null && identifiers !== void 0 ? identifiers : defaultIdentifiers }, children);
};
/**
 * @private
 */
const useIdentifiers = () => React.useContext(IdentifierContext);

// Copyright (c) Microsoft Corporation.
const MAXIMUM_LENGTH_OF_TYPING_USERS = 35;
/**
 * Helper function to create element wrapping all typing users
 * @param typingUsers typing users
 * @param delimiter string to separate typing users
 * @param onRenderUser optional callback to render each typing user
 * @param userDisplayNameStyles optional additional IStyle to apply to each element containing users name
 * @returns element wrapping all typing users
 */
const getUsersElement = (typingUsers, delimiter, onRenderUser, userDisplayNameStyles) => {
    const userElements = [];
    typingUsers.forEach((user, index) => {
        userElements.push(onRenderUser ? onRenderUser(user) : React__default['default'].createElement(react.Text, { className: react.mergeStyles(userDisplayNameStyles), key: `user-${index}` }, user.displayName));
        userElements.push(React__default['default'].createElement(react.Text, { key: `comma-${index}` }, `${delimiter}`));
    }); // pop last comma
    userElements.pop();
    return React__default['default'].createElement(React__default['default'].Fragment, null, userElements);
};
/**
 * Helper function to get a string of all typing users
 * @param typingUsers typing users
 * @param delimiter string to separate typing users
 * @returns string of all typing users
 */
const getNamesString = (typingUsers, delimiter) => {
    const userNames = [];
    typingUsers.forEach(user => {
        if (user.displayName) {
            userNames.push(user.displayName);
        }
    });
    return userNames.join(delimiter);
};
/**
 * Helper function to create span elements making up the typing indicator string
 * @param strings TypingIndicatorStrings containing strings to create span elements
 * @param usersElement JSX.Element containing all typing users
 * @param numTypingUsers number of total typing users
 * @param numUserNotMentioned number of typing users abbreviated
 * @returns array of span elements making up the typing indicator string
 */
const getSpanElements = (strings, usersElement, numTypingUsers, numTypingUsersAbbreviated) => {
    let variables = {};
    let typingString = '';
    if (numTypingUsers === 1) {
        typingString = strings.singleUser;
        variables = {
            user: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {
        typingString = strings.multipleUsers;
        variables = {
            users: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {
        typingString = strings.multipleUsersAbbreviateOne;
        variables = {
            users: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {
        typingString = strings.multipleUsersAbbreviateMany;
        variables = {
            users: usersElement,
            numOthers: React__default['default'].createElement(React__default['default'].Fragment, null, numTypingUsersAbbreviated)
        };
    }
    return formatInlineElements(typingString, variables);
};
/**
 * Helper function to get the string making up the typing indicator string
 * @param strings TypingIndicatorStrings containing strings to create span elements
 * @param namesString string of all typing users
 * @param numTypingUsers number of total typing users
 * @param numUserNotMentioned number of typing users abbreviated
 * @returns typing indicator string
 */
const getIndicatorString = (strings, namesString, numTypingUsers, numTypingUsersAbbreviated) => {
    if (numTypingUsers === 1) {
        return strings.singleUser.replace('{user}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {
        return strings.multipleUsers.replace('{users}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {
        return strings.multipleUsersAbbreviateOne.replace('{users}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {
        return strings.multipleUsersAbbreviateMany.replace('{users}', namesString).replace('{numOthers}', `${numTypingUsersAbbreviated}`);
    }
    return undefined;
};
const IndicatorComponent = (typingUsers, strings, onRenderUser, styles) => {
    const typingUsersMentioned = [];
    let totalCharacterCount = 0;
    const ids = useIdentifiers();
    for (const typingUser of typingUsers) {
        if (!typingUser.displayName) {
            continue;
        }
        let additionalCharCount = typingUser.displayName.length; // The typing users will be separated by the delimiter. We account for that additional length when we generate the final string.
        if (typingUsersMentioned.length > 0) {
            additionalCharCount += strings.delimiter.length;
        }
        if (totalCharacterCount + additionalCharCount <= MAXIMUM_LENGTH_OF_TYPING_USERS || typingUsersMentioned.length === 0) {
            typingUsersMentioned.push(typingUser);
            totalCharacterCount += additionalCharCount;
        }
        else {
            break;
        }
    }
    const usersElement = getUsersElement(typingUsersMentioned, strings.delimiter, onRenderUser, styles === null || styles === void 0 ? void 0 : styles.typingUserDisplayName);
    const numUserNotMentioned = typingUsers.length - typingUsersMentioned.length;
    const spanElements = getSpanElements(strings, usersElement, typingUsers.length, numUserNotMentioned);
    const labelString = getIndicatorString(strings, getNamesString(typingUsersMentioned, strings.delimiter), typingUsers.length, numUserNotMentioned);
    return React__default['default'].createElement("div", { "data-ui-id": ids.typingIndicator, className: react.mergeStyles(typingIndicatorStringStyle, styles === null || styles === void 0 ? void 0 : styles.typingString), key: "typingStringKey", role: "status", "aria-label": labelString }, spanElements);
};
/**
 * Component to notify local user when one or more participants in the chat thread are typing.
 *
 * @public
 */
const TypingIndicator = (props) => {
    const { typingUsers, onRenderUser, styles } = props;
    const { strings } = useLocale$1();
    const typingUsersToRender = typingUsers.filter(typingUser => typingUser.displayName !== undefined);
    const indicatorComponent = IndicatorComponent(typingUsersToRender, Object.assign(Object.assign({}, strings.typingIndicator), props.strings), onRenderUser, styles);
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(typingIndicatorContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root) }, indicatorComponent);
};
/**
 * Create an array of span elements by replacing the pattern "\{\}" in str with the elements
 * passed in as vars and creating inline elements from the rest
 *
 * @param str - The string to be formatted
 * @param vars - Variables to use to format the string
 * @returns formatted JSX elements
 */
const formatInlineElements = (str, vars) => {
    if (!str) {
        return [];
    }
    if (!vars) {
        return [];
    }
    const elements = []; // regex to search for the pattern "{}"
    const placeholdersRegex = /{(\w+)}/g;
    const regex = RegExp(placeholdersRegex);
    let array = regex.exec(str);
    let prev = 0;
    while (array !== null) {
        if (prev !== array.index) {
            elements.push(React__default['default'].createElement(react.Text, { key: elements.length }, str.substring(prev, array.index)));
        }
        elements.push(React__default['default'].createElement(react.Text, { key: elements.length }, vars[array[0].substring(1, array[0].length - 1)]));
        prev = regex.lastIndex;
        array = regex.exec(str);
    }
    elements.push(React__default['default'].createElement(react.Text, { key: elements.length }, str.substring(prev)));
    return elements;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 *
 * @param fileName
 * @returns string
 */
const extension = (fileName) => fileName.split('.').pop() || '';
/**
 * @private
 * @param dismissedErrors
 * @param toDismiss
 * @returns DismissedError[]
 * Always returns a new Array so that the state variable is updated, trigerring a render.
 */
const dismissError = (dismissedErrors, toDismiss) => {
    const now = new Date(Date.now());
    for (const error of dismissedErrors) {
        if (error.type === toDismiss.type) {
            // Bump the timestamp for latest dismissal of this error to now.
            error.dismissedAt = now;
            error.activeSince = toDismiss.timestamp;
            return Array.from(dismissedErrors);
        }
    } // Record that this error was dismissed for the first time right now.
    return [...dismissedErrors, {
            type: toDismiss.type,
            dismissedAt: now,
            activeSince: toDismiss.timestamp
        }];
};
/**
 * @private
 * @param activeErrorMessages
 * @param dismissedErrors
 * @returns DismissedError[]
 *  Returns a new Array if and only if contents change, to avoid re-rendering when nothing was dropped.
 */
const dropDismissalsForInactiveErrors = (activeErrorMessages, dismissedErrors) => {
    const active = new Map();
    for (const message of activeErrorMessages) {
        active.set(message.type, message);
    } // For an error such that:
    // * It was previously active, and dismissed.
    // * It did not have a timestamp associated with it.
    // * It is no longer active.
    //
    // We remove it from dismissals. When it becomes active again next time, it will be shown again on the UI.
    const shouldDeleteDismissal = (dismissed) => dismissed.activeSince === undefined && active.get(dismissed.type) === undefined;
    if (dismissedErrors.some(dismissed => shouldDeleteDismissal(dismissed))) {
        return dismissedErrors.filter(dismissed => !shouldDeleteDismissal(dismissed));
    }
    return dismissedErrors;
};
/**
 * @private
 * @param activeErrorMessages
 * @param dismissedErrors
 * @returns ActiveErrorMessage[]
 */
const errorsToShow = (activeErrorMessages, dismissedErrors) => {
    const dismissed = new Map();
    for (const error of dismissedErrors) {
        dismissed.set(error.type, error);
    }
    return activeErrorMessages.filter(error => {
        const dismissal = dismissed.get(error.type);
        if (!dismissal) {
            // This error was never dismissed.
            return true;
        }
        if (!error.timestamp) {
            // No timestamp associated with the error. In this case, the existence of a dismissal is enough to suppress the error.
            return false;
        } // Error has an associated timestamp, so compare with last dismissal.
        return error.timestamp > dismissal.dismissedAt;
    });
};
/**
 * @private
 * @param errorType
 * @returns MessageBarType
 */
const messageBarType = (errorType) => {
    switch (errorType) {
        case 'callNetworkQualityLow':
        case 'callNoSpeakerFound':
        case 'callNoMicrophoneFound':
        case 'callMicrophoneAccessDenied':
        case 'callMicrophoneMutedBySystem':
        case 'callMicrophoneUnmutedBySystem':
        case 'callMacOsMicrophoneAccessDenied':
        case 'callLocalVideoFreeze':
        case 'callCameraAccessDenied':
        case 'callCameraAlreadyInUse':
        case 'callVideoStoppedBySystem':
        case 'callVideoRecoveredBySystem':
        case 'callMacOsCameraAccessDenied':
        case 'callMacOsScreenShareAccessDenied':
            return react.MessageBarType.warning;
        default:
            return react.MessageBarType.error;
    }
};
/**
 * @private
 * @param errorType
 * @returns IIconProps | undefined
 */
const messageBarIconProps = (errorType) => {
    const iconName = customIconName[errorType];
    return iconName ? {
        iconName
    } : undefined;
};
/**
 * @private
 */
const customIconName = {
    callNetworkQualityLow: 'ErrorBarCallNetworkQualityLow',
    callNoSpeakerFound: 'ErrorBarCallNoSpeakerFound',
    callNoMicrophoneFound: 'ErrorBarCallNoMicrophoneFound',
    callMicrophoneAccessDenied: 'ErrorBarCallMicrophoneAccessDenied',
    callMicrophoneMutedBySystem: 'ErrorBarCallMicrophoneMutedBySystem',
    callMicrophoneUnmutedBySystem: 'ErrorBarCallMicrophoneUnmutedBySystem',
    callMacOsMicrophoneAccessDenied: 'ErrorBarCallMacOsMicrophoneAccessDenied',
    callLocalVideoFreeze: 'ErrorBarCallLocalVideoFreeze',
    callCameraAccessDenied: 'ErrorBarCallCameraAccessDenied',
    callCameraAlreadyInUse: 'ErrorBarCallCameraAlreadyInUse',
    callVideoStoppedBySystem: 'ErrorBarCallVideoStoppedBySystem',
    callVideoRecoveredBySystem: 'ErrorBarCallVideoRecoveredBySystem',
    callMacOsCameraAccessDenied: 'ErrorBarCallMacOsCameraAccessDenied'
};

// Copyright (c) Microsoft Corporation.
/**
 * A component to show error messages on the UI.
 * All strings that can be shown are accepted as the {@link ErrorBarProps.strings} so that they can be localized.
 * Active errors are selected by {@link ErrorBarProps.activeErrorMessages}.
 *
 * This component internally tracks dismissed by the user.
 *   * Errors that have an associated timestamp: The error is shown on the UI again if it occurs after being dismissed.
 *   * Errors that do not have a timestamp: The error is dismissed until it disappears from the props.
 *         If the error recurs, it is shown in the UI.
 *
 * Uses {@link @fluentui/react#MessageBar} UI element.
 *
 * @public
 */
const ErrorBar = (props) => {
    var _a;
    const localeStrings = useLocale$1().strings.errorBar;
    const strings = (_a = props.strings) !== null && _a !== void 0 ? _a : localeStrings;
    const [dismissedErrors, setDismissedErrors] = React.useState([]); // dropDismissalsForInactiveErrors only returns a new object if `dismissedErrors` actually changes.
    // Without this behaviour, this `useEffect` block would cause a render loop.
    React.useEffect(() => setDismissedErrors(dropDismissalsForInactiveErrors(props.activeErrorMessages, dismissedErrors)), [props.activeErrorMessages, dismissedErrors]);
    const toShow = errorsToShow(props.activeErrorMessages, dismissedErrors);
    return React__default['default'].createElement(react.Stack, { "data-ui-id": "error-bar-stack" }, toShow.map(error => React__default['default'].createElement(react.MessageBar, Object.assign({}, props, { styles: {
            innerText: {
                paddingTop: messageBarType(error.type) === 5 ? '0.15rem' : '0.1rem',
                // to move the inner text of the message bar down to be centered
                lineHeight: 'none'
            },
            icon: {
                height: 0
            },
            content: {
                lineHeight: 'inherit'
            },
            dismissal: {
                height: 0,
                paddingTop: '0.8rem'
            }
        }, key: error.type, messageBarType: messageBarType(error.type), messageBarIconProps: messageBarIconProps(error.type), onDismiss: () => setDismissedErrors(dismissError(dismissedErrors, error)), dismissButtonAriaLabel: strings.dismissButtonAriaLabel, dismissIconProps: {
            iconName: 'ErrorBarClear'
        } }), strings[error.type])));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const gridLayoutStyle = react.mergeStyles({
    width: '100%',
    height: '100%',
    display: 'grid',
    gridGap: '0.5rem'
});

// Copyright (c) Microsoft Corporation.
/**
 * A component to lay out audio / video participants tiles in a call.
 *
 * @public
 */
const GridLayout = (props) => {
    const { children, styles } = props;
    const numberOfChildren = React__default['default'].Children.count(children);
    const [currentWidth, setCurrentWidth] = React.useState(0);
    const [currentHeight, setCurrentHeight] = React.useState(0);
    const containerRef = React.useRef(null);
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        setCurrentWidth(width);
        setCurrentHeight(height);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => currentObserver.disconnect();
    }, [observer, containerRef]);
    const gridProps = React.useMemo(() => {
        return calculateGridProps(numberOfChildren, currentWidth, currentHeight);
    }, [numberOfChildren, currentWidth, currentHeight]);
    const cssGridStyles = React.useMemo(() => createGridStyles(numberOfChildren, gridProps), [numberOfChildren, gridProps]);
    return React__default['default'].createElement("div", { ref: containerRef, className: react.mergeStyles(gridLayoutStyle, cssGridStyles, styles === null || styles === void 0 ? void 0 : styles.root) }, children);
};
/**
 * The cell aspect ratio we aim for in a grid
 */
const TARGET_CELL_ASPECT_RATIO = 16 / 9;
/**
 * The minimum cell aspect ratio we allow
 */
const MINIMUM_CELL_ASPECT_RATIO_ALLOWED = 8 / 9;
const isCloserThan = (a, b, target) => {
    return Math.abs(target - a) < Math.abs(target - b);
};
/**
 * Get the best GridProps to place a number of items in a grid as evenly as possible given the width and height of the grid
 * @param numberOfItems - number of items to place in grid
 * @param width - width of grid
 * @param height - height of grid
 * @returns GridProps
 */
const calculateGridProps = (numberOfItems, width, height) => {
    if (numberOfItems <= 0) {
        return {
            fillDirection: 'horizontal',
            rows: 0,
            columns: 0
        };
    } // If width or height are 0 then we return rows and column evenly
    if (width <= 0 || height <= 0) {
        return {
            fillDirection: 'horizontal',
            rows: Math.ceil(Math.sqrt(numberOfItems)),
            columns: Math.ceil(Math.sqrt(numberOfItems))
        };
    }
    const aspectRatio = width / height; // Approximate how many rows to divide the grid to achieve cells close to the TARGET_CELL_ASPECT_RATIO
    let rows = Math.floor(Math.sqrt(TARGET_CELL_ASPECT_RATIO / aspectRatio * numberOfItems)) || 1; // Make sure rows do not exceed numberOfItems
    rows = Math.min(rows, numberOfItems); // Given the rows, get the minimum columns needed to create enough cells for the number of items
    let columns = Math.ceil(numberOfItems / rows); // Default fill direction to horizontal
    let fillDirection = 'horizontal';
    while (rows < numberOfItems) {
        // If cell aspect ratio is less than MINIMUM_CELL_ASPECT_RATIO_ALLOWED then try more rows
        if (rows / columns * aspectRatio < MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {
            rows += 1;
            columns = Math.ceil(numberOfItems / rows);
            continue;
        }
        if (numberOfItems < rows * columns) {
            // We need to check that stretching columns vertically will result in only one less cell in stretched columns.
            // Likewise, we need to check that stretching rows horizonally will result in only one less cell in stretched rows.
            // e.g. For 4 rows, 2 columns, but only 6 items, we cannot stretch vertically because that would result in a
            // column of 2 cells which is less by more than 1 compared to the unstretched column.
            //  _________
            // |____|    |
            // |____|____|
            // |____|    |
            // |____|____|
            const canStretchVertically = numberOfItems >= rows + (columns - 1) * (rows - 1);
            const canStretchHorizontally = numberOfItems >= columns + (rows - 1) * (columns - 1);
            if (!canStretchVertically && !canStretchHorizontally) {
                rows += 1;
                columns = Math.ceil(numberOfItems / rows);
                continue;
            }
            else if (!canStretchVertically) {
                break;
            }
            else if (!canStretchHorizontally) {
                fillDirection = 'vertical';
                break;
            } // We need to figure out whether the big cells should stretch horizontally or vertically
            // to fill in the empty spaces
            // e.g. For 2 rows, 3 columns, but only 5 items, we need to choose whether to stretch cells
            //       horizontally            or           vertically
            //  ______________________               _______________________
            // |       |       |      |             |       |       |       |
            // |_______|_______|______|             |_______|_______|       |
            // |           |          |             |       |       |       |
            // |___________|__________|             |_______|_______|_______|
            // Calculate the aspect ratio of big cells stretched horizontally
            const horizontallyStretchedCellRatio = rows / (columns - 1) * aspectRatio; // Calculate the aspect ratio of big cells stretched vertically
            const verticallyStretchedCellRatio = (rows - 1) / columns * aspectRatio; // We know the horizontally stretched cells aspect ratio is higher than MINIMUM_CELL_ASPECT_RATIO_ALLOWED. If vertically stretched cells
            // is also higher than the MINIMUM_CELL_ASPECT_RATIO_ALLOWED, then choose which aspect ratio is better.
            if (verticallyStretchedCellRatio >= MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {
                // If vertically stetched cell has an aspect ratio closer to TARGET_CELL_ASPECT_RATIO then change the fill direction to vertical
                if (isCloserThan(verticallyStretchedCellRatio, horizontallyStretchedCellRatio, TARGET_CELL_ASPECT_RATIO)) {
                    fillDirection = 'vertical';
                }
            }
        }
        break;
    }
    return {
        fillDirection,
        rows,
        columns
    };
};
/**
 * Creates a styles classname with CSS Grid related styles given GridProps and the number of items to distribute as evenly as possible.
 * @param numberOfItems - number of items to place in grid
 * @param gridProps - GridProps that define the number of rows, number of columns, and the fill direction
 * @returns - classname
 */
const createGridStyles = (numberOfItems, gridProps) => {
    const isHorizontal = gridProps.fillDirection === 'horizontal'; // Blocks are either rows or columns depending on whether we fill horizontally or vertically. Each block may differ in the number of cells.
    const blocks = isHorizontal ? gridProps.rows : gridProps.columns;
    const smallCellsPerBlock = Math.ceil(numberOfItems / blocks);
    const bigCellsPerBlock = Math.floor(numberOfItems / blocks);
    const numBigCells = (gridProps.rows * gridProps.columns - numberOfItems) * bigCellsPerBlock; // Get grid units
    // e.g. If some blocks have 2 big cells while others have 3 small cells, we need to work with 6 units per block
    const units = smallCellsPerBlock * bigCellsPerBlock;
    const gridStyles = isHorizontal ? {
        gridTemplateColumns: `repeat(${units}, minmax(0, 1fr))`,
        gridTemplateRows: `repeat(${blocks}, minmax(0, 1fr))`,
        gridAutoFlow: 'row'
    } : {
        gridTemplateColumns: `repeat(${blocks}, minmax(0, 1fr))`,
        gridTemplateRows: `repeat(${units}, minmax(0, 1fr))`,
        gridAutoFlow: 'column'
    };
    const smallCellStyle = isHorizontal ? {
        '> *': {
            gridColumn: `auto / span ${units / smallCellsPerBlock}`
        }
    } : {
        '> *': {
            gridRow: `auto / span ${units / smallCellsPerBlock}`
        }
    }; // If there are big cells, we are choosing to place the latest children into the big cells.
    // That is why we use the '> *:nth-last-child(-n + ${numBigCells})' CSS selector below
    const bigCellStyle = numBigCells ? {
        [`> *:nth-last-child(-n + ${numBigCells})`]: isHorizontal ? {
            gridColumn: `auto / span ${units / bigCellsPerBlock}`
        } : {
            gridRow: `auto / span ${units / bigCellsPerBlock}`
        }
    } : {};
    return react.mergeStyles(gridStyles, smallCellStyle, bigCellStyle);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const sendBoxWrapperStyles = react.mergeStyles({
    margin: '0.25rem',
    overflow: 'hidden',
    /**
     * margin-top set for all the child components of sendbox except first
     */
    ':not(:first-child)': {
        marginTop: '0.25rem'
    }
});
/**
 * @private
 */
const sendBoxStyle = react.mergeStyles({
    paddingRight: '2rem'
});
/**
 * @private
 */
const sendButtonStyle = react.mergeStyles({
    height: '1.25rem',
    width: '1.25rem',
    marginRight: '0.313rem' // 5px
});
/**
 * @private
 */
const sendIconStyle = react.mergeStyles({
    width: '1.25rem',
    height: '1.25rem',
    margin: 'auto'
});
/**
 * @private
 */
react.mergeStyles({
    margin: '0.25rem',
    maxHeight: '12.5rem',
    overflow: 'auto'
});
/**
 * @private
 */
react.mergeStyles({
    width: '100%',
    padding: '0.50rem'
});
const defaultSendBoxInactiveBorderThicknessREM = 0.0625;
const defaultSendBoxActiveBorderThicknessREM = 0.125;
/**
 * @private
 */
const borderAndBoxShadowStyle = (props) => {
    const { theme, hasErrorMessage, disabled } = props;
    const borderColor = hasErrorMessage ? theme.semanticColors.errorText : theme.palette.neutralSecondary;
    const borderColorActive = hasErrorMessage ? theme.semanticColors.errorText : theme.palette.themePrimary;
    const borderThickness = disabled ? 0 : defaultSendBoxInactiveBorderThicknessREM;
    const borderActiveThickness = disabled ? 0 : defaultSendBoxActiveBorderThicknessREM;
    return {
        borderRadius: theme.effects.roundedCorner4,
        border: `${borderThickness}rem solid ${borderColor}`,
        // The border thickness of the sendbox wrapper changes on hover, to prevent the border thickness change causing the
        // input box to shift we apply a margin to compensate. This margin is then removed on hover when the border is thicker.
        margin: `${defaultSendBoxActiveBorderThicknessREM - borderThickness}rem`,
        ':hover, :active, :focus, :focus-within': {
            border: `${borderActiveThickness}rem solid ${borderColorActive}`,
            margin: `${defaultSendBoxActiveBorderThicknessREM - borderActiveThickness}rem`
        }
    };
};

/**
 * Preset light theme for components exported from this library.
 *
 * @public
 */
const lightTheme = {
    palette: {
        themePrimary: '#0078d4',
        themeLighterAlt: '#eff6fc',
        themeLighter: '#deecf9',
        themeLight: '#c7e0f4',
        themeTertiary: '#71afe5',
        themeSecondary: '#2b88d8',
        themeDarkAlt: '#106ebe',
        themeDark: '#59b0f7',
        themeDarker: '#004578',
        neutralLighterAlt: '#faf9f8',
        neutralLighter: '#f3f2f1',
        neutralLight: '#edebe9',
        neutralQuaternaryAlt: '#e1dfdd',
        neutralQuaternary: '#d0d0d0',
        neutralTertiaryAlt: '#c8c6c4',
        neutralTertiary: '#a19f9d',
        neutralSecondary: '#605e5c',
        neutralPrimaryAlt: '#3b3a39',
        neutralPrimary: '#323130',
        neutralDark: '#201f1e',
        black: '#000000',
        white: '#ffffff'
    },
    callingPalette: {
        callRed: '#a42e43',
        callRedDark: '#8b2c3d',
        callRedDarker: '#772a38',
        iconWhite: '#ffffff'
    },
    semanticColors: {
        errorText: '#a80000'
    }
};
/**
 * Preset dark theme for components exported from this library.
 *
 * @public
 */
const darkTheme = {
    palette: {
        themePrimary: '#2899f5',
        themeLighterAlt: '#02060a',
        themeLighter: '#061827',
        themeLight: '#0c2e49',
        themeTertiary: '#185b93',
        themeSecondary: '#2286d7',
        themeDarkAlt: '#3ca2f6',
        themeDark: '#59b0f7',
        themeDarker: '#84c5f9',
        neutralLighterAlt: '#302e2d',
        neutralLighter: '#383735',
        neutralLight: '#464443',
        neutralQuaternaryAlt: '#4e4d4b',
        neutralQuaternary: '#4d4b49',
        neutralTertiaryAlt: '#72706e',
        neutralTertiary: '#c8c8c8',
        neutralSecondary: '#d0d0d0',
        neutralPrimaryAlt: '#dadada',
        neutralPrimary: '#ffffff',
        neutralDark: '#f4f4f4',
        black: '#f8f8f8',
        white: '#252423'
    },
    callingPalette: {
        callRed: '#c4314b',
        callRedDark: '#a42e43',
        callRedDarker: '#8b2c3d',
        iconWhite: '#ffffff'
    },
    semanticColors: {
        errorText: '#f1707b'
    }
};

// Copyright (c) Microsoft Corporation.
const wrapper = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'auto'
});
const defaultTheme = react.mergeThemes(react.getTheme(), lightTheme);
/** Theme context for library's react components */
const ThemeContext = React.createContext(defaultTheme);
const initialFluentNorthstarTheme = reactNorthstar.mergeThemes(reactNorthstar.teamsTheme, {
    componentStyles: {
        ChatMessage: {
            root: {
                lineHeight: '1.4286'
            }
        }
    },
    fontFaces: [],
    // suppressing font faces from teamsTheme as recommended by FluentUI N* to avoid font styling to other elements
    siteVariables: {
        // suppressing body styles from teamsTheme to avoid inherited styling to other elements
        bodyPadding: undefined,
        bodyFontSize: undefined,
        bodyFontFamily: undefined,
        bodyBackground: undefined,
        bodyColor: undefined,
        bodyLineHeight: undefined
    }
});
/**
 * Provider to apply a Fluent theme across this library's react components.
 *
 * @remarks Components in this library are composed primarily from [Fluent UI](https://developer.microsoft.com/fluentui#/controls/web),
 * controls, and also from [Fluent React Northstar](https://fluentsite.z22.web.core.windows.net/0.53.0) controls.
 * This provider handles applying any theme provided to both the underlying Fluent UI controls, as well as the Fluent React Northstar controls.
 *
 * @public
 */
const FluentThemeProvider = (props) => {
    const { fluentTheme, rtl, children } = props;
    let fluentUITheme = react.mergeThemes(defaultTheme, fluentTheme); // merge in rtl from FluentThemeProviderProps
    fluentUITheme = react.mergeThemes(fluentUITheme, {
        rtl
    });
    const fluentNorthstarTheme = reactNorthstar.mergeThemes(initialFluentNorthstarTheme, {
        componentVariables: {
            Chat: {
                backgroundColor: fluentUITheme.palette.white
            },
            ChatMessage: {
                authorColor: fluentUITheme.palette.neutralPrimary,
                contentColor: fluentUITheme.palette.neutralPrimary,
                backgroundColor: fluentUITheme.palette.neutralLighter,
                backgroundColorMine: fluentUITheme.palette.themeLight
            }
        },
        componentStyles: {
            ChatMessage: {
                timestamp: {
                    WebkitTextFillColor: fluentUITheme.palette.neutralSecondary
                }
            }
        } // add more northstar components to align with Fluent UI theme
    });
    return React__default['default'].createElement(ThemeContext.Provider, { value: fluentUITheme },
        React__default['default'].createElement(react.ThemeProvider, { theme: fluentUITheme, className: wrapper },
            React__default['default'].createElement(reactNorthstar.Provider, { theme: fluentNorthstarTheme, className: wrapper, rtl: rtl }, children)));
};
/**
 * React hook to access theme
 *
 * @public
 */
const useTheme = () => React.useContext(ThemeContext);

// Copyright (c) Microsoft Corporation.
const WifiWarning16Filled = () => // All ErrorBar icons are 16px x 16px (when 1rem = 16 px).
 
// There is no 16px version of this icon in the fluent icon package, so scale the larger
// one down to required size.
React__default['default'].createElement("div", { className: react.mergeStyles({
        transform: 'scale(0.8)'
    }) },
    React__default['default'].createElement(reactIcons.WifiWarning20Filled, null));
const MoreHorizontal18Regular = () => // MoreHorizontal icons are 16px x 16px or 20px x 20px so scaling to get desired size
 React__default['default'].createElement("div", { className: react.mergeStyles({
        transform: 'scale(0.9)'
    }) },
    React__default['default'].createElement(reactIcons.MoreHorizontal20Regular, null));
/**
 * The default set of icons that are available to use in the UI components.
 *
 * @remark Icons used only in the composites are available in {@link DEFAULT_COMPOSITE_ICONS}.
 *
 * @public
 */
const DEFAULT_COMPONENT_ICONS = {
    ChatMessageOptions: React__default['default'].createElement(MoreHorizontal18Regular, null),
    ControlButtonCameraOff: React__default['default'].createElement(reactIcons.VideoOff20Filled, null),
    ControlButtonCameraOn: React__default['default'].createElement(reactIcons.Video20Filled, null),
    ControlButtonEndCall: React__default['default'].createElement(reactIcons.CallEnd20Filled, null),
    ControlButtonMicOff: React__default['default'].createElement(reactIcons.MicOff20Filled, null),
    ControlButtonMicOn: React__default['default'].createElement(reactIcons.MicOn20Filled, null),
    ControlButtonOptions: React__default['default'].createElement(reactIcons.Settings20Filled, null),
    ControlButtonParticipants: React__default['default'].createElement(reactIcons.People20Filled, null),
    ControlButtonScreenShareStart: React__default['default'].createElement(reactIcons.ShareScreenStart20Filled, null),
    ControlButtonScreenShareStop: React__default['default'].createElement(reactIcons.ShareScreenStop20Filled, null),
    EditBoxCancel: React__default['default'].createElement(reactIcons.Dismiss20Regular, null),
    EditBoxSubmit: React__default['default'].createElement(reactIcons.Checkmark20Regular, null),
    ErrorBarCallCameraAccessDenied: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallCameraAlreadyInUse: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallLocalVideoFreeze: React__default['default'].createElement(WifiWarning16Filled, null),
    ErrorBarCallMacOsCameraAccessDenied: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallMacOsMicrophoneAccessDenied: React__default['default'].createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallMicrophoneAccessDenied: React__default['default'].createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallMicrophoneMutedBySystem: React__default['default'].createElement(reactIcons.MicOff16Filled, null),
    ErrorBarCallMicrophoneUnmutedBySystem: React__default['default'].createElement(reactIcons.MicOn16Filled, null),
    ErrorBarCallNetworkQualityLow: React__default['default'].createElement(WifiWarning16Filled, null),
    ErrorBarCallNoMicrophoneFound: React__default['default'].createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallNoSpeakerFound: React__default['default'].createElement(reactIcons.SpeakerMute16Filled, null),
    ErrorBarClear: React__default['default'].createElement(reactIcons.Dismiss16Regular, null),
    ErrorBarCallVideoRecoveredBySystem: React__default['default'].createElement(reactIcons.Video16Filled, null),
    ErrorBarCallVideoStoppedBySystem: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    HorizontalGalleryLeftButton: React__default['default'].createElement(reactIcons.ChevronLeft20Regular, null),
    HorizontalGalleryRightButton: React__default['default'].createElement(reactIcons.ChevronRight20Regular, null),
    MessageDelivered: React__default['default'].createElement(reactIcons.CheckmarkCircle16Regular, null),
    MessageEdit: React__default['default'].createElement(reactIcons.Edit20Regular, null),
    MessageFailed: React__default['default'].createElement(reactIcons.ErrorCircle16Regular, null),
    MessageRemove: React__default['default'].createElement(reactIcons.Delete20Regular, null),
    MessageResend: React__default['default'].createElement(reactIcons.ArrowClockwise16Regular, null),
    MessageSeen: React__default['default'].createElement(reactIcons.EyeShow16Regular, null),
    MessageSending: React__default['default'].createElement(reactIcons.Circle16Regular, null),
    OptionsCamera: React__default['default'].createElement(reactIcons.Video20Regular, null),
    OptionsMic: React__default['default'].createElement(reactIcons.MicOn20Regular, null),
    OptionsSpeaker: React__default['default'].createElement(reactIcons.Speaker220Regular, null),
    ParticipantItemMicOff: React__default['default'].createElement(reactIcons.MicOff16Regular, null),
    ParticipantItemOptions: React__default['default'].createElement(React__default['default'].Fragment, null),
    ParticipantItemOptionsHovered: React__default['default'].createElement(reactIcons.MoreHorizontal20Filled, null),
    ParticipantItemScreenShareStart: React__default['default'].createElement(reactIcons.ShareScreenStart20Filled, null),
    SendBoxSend: React__default['default'].createElement(reactIcons.Send20Regular, null),
    SendBoxSendHovered: React__default['default'].createElement(reactIcons.Send20Filled, null),
    VideoTileMicOff: React__default['default'].createElement(reactIcons.MicOff16Filled, null)
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const inputBoxWrapperStyle = react.mergeStyles({
    padding: '0'
});
/**
 * @private
 */
const inputBoxStyle = react.mergeStyles({
    overflow: 'auto',
    minHeight: '2.25rem',
    // prevents the input text box from being sized to 0px when the CallWithChatComposite chat pane is closed.
    maxHeight: '8.25rem',
    outline: 'red 5px',
    fontWeight: react.FontWeights.regular,
    fontSize: '0.875rem',
    width: '100%',
    height: '2.25rem',
    lineHeight: '1.5rem',
    '::-webkit-input-placeholder': {
        fontSize: '0.875rem'
    },
    '::-moz-placeholder': {
        fontSize: '0.875rem'
    },
    ':-moz-placeholder': {
        fontSize: '0.875rem'
    }
});
/**
 * @private
 */
const inputBoxNewLineSpaceAffordance = {
    marginBottom: '2rem'
};
/**
 *
 * @private
 */
const textContainerStyle = {
    alignSelf: 'center',
    position: 'relative',
    width: '100%'
};
/**
 * @private
 */
const textFieldStyle = {
    root: {
        width: '100%',
        minHeight: '0',
        fontSize: '8.25rem'
    },
    wrapper: {},
    fieldGroup: {
        outline: 'none',
        border: 'none',
        height: 'auto',
        minHeight: '0',
        /**
         * Removing fieldGroup border to make sure no border is rendered around the text area in sendbox.
         */
        ':after': {
            border: 'none'
        }
    },
    field: {
        borderRadius: '0.25rem'
    }
};
/**
 * @private
 */
const inputButtonStyle = react.mergeStyles({
    color: 'grey',
    margin: 'auto',
    width: '1.0625rem',
    height: '1.0625rem',
    '&:hover': {
        backgroundColor: 'transparent'
    }
});
/**
 * @private
 */
const inlineButtonsContainerStyle = {
    position: 'absolute',
    right: '0.3rem',
    top: '0',
    bottom: '0',
    gap: '0.25rem',
    alignItems: 'center'
};
/**
 * @private
 */
const newLineButtonsContainerStyle = {
    position: 'absolute',
    right: '0.8rem',
    bottom: '0.8rem',
    gap: '1rem'
};
/**
 * @private
 */
const inputButtonTooltipStyle = react.mergeStyles({
    // The toolTip host container show be a flex box, so that alignItems: 'center' works for inside buttons
    display: 'flex'
});

/**
 * @private
 */
const isDarkThemed = (theme) => {
    const themeBlackBrightness = getPerceptualBrightnessOfHexColor(theme.palette.black);
    const themeWhiteBrightness = getPerceptualBrightnessOfHexColor(theme.palette.white);
    if (Number.isNaN(themeBlackBrightness) || Number.isNaN(themeWhiteBrightness)) {
        return false;
    }
    return themeBlackBrightness > themeWhiteBrightness;
};
const getPerceptualBrightnessOfHexColor = (hexColor) => {
    // return NaN if hexColor is not a hex code
    if (!/^#[0-9A-Fa-f]{6}$/i.test(hexColor)) {
        return NaN;
    }
    const r = parseInt(hexColor.substring(1, 3), 16);
    const g = parseInt(hexColor.substring(3, 5), 16);
    const b = parseInt(hexColor.substring(5, 7), 16); // arithmetic mean  of the red, green, and blue color coordinates. Source: https://en.wikipedia.org/wiki/Brightness
    return (r + g + b) / 3;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const InputBoxComponent = (props) => {
    const { styles, id, 'data-ui-id': dataUiId, textValue, onChange, textFieldRef, placeholderText, onKeyDown, onEnterKeyDown, supportNewline, inputClassName, errorMessage, disabled, children } = props;
    const mergedRootStyle = react.mergeStyles(inputBoxWrapperStyle, styles === null || styles === void 0 ? void 0 : styles.root);
    const mergedTextFiledStyle = react.mergeStyles(inputBoxStyle, inputClassName, props.inlineChildren ? {} : inputBoxNewLineSpaceAffordance);
    const mergedTextContainerStyle = react.mergeStyles(textContainerStyle, styles === null || styles === void 0 ? void 0 : styles.textFieldContainer);
    const mergedTextFieldStyle = react.concatStyleSets(textFieldStyle, {
        fieldGroup: styles === null || styles === void 0 ? void 0 : styles.textField,
        errorMessage: styles === null || styles === void 0 ? void 0 : styles.systemMessage
    });
    const onTexFieldKeyDown = React.useCallback((ev) => {
        // Uses KeyCode 229 and which code 229 to determine if the press of the enter key is from a composition session or not (Safari only)
        if (ev.nativeEvent.isComposing || ev.nativeEvent.keyCode === 229 || ev.nativeEvent.which === 229) {
            return;
        }
        if (ev.key === 'Enter' && (ev.shiftKey === false || !supportNewline)) {
            ev.preventDefault();
            onEnterKeyDown && onEnterKeyDown();
        }
        onKeyDown && onKeyDown(ev);
    }, [onEnterKeyDown, onKeyDown, supportNewline]);
    return React__default['default'].createElement(react.Stack, { className: mergedRootStyle },
        React__default['default'].createElement("div", { className: mergedTextContainerStyle },
            React__default['default'].createElement(react.TextField, { autoFocus: props.autoFocus === 'sendBoxTextField', "data-ui-id": dataUiId, multiline: true, autoAdjustHeight: true, multiple: false, resizable: false, componentRef: textFieldRef, id: id, inputClassName: mergedTextFiledStyle, placeholder: placeholderText, value: textValue, onChange: onChange, autoComplete: "off", onKeyDown: onTexFieldKeyDown, styles: mergedTextFieldStyle, disabled: disabled, errorMessage: errorMessage }),
            React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(props.inlineChildren ? inlineButtonsContainerStyle : newLineButtonsContainerStyle) }, children)));
};
/**
 * @private
 */
const InputBoxButton = (props) => {
    const { onRenderIcon, onClick, ariaLabel, className, id, tooltipContent } = props;
    const [isHover, setIsHover] = React.useState(false);
    const mergedButtonStyle = react.mergeStyles(inputButtonStyle, className);
    const theme = useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    }; // Place callout with no gap between it and the button.
    const calloutProps = {
        gapSpace: 0,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    return React__default['default'].createElement(react.TooltipHost, { hostClassName: inputButtonTooltipStyle, content: tooltipContent, calloutProps: Object.assign({}, calloutProps) },
        React__default['default'].createElement(react.IconButton, { className: mergedButtonStyle, ariaLabel: ariaLabel, onClick: onClick, id: id, onMouseEnter: () => {
                setIsHover(true);
            }, onMouseLeave: () => {
                setIsHover(false);
            }, onRenderIcon: () => onRenderIcon(isHover) }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const buttonStyle$1 = react.mergeStyles({
    color: 'grey',
    margin: '0',
    padding: '0',
    width: '1.0625rem',
    height: '1.0625rem',
    border: 'none',
    minWidth: '0',
    '&:hover': {
        backgroundColor: 'transparent'
    }
});
/**
 * @private
 */
const iconWrapperStyle$1 = react.mergeStyles({
    position: 'absolute',
    pointerEvents: 'none'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const VoiceOverButton = (props) => {
    const { onRenderIcon, onClick, ariaLabel, className, id, tooltipContent } = props;
    const [isHover, setIsHover] = React.useState(false);
    const mergedButtonStyle = react.mergeStyles(buttonStyle$1, className);
    const theme = useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    }; // Place callout with no gap between it and the button.
    const calloutProps = {
        gapSpace: 0,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    return React__default['default'].createElement(react.TooltipHost, { hostClassName: inputButtonTooltipStyle, content: tooltipContent, calloutProps: Object.assign({}, calloutProps) },
        React__default['default'].createElement(react.DefaultButton, { className: mergedButtonStyle, ariaLabel: ariaLabel, onClick: onClick, id: id, onMouseEnter: () => {
                setIsHover(true);
            }, onMouseLeave: () => {
                setIsHover(false);
            } }),
        React__default['default'].createElement("div", { className: iconWrapperStyle$1 }, onRenderIcon(isHover)));
};

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * Announcer component to maker aria announcements on actions
 */
const Announcer = (props) => {
    const { announcementString, ariaLive } = props;
    return React__default['default'].createElement(react.Stack, { "aria-label": announcementString, "aria-live": ariaLive, styles: announcerStyles });
};
/**
 * Styles to hide the announcer from view but still existing on the DOM tree it so that narration can happen.
 */
const announcerStyles = {
    root: {
        position: 'absolute',
        width: '1px',
        height: '1px',
        padding: 0,
        margin: '-1px',
        overflow: 'hidden',
        clip: 'rect(0,0,0,0)',
        whiteSpace: 'nowrap',
        border: 0
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const SendBoxErrorBar = (props) => {
    const { error, dismissAfterMs, onDismiss } = props;
    const [errorMessage, setErrorMessage] = React__default['default'].useState(error === null || error === void 0 ? void 0 : error.message); // Using `any` because `NodeJS.Timeout` here will cause `declaration error` with jest.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const timeoutRef = React__default['default'].useRef();
    React__default['default'].useEffect(() => {
        setErrorMessage(error === null || error === void 0 ? void 0 : error.message);
    }, [error]);
    React.useEffect(() => {
        if (error && dismissAfterMs !== undefined) {
            timeoutRef.current = setTimeout(() => {
                setErrorMessage(undefined);
                onDismiss && onDismiss();
            }, dismissAfterMs);
        }
        return () => {
            timeoutRef.current && clearTimeout(timeoutRef.current);
        };
    }, [dismissAfterMs, onDismiss, error]);
    if (errorMessage) {
        return React__default['default'].createElement(React__default['default'].Fragment, null,
            React__default['default'].createElement(Announcer, { announcementString: errorMessage, ariaLive: 'polite' }),
            React__default['default'].createElement(react.MessageBar, { messageBarType: react.MessageBarType.warning, styles: {
                    iconContainer: {
                        display: 'none'
                    }
                } }, errorMessage));
    }
    else {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const SendBoxErrors = (props) => {
    const { fileUploadError, fileUploadsPendingError } = props;
    const errorToDisplay = React__default['default'].useMemo(() => {
        if (fileUploadError && fileUploadsPendingError) {
            return fileUploadError.timestamp > fileUploadsPendingError.timestamp ? fileUploadError : fileUploadsPendingError;
        }
        return fileUploadError || fileUploadsPendingError;
    }, [fileUploadError, fileUploadsPendingError]);
    return React__default['default'].createElement(SendBoxErrorBar, { error: errorToDisplay, dismissAfterMs: 10 * 1000 });
};

// Copyright (c) Microsoft Corporation.
const EMPTY_MESSAGE_REGEX = /^\s*$/;
const MAXIMUM_LENGTH_OF_MESSAGE$1 = 8000;
/**
 * Component for typing and sending messages.
 *
 * Supports sending typing notification when user starts entering text.
 * Supports an optional message below the text input field.
 *
 * @public
 */
const SendBox = (props) => {
    const { disabled, systemMessage, supportNewline, onSendMessage, onTyping, onRenderIcon, onRenderSystemMessage, styles, autoFocus } = props;
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.sendBox;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const ids = useIdentifiers();
    const activeFileUploads = activeFileUploadsTrampoline();
    const [textValue, setTextValue] = React.useState('');
    const [textValueOverflow, setTextValueOverflow] = React.useState(false);
    const sendTextFieldRef = React__default['default'].useRef(null);
    const [fileUploadsPendingError, setFileUploadsPendingError] = React.useState(undefined);
    const sendMessageOnClick = () => {
        var _a;
        // don't send a message when disabled
        if (disabled || textValueOverflow) {
            return;
        } // Don't send message until all files have been uploaded successfully
        setFileUploadsPendingError(undefined);
        if (hasIncompleteFileUploads()) {
            return;
        } // we dont want to send empty messages including spaces, newlines, tabs
        // Message can be empty if there is a valid file upload
        if (!EMPTY_MESSAGE_REGEX.test(textValue) || hasFile()) {
            onSendMessage && onSendMessage(sanitizeText(textValue));
            setTextValue('');
        }
        (_a = sendTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const setText = (event, newValue) => {
        if (newValue === undefined) {
            return;
        }
        if (newValue.length > MAXIMUM_LENGTH_OF_MESSAGE$1) {
            setTextValueOverflow(true);
        }
        else {
            setTextValueOverflow(false);
        }
        setTextValue(newValue);
    };
    const textTooLongMessage = textValueOverflow ? strings.textTooLong : undefined;
    const errorMessage = systemMessage !== null && systemMessage !== void 0 ? systemMessage : textTooLongMessage;
    const mergedSendButtonStyle = React.useMemo(() => react.mergeStyles(sendButtonStyle, styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer), [styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer]);
    const mergedStyles = React.useMemo(() => react.concatStyleSets(styles), [styles]);
    const hasText = !!textValue;
    const hasTextOrFile = hasText || hasFile();
    const mergedSendIconStyle = React.useMemo(() => react.mergeStyles(sendIconStyle, {
        color: !!errorMessage || !hasTextOrFile ? theme.palette.neutralTertiary : theme.palette.themePrimary
    }, styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon), [errorMessage, hasTextOrFile, theme, styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon]);
    const onRenderSendIcon = React.useCallback((isHover) => onRenderIcon ? onRenderIcon(isHover) : React__default['default'].createElement(react.Icon, { iconName: isHover && textValue ? 'SendBoxSendHovered' : 'SendBoxSend', className: mergedSendIconStyle }), [mergedSendIconStyle, onRenderIcon, textValue]); // Ensure that errors are cleared when there are no files in sendbox
    React__default['default'].useEffect(() => {
        if (!(activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.filter(upload => !upload.error).length)) {
            setFileUploadsPendingError(undefined);
        }
    }, [activeFileUploads]);
    const sendBoxErrorsProps = React.useMemo(() => {
        var _a;
        return {
            fileUploadsPendingError: fileUploadsPendingError,
            fileUploadError: (_a = activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.filter(fileUpload => fileUpload.error).pop()) === null || _a === void 0 ? void 0 : _a.error
        };
    }, [activeFileUploads, fileUploadsPendingError]);
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(sendBoxWrapperStyles) },
        React__default['default'].createElement(SendBoxErrors, Object.assign({}, sendBoxErrorsProps)),
        React__default['default'].createElement(react.Stack, { className: react.mergeStyles(borderAndBoxShadowStyle({
                theme,
                hasErrorMessage: !!errorMessage,
                disabled: !!disabled
            })) },
            React__default['default'].createElement(InputBoxComponent, { autoFocus: autoFocus, "data-ui-id": ids.sendboxTextField, inlineChildren: true, disabled: disabled, errorMessage: onRenderSystemMessage ? onRenderSystemMessage(errorMessage) : errorMessage, textFieldRef: sendTextFieldRef, id: "sendbox", inputClassName: sendBoxStyle, placeholderText: strings.placeholderText, textValue: textValue, onChange: setText, onKeyDown: () => {
                    onTyping && onTyping();
                }, onEnterKeyDown: () => {
                    sendMessageOnClick();
                }, styles: mergedStyles, supportNewline: supportNewline, maxLength: MAXIMUM_LENGTH_OF_MESSAGE$1 },
                React__default['default'].createElement(VoiceOverButton, { onRenderIcon: onRenderSendIcon, onClick: e => {
                        if (!textValueOverflow) {
                            sendMessageOnClick();
                        }
                        e.stopPropagation();
                    }, id: 'sendIconWrapper', className: mergedSendButtonStyle, ariaLabel: localeStrings.sendButtonAriaLabel, tooltipContent: localeStrings.sendButtonAriaLabel }))));
};
/**
 * @private
 */
const hasIncompleteFileUploads = (props) => {
    const activeFileUploads = activeFileUploadsTrampoline();
    return !!((activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.length) && !activeFileUploads.filter(fileUpload => !fileUpload.error).every(fileUpload => fileUpload.uploadComplete));
};
const hasFile = (props) => {
    const activeFileUploads = activeFileUploadsTrampoline();
    return !!(activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.find(file => !file.error));
};
const sanitizeText = (message) => {
    if (EMPTY_MESSAGE_REGEX.test(message)) {
        return '';
    }
    else {
        return message;
    }
};
const activeFileUploadsTrampoline = (props) => {
    return [];
};

// Copyright (c) Microsoft Corporation.
/** @private */
const MESSAGE_STATUS_INDICATOR_SIZE_REM = 1;
/**
 * ErrorIcon seems designed slightly smaller than other icons we try to match the size and then fix positioning here.
 *
 * @private
 */
const MessageStatusIndicatorErrorIconStyle = react.mergeStyles({
    marginRight: '-0.06rem',
    fontSize: '1.06rem'
});
/**
 * @private
 */
const MessageStatusIndicatorIconStyle = react.mergeStyles({
    fontSize: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`,
    width: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`,
    height: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`
});

// Copyright (c) Microsoft Corporation.
/**
 * Component to display the status of a sent message.
 *
 * Adds an icon and tooltip corresponding to the message status.
 *
 * @public
 */
const MessageStatusIndicator = (props) => {
    const { status, styles, remoteParticipantsCount, onToggleToolTip, readCount } = props;
    const localeStrings = useLocale$1().strings.messageStatusIndicator;
    const [isTooltipToggled, setIsTooltipToggled] = React.useState(false);
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    }; // Place callout with no gap between it and the button.
    const calloutProps = {
        gapSpace: 0,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    switch (status) {
        case 'failed':
            return React__default['default'].createElement(react.TooltipHost, { content: strings.failedToSendTooltipText, "data-ui-id": "chat-composite-message-tooltip", calloutProps: Object.assign({}, calloutProps), styles: hostStyles$1 },
                strings.failedToSendAriaLabel && // live message is used here and in the following tooltips so that aria labels are announced on mobile
                    React__default['default'].createElement(reactAriaLive.LiveMessage, { message: strings.failedToSendAriaLabel, "aria-live": "polite" }),
                React__default['default'].createElement(react.Icon, { role: "status", "data-ui-id": "chat-composite-message-status-icon", "aria-label": strings.failedToSendAriaLabel, iconName: "MessageFailed", className: react.mergeStyles(MessageStatusIndicatorErrorIconStyle, {
                        color: theme.palette.redDark
                    }, styles === null || styles === void 0 ? void 0 : styles.root) }));
        case 'sending':
            return React__default['default'].createElement(react.TooltipHost, { content: strings.sendingTooltipText, "data-ui-id": "chat-composite-message-tooltip", calloutProps: Object.assign({}, calloutProps), styles: hostStyles$1 },
                strings.sendingAriaLabel && React__default['default'].createElement(reactAriaLive.LiveMessage, { message: strings.sendingAriaLabel, "aria-live": "polite" }),
                React__default['default'].createElement(react.Icon, { role: "status", "data-ui-id": "chat-composite-message-status-icon", "aria-label": strings.sendingAriaLabel, iconName: "MessageSending", className: react.mergeStyles(MessageStatusIndicatorIconStyle, {
                        color: theme.palette.themePrimary
                    }, styles === null || styles === void 0 ? void 0 : styles.root) }));
        case 'seen':
            return React__default['default'].createElement(react.TooltipHost, { calloutProps: Object.assign({}, calloutProps), "data-ui-id": "chat-composite-message-tooltip", styles: hostStyles$1, content: // when it's just 1 to 1 texting, we don't need to know who has read the message, just show message as 'seen'
                // when readcount is 0, we have a bug, show 'seen' to cover up as a fall back
                // when participant count is 0, we have a bug, show 'seen' to cover up as a fall back
                readCount === 0 || remoteParticipantsCount && remoteParticipantsCount <= 1 || !readCount || !remoteParticipantsCount || strings.readByTooltipText === undefined ? strings.seenTooltipText : _formatString(strings.readByTooltipText, {
                    messageThreadReadCount: `${readCount}`,
                    remoteParticipantsCount: `${remoteParticipantsCount}`
                }), onTooltipToggle: () => {
                    if (onToggleToolTip) {
                        onToggleToolTip(!isTooltipToggled);
                        setIsTooltipToggled(!isTooltipToggled);
                    }
                } },
                strings.seenAriaLabel && React__default['default'].createElement(reactAriaLive.LiveMessage, { message: strings.seenAriaLabel, "aria-live": "polite" }),
                React__default['default'].createElement(react.Icon, { "data-ui-id": "chat-composite-message-status-icon", role: "status", "aria-label": strings.seenAriaLabel, iconName: "MessageSeen", className: react.mergeStyles({
                        color: theme.palette.themePrimary
                    }, styles === null || styles === void 0 ? void 0 : styles.root) }));
        case 'delivered':
            return React__default['default'].createElement(react.TooltipHost, { calloutProps: Object.assign({}, calloutProps), content: strings.deliveredTooltipText, "data-ui-id": "chat-composite-message-tooltip", styles: hostStyles$1 },
                strings.deliveredAriaLabel && React__default['default'].createElement(reactAriaLive.LiveMessage, { message: strings.deliveredAriaLabel, "aria-live": "polite" }),
                React__default['default'].createElement(react.Icon, { role: "status", "data-ui-id": "chat-composite-message-status-icon", "aria-label": strings.deliveredAriaLabel, iconName: "MessageDelivered", className: react.mergeStyles(MessageStatusIndicatorIconStyle, {
                        color: theme.palette.themePrimary
                    }, styles === null || styles === void 0 ? void 0 : styles.root) }));
        default:
            return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
}; // The TooltipHost root uses display: inline by default.
// To prevent sizing issues or tooltip positioning issues, we override to inline-block.
// For more details see "Icon Button with Tooltip" on https://developer.microsoft.com/en-us/fluentui#/controls/web/button
const hostStyles$1 = {
    root: {
        display: 'inline-block'
    }
};

// Copyright (c) Microsoft Corporation.
// that can contain a message and a timestamp.
const CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM = 6.25; // Chat messages should span just short of the width of the container.
// When calculating the width of a message we also must take into account
// the width of the avatar/gutter and the gap between the message and avatar/gutter.
const AVATAR_WIDTH_REM = 2;
const AVATAR_MESSAGE_GAP_REM = 0.5;
const MESSAGE_AMOUNT_OUT_FROM_EDGE_REM = 2; // Avatars should display on top of chat messages when the chat thread is narrow
const MESSAGE_AVATAR_OVERLAP_REM = 0.425;
const CHAT_MESSAGE_ZINDEX = 1;
const AVATAR_ZINDEX = 2; // new message button should be on top of chat message
const NEW_MESSAGE_BUTTON_ZINDEX = 2;
/**
 * @private
 */
const messageThreadContainerStyle = react.mergeStyles({
    height: '100%',
    width: '100%',
    maxHeight: '100%',
    overflow: 'auto',
    position: 'relative',
    alignSelf: 'center'
});
/**
 * @private
 */
const noMessageStatusStyle = react.mergeStyles({
    // This should match the size of the message status indicator icon to ensure
    // multiple messages sent by the user are aligned correctly.
    width: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`
});
/**
 * @private
 */
const chatStyle = {
    paddingBottom: '0.5rem',
    paddingTop: '0.8rem',
    border: 'none',
    overflow: 'auto',
    // `height: 100%` ensures that the Chat component covers 100% of it's parents height
    // to prevent intermittent scrollbars when gifs are present in the chat.
    height: '100%'
};
/**
 * @private
 */
const newMessageButtonContainerStyle = react.mergeStyles({
    position: 'absolute',
    zIndex: NEW_MESSAGE_BUTTON_ZINDEX,
    bottom: 0,
    right: '1.5rem'
});
/**
 * @private
 */
const defaultChatItemMessageContainer = (overlapAvatarAndMessage) => {
    const messageAvatarGap = overlapAvatarAndMessage ? -MESSAGE_AVATAR_OVERLAP_REM : AVATAR_MESSAGE_GAP_REM;
    return {
        marginRight: '0rem',
        marginLeft: `${messageAvatarGap}rem`,
        width: `calc(100% - ${AVATAR_WIDTH_REM + MESSAGE_AMOUNT_OUT_FROM_EDGE_REM + messageAvatarGap}rem)`,
        zIndex: CHAT_MESSAGE_ZINDEX
    };
};
/**
 * @private
 */
const defaultMyChatMessageContainer = {
    maxWidth: '100%',
    minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem`,
    marginLeft: '0rem',
    // This makes message bubble show border in high contrast mode making each message distinguishable
    border: '1px solid transparent'
};
/**
 * @private
 */
const FailedMyChatMessageContainer = Object.assign(Object.assign({}, defaultChatItemMessageContainer), { backgroundColor: 'rgba(168, 0, 0, 0.2)' });
/**
 * @private
 */
const defaultChatMessageContainer = {
    maxWidth: '100%',
    minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem`,
    marginRight: '0rem',
    '& img': {
        maxWidth: '100% !important',
        // Add !important to make sure it won't be overridden by style defined in element
        height: 'auto !important'
    },
    '& p': {
        // Deal with awkward padding seen in messages from Teams.
        // For more info see https://github.com/Azure/communication-ui-library/pull/1507
        marginBlock: '0.125rem'
    },
    // This makes message bubble show border in high contrast mode making each message distinguishable
    border: '1px solid transparent'
};
/**
 * @private
 */
const gutterWithAvatar = {
    width: `${AVATAR_WIDTH_REM}`,
    position: 'relative',
    float: 'left',
    display: 'block',
    visibility: 'visible',
    zIndex: AVATAR_ZINDEX
};
/**
 * @private
 */
const gutterWithHiddenAvatar = Object.assign(Object.assign({}, gutterWithAvatar), { visibility: 'hidden', 
    // we use this hidden avatar just as a width placeholder
    // the placeholder is needed for responsive bubble width
    height: 0 });
/**
 * @private
 */
const messageStatusContainerStyle = (mine) => react.mergeStyles({
    marginLeft: mine ? '0.25rem' : '0rem'
});
/**
 * @private
 */
const newMessageButtonStyle = react.mergeStyles({
    float: 'right',
    width: 'fit-content'
});
/**
 * @private
 */
const buttonWithIconStyles$1 = {
    textContainer: {
        display: 'contents'
    }
};
/**
 * @private
 */
react.mergeStyles({
    border: 'none',
    minHeight: '1.5rem',
    '&:hover': {
        background: 'none'
    },
    '&:active': {
        background: 'none'
    }
});
/**
 * @private
 */
const DownIconStyle = react.mergeStyles({
    marginRight: '0.5em'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const delay = (delay) => {
    return new Promise(function (resolve) {
        setTimeout(resolve, delay);
    });
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const systemMessageIconStyle = react.mergeStyles({
    margin: '0 0.688rem 0 0'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const SystemMessage = (props) => {
    const { iconName, content } = props;
    const Icon = React__default['default'].createElement(react.FontIcon, { iconName: iconName, className: react.mergeStyles(systemMessageIconStyle) });
    return React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(props === null || props === void 0 ? void 0 : props.containerStyle), tabIndex: 0 },
        Icon,
        React__default['default'].createElement(react.Text, { style: {
                wordBreak: 'break-word'
            }, role: "status", title: content }, content));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const editBoxStyle = (inlineEditButtons) => react.mergeStyles({
    marginTop: '0.0875rem',
    marginBottom: '0.0875rem',
    // @TODO future refactor: This is being used to give enough space to the accept/reject edits buttons
    // This space affordance should be handled by the InputBoxComponent not the here (by the parent of the InputBoxComponent)
    paddingRight: inlineEditButtons ? '3.25rem' : '0.5rem'
});
/**
 * @private
 */
const editingButtonStyle = react.mergeStyles({
    margin: 'auto .3rem'
});
/**
 * @private
 */
const inputBoxIcon = react.mergeStyles({
    margin: 'auto',
    '&:hover svg': {
        stroke: 'currentColor'
    }
});
/**
 * @private
 */
const editBoxStyleSet = {
    root: {
        width: '100%'
    }
};

/**
 * Conditionally modify locale strings passed to the file card
 * @returns file upload card strings
 */
const useLocaleFileCardStringsTrampoline = () => {
    return {
        removeFile: '',
        uploadCompleted: '',
        uploading: ''
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * A component for displaying a file card with file icon and progress bar.
 */
const _FileCard = (props) => {
    var _a, _b, _c, _d;
    const { fileName, fileExtension, progress, actionIcon } = props;
    const theme = react.useTheme();
    const [announcerString, setAnnouncerString] = React.useState(undefined);
    const localeStrings = useLocaleFileCardStringsTrampoline();
    const uploadStartedString = (_b = (_a = props.strings) === null || _a === void 0 ? void 0 : _a.uploading) !== null && _b !== void 0 ? _b : localeStrings.uploading;
    const uploadCompletedString = (_d = (_c = props.strings) === null || _c === void 0 ? void 0 : _c.uploadCompleted) !== null && _d !== void 0 ? _d : localeStrings.uploadCompleted;
    const showProgressIndicator = progress !== undefined && progress > 0 && progress < 1;
    React.useEffect(() => {
        if (showProgressIndicator) {
            setAnnouncerString(`${uploadStartedString} ${fileName}`);
        }
        else if (progress === 1) {
            setAnnouncerString(`${fileName} ${uploadCompletedString}`);
        }
        else {
            setAnnouncerString(undefined);
        }
    }, [progress, showProgressIndicator, fileName, uploadStartedString, uploadCompletedString]);
    const progressBarThicknessPx = 4;
    const containerClassName = react.mergeStyles({
        width: '12rem',
        background: theme.palette.neutralLighter,
        borderRadius: theme.effects.roundedCorner4,
        border: `${_pxToRem(1)} solid ${theme.palette.neutralQuaternary}`,
        cursor: 'pointer'
    });
    const fileInfoWrapperClassName = react.mergeStyles({
        padding: _pxToRem(12),
        // To make space for the progress indicator.
        paddingBottom: showProgressIndicator ? _pxToRem(12 - progressBarThicknessPx * 2) : _pxToRem(12)
    });
    const fileNameContainerClassName = react.mergeStyles({
        paddingLeft: _pxToRem(4),
        minWidth: '75%',
        maxWidth: '75%'
    });
    const fileNameTextClassName = react.mergeStyles({
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        lineHeight: 'normal',
        whiteSpace: 'nowrap',
        paddingRight: _pxToRem(4)
    });
    const actionIconClassName = react.mergeStyles({
        cursor: 'pointer'
    });
    const progressIndicatorStyles = {
        itemProgress: {
            padding: `${_pxToRem(progressBarThicknessPx - 1)} 0`,
            // item progress height won't apply without an explicit padding
            // To make the progress indicator border curve along the bottom of file card.
            borderRadius: `0 0 ${theme.effects.roundedCorner4} ${theme.effects.roundedCorner4}`
        },
        progressBar: {
            height: _pxToRem(progressBarThicknessPx)
        }
    };
    return React__default['default'].createElement("div", { "data-is-focusable": true },
        React__default['default'].createElement(Announcer, { announcementString: announcerString, ariaLive: 'polite' }),
        React__default['default'].createElement(react.Stack, { className: containerClassName, onClick: () => {
                var _a;
                (_a = props.actionHandler) === null || _a === void 0 ? void 0 : _a.call(props);
            } },
            React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "space-between", verticalAlign: "center", className: fileInfoWrapperClassName },
                React__default['default'].createElement(react.Stack, null,
                    React__default['default'].createElement(react.Icon, Object.assign({ "data-ui-id": 'filetype-icon' }, reactFileTypeIcons.getFileTypeIconProps({
                        extension: fileExtension,
                        size: 24,
                        imageFileType: 'svg'
                    })))),
                React__default['default'].createElement(react.Stack, { className: fileNameContainerClassName },
                    React__default['default'].createElement(react.Text, { className: fileNameTextClassName }, fileName)),
                React__default['default'].createElement(react.Stack, { verticalAlign: "center", className: actionIconClassName }, actionIcon && actionIcon)),
            showProgressIndicator && React__default['default'].createElement(react.ProgressIndicator, { percentComplete: progress, styles: progressIndicatorStyles })));
};

// Copyright (c) Microsoft Corporation.
/**
 * Note: If we use stack tokens.childrenGap, when child elements are wrapped and moved to the next line,
 * an extra margin is added to the left of each line.
 * This is a workaround to avoid this issue.
 */
const fileCardGroupClassName = react.mergeStyles({
    flexFlow: 'row wrap',
    '& > *': {
        margin: _pxToRem(2)
    },
    /**
     * margin for children is overriden by parent stack, so adding left margin for each child
     */
    '& > *:not(:first-child)': {
        marginLeft: _pxToRem(2)
    }
});
/**
 * @internal
 * Used with `_FileCard` component where `_FileCard` components are passed as children.
 * Renders the children equally spaced in multiple rows.
 */
const _FileCardGroup = (props) => {
    const { children } = props;
    if (!children) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return React__default['default'].createElement(react.Stack, { horizontal: true, className: fileCardGroupClassName }, children);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const iconButtonClassName = react.mergeStyles({
    color: 'unset',
    width: '1rem',
    height: '1rem',
    background: 'transparent',
    ':hover': {
        color: 'unset',
        background: 'transparent'
    }
});

// Copyright (c) Microsoft Corporation.
const actionIconStyle$1 = {
    height: '1rem'
};
/**
 * @internal
 */
const _FileUploadCards = (props) => {
    var _a;
    const files = props.activeFileUploads;
    const localeStrings = useLocaleFileCardStringsTrampoline();
    const removeFileButtonString = React.useMemo(() => () => {
        var _a, _b;
        return (_b = (_a = props.strings) === null || _a === void 0 ? void 0 : _a.removeFile) !== null && _b !== void 0 ? _b : localeStrings.removeFile; // Return download button without aria label
    }, [(_a = props.strings) === null || _a === void 0 ? void 0 : _a.removeFile, localeStrings.removeFile]);
    if (!files || files.length === 0) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return React__default['default'].createElement(_FileCardGroup, null, files && files.filter(file => !file.error).map(file => React__default['default'].createElement(_FileCard, { fileName: file.filename, progress: file.progress, key: file.id, fileExtension: extension(file.filename), actionIcon: React__default['default'].createElement(react.IconButton, { className: iconButtonClassName, ariaLabel: removeFileButtonString() },
            React__default['default'].createElement(react.Icon, { iconName: "CancelFileUpload", style: actionIconStyle$1 })), actionHandler: () => {
            props.onCancelFileUpload && props.onCancelFileUpload(file.id);
        }, strings: props.strings })));
};

// Copyright (c) Microsoft Corporation.
const MAXIMUM_LENGTH_OF_MESSAGE = 8000;
const onRenderCancelIcon = (color) => {
    const className = react.mergeStyles(inputBoxIcon, {
        color
    });
    return React__default['default'].createElement(react.Icon, { iconName: 'EditBoxCancel', className: className });
};
const onRenderSubmitIcon = (color) => {
    const className = react.mergeStyles(inputBoxIcon, {
        color
    });
    return React__default['default'].createElement(react.Icon, { iconName: 'EditBoxSubmit', className: className });
};
/**
 * @private
 */
const ChatMessageComponentAsEditBox = (props) => {
    const { onCancel, onSubmit, strings, message } = props;
    const [textValue, setTextValue] = React.useState(message.content || '');
    const [attachedFilesMetadata, setAttachedFilesMetadata] = React__default['default'].useState(getMessageAttachedFilesMetadata());
    const editTextFieldRef = React__default['default'].useRef(null);
    const theme = useTheme();
    const messageState = getMessageState(textValue, attachedFilesMetadata !== null && attachedFilesMetadata !== void 0 ? attachedFilesMetadata : []);
    const submitEnabled = messageState === 'OK';
    React.useEffect(() => {
        var _a;
        (_a = editTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, []);
    const setText = (event, newValue) => {
        setTextValue(newValue !== null && newValue !== void 0 ? newValue : '');
    };
    const textTooLongMessage = messageState === 'too long' ? _formatString(strings.editBoxTextLimit, {
        limitNumber: `${MAXIMUM_LENGTH_OF_MESSAGE}`
    }) : undefined;
    const onRenderThemedCancelIcon = React.useCallback(() => onRenderCancelIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const onRenderThemedSubmitIcon = React.useCallback(() => onRenderSubmitIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const editBoxStyles = React.useMemo(() => {
        return react.concatStyleSets(editBoxStyleSet, {
            textField: {
                borderColor: theme.palette.themePrimary
            }
        });
    }, [theme.palette.themePrimary]);
    const onRenderFileUploads = React.useCallback(() => {
        return (attachedFilesMetadata === null || attachedFilesMetadata === void 0 ? void 0 : attachedFilesMetadata.length) && React__default['default'].createElement("div", { style: {
                margin: '0.25rem'
            } },
            React__default['default'].createElement(_FileUploadCards, { activeFileUploads: attachedFilesMetadata === null || attachedFilesMetadata === void 0 ? void 0 : attachedFilesMetadata.map(file => ({
                    id: file.name,
                    filename: file.name,
                    progress: 1
                })), onCancelFileUpload: fileId => {
                    setAttachedFilesMetadata(attachedFilesMetadata === null || attachedFilesMetadata === void 0 ? void 0 : attachedFilesMetadata.filter(file => file.name !== fileId));
                } }));
    }, [attachedFilesMetadata]);
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(borderAndBoxShadowStyle({
            theme,
            hasErrorMessage: false,
            disabled: false
        })) },
        React__default['default'].createElement(InputBoxComponent, { inlineChildren: props.inlineEditButtons, id: 'editbox', textFieldRef: editTextFieldRef, inputClassName: editBoxStyle(props.inlineEditButtons), placeholderText: strings.editBoxPlaceholderText, textValue: textValue, onChange: setText, onEnterKeyDown: () => {
                submitEnabled && onSubmit(textValue, message.metadata, {
                    attachedFilesMetadata
                });
            }, supportNewline: false, maxLength: MAXIMUM_LENGTH_OF_MESSAGE, errorMessage: textTooLongMessage, styles: editBoxStyles },
            React__default['default'].createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxCancelButton, tooltipContent: strings.editBoxCancelButton, onRenderIcon: onRenderThemedCancelIcon, onClick: () => {
                    onCancel && onCancel();
                }, id: 'dismissIconWrapper' }),
            React__default['default'].createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxSubmitButton, tooltipContent: strings.editBoxSubmitButton, onRenderIcon: onRenderThemedSubmitIcon, onClick: e => {
                    submitEnabled && onSubmit(textValue, message.metadata, {
                        attachedFilesMetadata
                    });
                    e.stopPropagation();
                }, id: 'submitIconWrapper' })),
        onRenderFileUploads());
};
const isMessageTooLong = (messageText) => messageText.length > MAXIMUM_LENGTH_OF_MESSAGE;
const isMessageEmpty = (messageText, attachedFilesMetadata) => messageText.trim().length === 0 && attachedFilesMetadata.length === 0;
const getMessageState = (messageText, attachedFilesMetadata) => isMessageEmpty(messageText, attachedFilesMetadata) ? 'too short' : isMessageTooLong(messageText) ? 'too long' : 'OK'; // @TODO: Remove when file-sharing feature becomes stable.
const getMessageAttachedFilesMetadata = (message) => {
    return [];
};

// Copyright (c) Microsoft Corporation.
const MINIMUM_TOUCH_TARGET_HEIGHT_REM$1 = 3;
/**
 * @private
 */
const chatActionsCSS = {
    'ul&': {
        right: '0',
        left: 'auto',
        top: '-1.2rem',
        bottom: 'auto',
        position: 'absolute'
    },
    '& a': {
        margin: '0',
        padding: '0',
        border: '0'
    }
};
/**
 * @private
 */
const iconWrapperStyle = (theme, isSubMenuOpen) => ({
    root: {
        margin: _pxToRem(3),
        // Show hover styles when the Edit/Delete menu is showing as this action button is still considered 'active'
        color: isSubMenuOpen ? theme.palette.black : theme.palette.neutralPrimary,
        strokeWidth: isSubMenuOpen ? _pxToRem(0.5) : _pxToRem(0),
        stroke: theme.palette.black,
        ':hover, :focus': {
            color: theme.palette.black,
            strokeWidth: _pxToRem(0.5)
        }
    }
});
/**
 * @private
 */
const chatMessageDateStyle = react.mergeStyles({
    fontWeight: react.FontWeights.semibold
});
/**
 * @private
 */
const chatMessageEditedTagStyle = (theme) => react.mergeStyles({
    fontWeight: react.FontWeights.semibold,
    color: theme.palette.neutralSecondary
});
/**
 * @private
 */
const chatMessageFailedTagStyle = (theme) => react.mergeStyles({
    fontWeight: react.FontWeights.light,
    color: theme.semanticColors.errorText
});
/**
 * @private
 */
const chatMessageMenuStyle = react.mergeStyles({
    minWidth: '8.5rem',
    height: 'max-content',
    cursor: 'pointer',
    overflow: 'hidden'
});
/**
 * Styles that can be applied to ensure flyout items have the minimum touch target size.
 *
 * @private
 */
const menuItemIncreasedSizeStyles = {
    root: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        maxHeight: 'unset'
    },
    linkContent: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        maxHeight: 'unset'
    },
    icon: {
        maxHeight: 'unset'
    }
};
/**
 * @private
 */
const menuIconStyleSet = {
    root: {
        height: 'calc(100% - 8px)',
        // Adjust for the pixel margin Fluent applies
        width: '1.25rem'
    }
};
/**
 * @private
 */
const menuSubIconStyleSet = {
    root: {
        height: 'unset',
        lineHeight: '100%',
        width: '1.25rem'
    }
};

/**
 * @private
 */
const formatTimeForChatMessage = (messageDate) => {
    let hours = messageDate.getHours();
    let minutes = messageDate.getMinutes().toString();
    const isAm = hours < 12;
    if (hours > 12) {
        hours = hours - 12;
    }
    if (hours === 0) {
        hours = 12;
    }
    if (minutes.length < 2) {
        minutes = '0' + minutes;
    }
    return hours.toString() + ':' + minutes + ' ' + (isAm ? 'a.m.' : 'p.m.');
};
/**
 * @private
 */
const formatDateForChatMessage = (messageDate) => {
    const year = messageDate.getFullYear().toString();
    let month = (messageDate.getMonth() + 1).toString();
    let day = messageDate.getDate().toString();
    if (month.length === 1) {
        month = '0' + month;
    }
    if (day.length === 1) {
        day = '0' + day;
    }
    return year + '-' + month + '-' + day;
};
/**
 * Given a message date object in ISO8601 and a current date object, generates a user friendly timestamp text like the
 * following:
 *
 * 1:30 p.m.
 * Yesterday 1:30 p.m.
 * Monday 1:30 p.m.
 * 2021-01-10 1:30 p.m.
 *
 * If message is after yesterday, then only show the time.
 * If message is before yesteray and after day before yesterday, then show 'Yesterday' plus the time.
 * If message is before day before yesterday and within the current week, then show 'Monday/Tuesday/etc' plus the time.
 *   - We consider start of the week as Sunday. If current day is Sunday, then any time before that is in previous week.
 * If message is in previous or older weeks, then show date string plus the time.
 *
 * @param messageDate - date of message
 * @param currentDate - date used as offset to create the user friendly timestamp (e.g. to create 'Yesterday' instead of an absolute date)
 *
 * @private
 */
const formatTimestampForChatMessage = (messageDate, todayDate, dateStrings) => {
    // If message was in the same day timestamp string is just the time like '1:30 p.m.'.
    const startOfDay = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate());
    if (messageDate > startOfDay) {
        return formatTimeForChatMessage(messageDate);
    } // If message was yesterday then timestamp string is like this 'Yesterday 1:30 p.m.'.
    const yesterdayDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - 1);
    if (messageDate > yesterdayDate) {
        return dateStrings.yesterday + ' ' + formatTimeForChatMessage(messageDate);
    } // If message was before Sunday and today is Sunday (start of week) then timestamp string is like
    // '2021-01-10 1:30 p.m.'.
    const weekDay = todayDate.getDay();
    if (weekDay === 0) {
        return formatDateForChatMessage(messageDate) + ' ' + formatTimeForChatMessage(messageDate);
    } // If message was before first day of the week then timestamp string is like Monday 1:30 p.m.
    const firstDayOfTheWeekDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - weekDay);
    if (messageDate > firstDayOfTheWeekDate) {
        return dayToDayName(messageDate.getDay(), dateStrings) + ' ' + formatTimeForChatMessage(messageDate);
    } // If message date is in previous or older weeks then timestamp string is like 2021-01-10 1:30 p.m.
    return formatDateForChatMessage(messageDate) + ' ' + formatTimeForChatMessage(messageDate);
};
const dayToDayName = (day, dateStrings) => {
    switch (day) {
        case 0:
            return dateStrings.sunday;
        case 1:
            return dateStrings.monday;
        case 2:
            return dateStrings.tuesday;
        case 3:
            return dateStrings.wednesday;
        case 4:
            return dateStrings.thursday;
        case 5:
            return dateStrings.friday;
        case 6:
            return dateStrings.saturday;
        default:
            throw new Error(`Invalid day [${day}] passed`);
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * Chat message actions flyout that contains actions such as Edit Message, or Remove Message.
 *
 * @private
 */
const ChatMessageActionFlyout = (props) => {
    var _a, _b;
    const theme = react.useTheme();
    const messageReadByCount = (_a = props.messageReadBy) === null || _a === void 0 ? void 0 : _a.length;
    const sortedMessageReadyByList = [...((_b = props.messageReadBy) !== null && _b !== void 0 ? _b : [])].sort((a, b) => a.displayName.localeCompare(b.displayName));
    const messageReadByList = sortedMessageReadyByList === null || sortedMessageReadyByList === void 0 ? void 0 : sortedMessageReadyByList.map(person => {
        const personaOptions = {
            hidePersonaDetails: true,
            size: react.PersonaSize.size24,
            text: person.displayName,
            showOverflowTooltip: false,
            styles: {
                root: {
                    margin: '0.25rem'
                }
            }
        };
        const { onRenderAvatar } = props;
        return {
            key: person.displayName,
            text: person.displayName,
            itemProps: {
                styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined
            },
            onRenderIcon: () => { var _a; return onRenderAvatar ? onRenderAvatar((_a = person.id) !== null && _a !== void 0 ? _a : '', personaOptions) : React__default['default'].createElement(react.Persona, Object.assign({}, personaOptions)); },
            iconProps: {
                styles: menuIconStyleSet
            }
        };
    });
    const menuItems = React.useMemo(() => {
        const items = [{
                key: 'Edit',
                'data-ui-id': 'chat-composite-message-contextual-menu-edit-action',
                text: props.strings.editMessage,
                itemProps: {
                    styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined
                },
                iconProps: {
                    iconName: 'MessageEdit',
                    styles: menuIconStyleSet
                },
                onClick: props.onEditClick
            }, {
                key: 'Remove',
                text: props.strings.removeMessage,
                itemProps: {
                    styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined
                },
                iconProps: {
                    iconName: 'MessageRemove',
                    styles: menuIconStyleSet
                },
                onClick: props.onRemoveClick
            }]; // only show read by x of x if more than 3 participants in total including myself
        // TODO: change strings.messageReadCount to be required if we can fallback to our own en-us strings for anything that Contoso doesn't provide
        if (props.remoteParticipantsCount && messageReadByCount !== undefined && props.remoteParticipantsCount >= 2 && props.showMessageStatus && props.strings.messageReadCount && props.messageStatus !== 'failed') {
            items.push({
                key: 'Read Count',
                'data-ui-id': 'chat-composite-message-contextual-menu-read-info',
                text: _formatString(props.strings.messageReadCount, {
                    messageReadByCount: `${messageReadByCount}`,
                    remoteParticipantsCount: `${props.remoteParticipantsCount}`
                }),
                itemProps: {
                    styles: react.concatStyleSets({
                        linkContent: {
                            color: messageReadByCount > 0 ? theme.palette.neutralPrimary : theme.palette.neutralTertiary
                        },
                        root: {
                            borderTop: `1px solid ${theme.palette.neutralLighter}`
                        }
                    }, props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined)
                },
                calloutProps: preventUnwantedDismissProps,
                subMenuProps: {
                    id: 'chat-composite-message-contextual-menu-read-name-list',
                    items: messageReadByList !== null && messageReadByList !== void 0 ? messageReadByList : [],
                    calloutProps: preventUnwantedDismissProps
                },
                iconProps: {
                    iconName: 'MessageSeen',
                    styles: {
                        root: {
                            color: messageReadByCount > 0 ? theme.palette.themeDarkAlt : theme.palette.neutralTertiary
                        }
                    }
                },
                submenuIconProps: {
                    iconName: 'HorizontalGalleryRightButton',
                    styles: menuSubIconStyleSet
                },
                disabled: messageReadByCount <= 0
            });
        }
        else if (props.messageStatus === 'failed' && props.strings.resendMessage) {
            items.push({
                key: 'Resend',
                text: props.strings.resendMessage,
                itemProps: {
                    styles: react.concatStyleSets({
                        linkContent: {
                            color: theme.palette.neutralPrimary
                        },
                        root: {
                            borderTop: `1px solid ${theme.palette.neutralLighter}`
                        }
                    }, props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined)
                },
                calloutProps: preventUnwantedDismissProps,
                iconProps: {
                    iconName: 'MessageResend',
                    styles: {
                        root: {
                            color: theme.palette.themeDarkAlt
                        }
                    }
                },
                onClick: props.onResendClick
            });
        }
        return items;
    }, [props.strings.editMessage, props.strings.removeMessage, props.strings.messageReadCount, props.strings.resendMessage, props.messageStatus, props.increaseFlyoutItemSize, props.onEditClick, props.onRemoveClick, props.onResendClick, props.remoteParticipantsCount, props.showMessageStatus, messageReadByCount, theme.palette.neutralPrimary, theme.palette.neutralTertiary, theme.palette.neutralLighter, theme.palette.themeDarkAlt, messageReadByList]); // gap space uses pixels
    return React__default['default'].createElement(react.ContextualMenu, { id: "chat-composite-message-contextual-menu", alignTargetEdge: true, gapSpace: 5, isBeakVisible: false, items: menuItems, hidden: props.hidden, target: props.target, onDismiss: props.onDismiss, directionalHint: react.DirectionalHint.topRightEdge, className: chatMessageMenuStyle, calloutProps: preventUnwantedDismissProps });
};
/**
 * Similar to {@link preventDismissOnEvent}, but not prevent dismissing from scrolling, since it is causing bugs in chat thread.
 */
const preventUnwantedDismissProps = {
    preventDismissOnEvent: (ev) => {
        return ev.type === 'resize';
    }
};

// Copyright (c) Microsoft Corporation.
/** @private */
const ChatMessageContent = (props) => {
    switch (props.message.contentType) {
        case 'text':
            return MessageContentAsText(props);
        case 'html':
            return MessageContentAsRichTextHTML(props);
        case 'richtext/html':
            return MessageContentAsRichTextHTML(props);
        default:
            console.warn('unknown message content type');
            return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
};
const MessageContentAsRichTextHTML = (props) => {
    const htmlToReactParser = new htmlToReact.Parser();
    const liveAuthor = _formatString(props.liveAuthorIntro, {
        author: `${props.message.senderDisplayName}`
    });
    return React__default['default'].createElement("div", { "data-ui-status": props.message.status, role: "text", "aria-text": props.messageContentAriaText },
        React__default['default'].createElement(reactAriaLive.LiveMessage, { message: `${props.message.mine ? '' : liveAuthor} ${extractContent(props.message.content || '')}`, "aria-live": "polite" }),
        htmlToReactParser.parse(props.message.content));
};
const MessageContentAsText = (props) => {
    const liveAuthor = _formatString(props.liveAuthorIntro, {
        author: `${props.message.senderDisplayName}`
    });
    return React__default['default'].createElement("div", { "data-ui-status": props.message.status, role: "text", "aria-label": props.messageContentAriaText },
        React__default['default'].createElement(reactAriaLive.LiveMessage, { message: `${props.message.mine ? '' : liveAuthor} ${props.message.content}`, "aria-live": "polite" }),
        React__default['default'].createElement(Linkify__default['default'], { componentDecorator: (decoratedHref, decoratedText, key) => {
                return React__default['default'].createElement(react.Link, { target: "_blank", href: decoratedHref, key: key }, decoratedText);
            } }, props.message.content));
}; // https://stackoverflow.com/questions/28899298/extract-the-text-out-of-html-string-using-javascript
const extractContent = (s) => {
    const span = document.createElement('span');
    span.innerHTML = s;
    return span.textContent || span.innerText;
};

// Copyright (c) Microsoft Corporation.
/**
 * Props for the Chat.Message action menu.
 * This is the 3 dots that appear when hovering over one of your own chat messages.
 *
 * @private
 */
const chatMessageActionMenuProps = (menuProps) => {
    if (!menuProps.enabled) {
        return undefined;
    }
    const menuClass = react.mergeStyles(chatActionsCSS, {
        'ul&': {
            boxShadow: menuProps.theme.effects.elevation4,
            backgroundColor: menuProps.theme.palette.white
        }
    });
    const actionMenuProps = {
        showActionMenu: menuProps.forceShow === true ? true : undefined,
        iconOnly: true,
        activeIndex: -1,
        className: menuClass,
        onItemClick: () => menuProps.onActionButtonClick(),
        items: [{
                children: React__default['default'].createElement(reactNorthstar.Ref, { innerRef: menuProps.menuButtonRef },
                    React__default['default'].createElement(react.Icon, { iconName: "ChatMessageOptions", "data-ui-id": "chat-composite-message-action-icon", "aria-label": menuProps.ariaLabel, styles: iconWrapperStyle(menuProps.theme, menuProps.forceShow) })),
                key: 'menuButton',
                indicator: false
            }]
    };
    return actionMenuProps;
};

var __awaiter$s = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fileDownloadCardsStyle = {
    marginTop: '0.25rem'
};
const actionIconStyle = {
    height: '1rem'
};
/**
 * @internal
 */
const _FileDownloadCards = (props) => {
    var _a;
    const { userId, fileMetadata } = props;
    const [showSpinner, setShowSpinner] = React.useState(false);
    const localeStrings = useLocaleStringsTrampoline();
    const downloadFileButtonString = React.useMemo(() => () => {
        var _a, _b;
        return (_b = (_a = props.strings) === null || _a === void 0 ? void 0 : _a.downloadFile) !== null && _b !== void 0 ? _b : localeStrings.downloadFile; // Return download button without aria label
    }, [(_a = props.strings) === null || _a === void 0 ? void 0 : _a.downloadFile, localeStrings.downloadFile]);
    const fileDownloadHandler = React.useCallback((userId, file) => __awaiter$s(void 0, void 0, void 0, function* () {
        if (!props.downloadHandler) {
            window.open(file.url, '_blank', 'noopener,noreferrer');
        }
        else {
            setShowSpinner(true);
            try {
                const response = yield props.downloadHandler(userId, file);
                setShowSpinner(false);
                if (response instanceof URL) {
                    window.open(response.toString(), '_blank', 'noopener,noreferrer');
                }
                else {
                    props.onDownloadErrorMessage && props.onDownloadErrorMessage(response.errorMessage);
                }
            }
            finally {
                setShowSpinner(false);
            }
        }
    }), [props]);
    if (!fileMetadata || fileMetadata.length === 0) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return React__default['default'].createElement("div", { style: fileDownloadCardsStyle, "data-ui-id": "file-download-card-group" },
        React__default['default'].createElement(_FileCardGroup, null, fileMetadata && fileMetadata.map(file => React__default['default'].createElement(_FileCard, { fileName: file.name, key: file.name, fileExtension: file.extension, actionIcon: showSpinner ? React__default['default'].createElement(react.Spinner, { size: react.SpinnerSize.medium, "aria-live": 'polite', role: 'status' }) : React__default['default'].createElement(react.IconButton, { className: iconButtonClassName, ariaLabel: downloadFileButtonString() },
                React__default['default'].createElement(DownloadIconTrampoline, null)), actionHandler: () => fileDownloadHandler(userId, file) }))));
};
/**
 * @private
 */
const DownloadIconTrampoline = () => {
    // Return _some_ available icon, as the real icon is beta-only.
    return React__default['default'].createElement(react.Icon, { iconName: "EditBoxCancel", style: actionIconStyle });
};
const useLocaleStringsTrampoline = () => {
    return {
        downloadFile: ''
    };
};

// Copyright (c) Microsoft Corporation.
const generateDefaultTimestamp = (createdOn, showDate, strings) => {
    const formattedTimestamp = showDate ? formatTimestampForChatMessage(createdOn, new Date(), strings) : formatTimeForChatMessage(createdOn);
    return formattedTimestamp;
}; // onDisplayDateTimeString from props overwrite onDisplayDateTimeString from locale
const generateCustomizedTimestamp = (props, createdOn, locale) => {
    return '';
};
/** @private */
const MessageBubble = (props) => {
    var _a;
    const ids = useIdentifiers();
    const theme = useTheme();
    useLocale$1();
    const { userId, message, onRemoveClick, onResendClick, disableEditing, showDate, messageContainerStyle, strings, onEditClick, remoteParticipantsCount = 0, onRenderAvatar, showMessageStatus, messageStatus, fileDownloadHandler } = props;
    const defaultTimeStamp = message.createdOn ? generateDefaultTimestamp(message.createdOn, showDate, strings) : undefined;
    const customTimestamp = message.createdOn ? generateCustomizedTimestamp(props, message.createdOn) : '';
    const formattedTimestamp = customTimestamp || defaultTimeStamp; // Track if the action menu was opened by touch - if so we increase the touch targets for the items
    const [wasInteractionByTouch, setWasInteractionByTouch] = React.useState(false); // The chat message action flyout should target the Chat.Message action menu if clicked,
    // or target the chat message if opened via touch press.
    // Undefined indicates the flyout menu should not be being shown.
    const messageRef = React.useRef(null);
    const messageActionButtonRef = React.useRef(null);
    const [chatMessageActionFlyoutTarget, setChatMessageActionFlyoutTarget] = React.useState(undefined);
    const chatActionsEnabled = !disableEditing && message.status !== 'sending' && !!message.mine;
    const [messageReadBy, setMessageReadBy] = React.useState([]);
    const actionMenuProps = wasInteractionByTouch ? undefined : chatMessageActionMenuProps({
        ariaLabel: (_a = strings.actionMenuMoreOptions) !== null && _a !== void 0 ? _a : '',
        enabled: chatActionsEnabled,
        menuButtonRef: messageActionButtonRef,
        // Force show the action button while the flyout is open (otherwise this will dismiss when the pointer is hovered over the flyout)
        forceShow: chatMessageActionFlyoutTarget === messageActionButtonRef,
        onActionButtonClick: () => {
            props.onActionButtonClick(message, setMessageReadBy);
            setChatMessageActionFlyoutTarget(messageActionButtonRef);
        },
        theme
    });
    const onActionFlyoutDismiss = React.useCallback(() => {
        // When the flyout dismiss is called, since we control if the action flyout is visible
        // or not we need to set the target to undefined here to actually hide the action flyout
        setChatMessageActionFlyoutTarget(undefined);
    }, [setChatMessageActionFlyoutTarget]);
    const defaultOnRenderFileDownloads = React.useCallback(() => React__default['default'].createElement(_FileDownloadCards, { userId: userId, fileMetadata: message['attachedFilesMetadata'] || [], downloadHandler: fileDownloadHandler }), [userId, message, fileDownloadHandler]);
    const messageContentAriaText = props.message.content ? props.message.mine ? _formatString(strings.messageContentMineAriaText, {
        message: props.message.content
    }) : _formatString(strings.messageContentAriaText, {
        author: `${props.message.senderDisplayName}`,
        message: props.message.content
    }) : undefined;
    const chatMessage = React__default['default'].createElement(React__default['default'].Fragment, null,
        React__default['default'].createElement("div", { ref: messageRef },
            React__default['default'].createElement(reactNorthstar.Chat.Message, { "data-ui-id": "chat-composite-message", className: react.mergeStyles(messageContainerStyle), styles: messageContainerStyle, content: React__default['default'].createElement("div", { tabIndex: 0 },
                    React__default['default'].createElement(ChatMessageContent, { message: message, liveAuthorIntro: strings.liveAuthorIntro, messageContentAriaText: messageContentAriaText }),
                    props.onRenderFileDownloads ? props.onRenderFileDownloads(userId, message) : defaultOnRenderFileDownloads()), author: React__default['default'].createElement(reactNorthstar.Text, { className: chatMessageDateStyle }, message.senderDisplayName), mine: message.mine, timestamp: React__default['default'].createElement(reactNorthstar.Text, { "data-ui-id": ids.messageTimestamp }, formattedTimestamp), details: messageStatus === 'failed' ? React__default['default'].createElement("div", { className: chatMessageFailedTagStyle(theme) }, strings.failToSendTag) : message.editedOn ? React__default['default'].createElement("div", { className: chatMessageEditedTagStyle(theme) }, strings.editedTag) : undefined, positionActionMenu: false, actionMenu: actionMenuProps, onTouchStart: () => setWasInteractionByTouch(true), onPointerDown: () => setWasInteractionByTouch(false), onKeyDown: () => setWasInteractionByTouch(false), onBlur: () => setWasInteractionByTouch(false), onClick: () => {
                    if (!wasInteractionByTouch) {
                        return;
                    } // If the message was touched via touch we immediately open the menu
                    // flyout (when using mouse the 3-dot menu that appears on hover
                    // must be clicked to open the flyout).
                    // In doing so here we set the target of the flyout to be the message and
                    // not the 3-dot menu button to position the flyout correctly.
                    setChatMessageActionFlyoutTarget(messageRef);
                    props.onActionButtonClick(message, setMessageReadBy);
                } })),
        chatActionsEnabled && React__default['default'].createElement(ChatMessageActionFlyout, { hidden: !chatMessageActionFlyoutTarget, target: chatMessageActionFlyoutTarget, increaseFlyoutItemSize: wasInteractionByTouch, onDismiss: onActionFlyoutDismiss, onEditClick: onEditClick, onRemoveClick: onRemoveClick, onResendClick: onResendClick, strings: strings, messageReadBy: messageReadBy, messageStatus: messageStatus !== null && messageStatus !== void 0 ? messageStatus : 'failed', remoteParticipantsCount: remoteParticipantsCount, onRenderAvatar: onRenderAvatar, showMessageStatus: showMessageStatus }));
    return chatMessage;
};
/** @private */
const ChatMessageComponentAsMessageBubble = React__default['default'].memo(MessageBubble);

var __awaiter$r = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const ChatMessageComponent = (props) => {
    const [isEditing, setIsEditing] = React.useState(false);
    const onEditClick = React.useCallback(() => setIsEditing(true), [setIsEditing]);
    const { onDeleteMessage, onSendMessage, message } = props;
    const onRemoveClick = React.useCallback(() => {
        if (onDeleteMessage && message.messageId) {
            onDeleteMessage(message.messageId);
        } // when fail to send, message does not have message id, delete message using clientmessageid
        else if (onDeleteMessage && message.clientMessageId) {
            onDeleteMessage(message.clientMessageId);
        }
    }, [message.messageId, message.clientMessageId, onDeleteMessage]);
    const onResendClick = React.useCallback(() => {
        var _a;
        onDeleteMessage && message.clientMessageId && onDeleteMessage(message.clientMessageId);
        onSendMessage && onSendMessage((_a = message.content) !== null && _a !== void 0 ? _a : '');
    }, [message.clientMessageId, message.content, onSendMessage, onDeleteMessage]);
    if (props.message.messageType !== 'chat') {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    else if (isEditing) {
        return React__default['default'].createElement(ChatMessageComponentAsEditBox, { message: message, inlineEditButtons: props.inlineAcceptRejectEditButtons, strings: props.strings, onSubmit: (text, metadata, options) => __awaiter$r(void 0, void 0, void 0, function* () {
                props.onUpdateMessage && props.message.messageId && (yield props.onUpdateMessage(props.message.messageId, text, metadata, options));
                setIsEditing(false);
            }), onCancel: () => {
                setIsEditing(false);
            } });
    }
    else {
        return React__default['default'].createElement(ChatMessageComponentAsMessageBubble, Object.assign({}, props, { onRemoveClick: onRemoveClick, onEditClick: onEditClick, onResendClick: onResendClick, onRenderAvatar: props.onRenderAvatar, strings: props.strings }));
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * A utility hook for providing the width of a parent element.
 * Returns updated width if parent/window resizes.
 * @param containerRef - Ref of a parent element whose width will be returned.
 * @internal
 */
const _useContainerWidth = (containerRef) => {
    const [width, setWidth] = React.useState(undefined);
    const observer = React.useRef(new ResizeObserver(entries => {
        const { width } = entries[0].contentRect;
        setWidth(width);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => {
            currentObserver.disconnect();
        };
    }, [containerRef, observer]);
    return width;
};
/**
 * A utility hook for providing the height of a parent element.
 * Returns updated height if parent/window resizes.
 * @param containerRef - Ref of a parent element whose height will be returned.
 * @internal
 */
const _useContainerHeight = (containerRef) => {
    const [height, setHeight] = React.useState(undefined);
    const observer = React.useRef(new ResizeObserver(entries => {
        const { height } = entries[0].contentRect;
        setHeight(height);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => {
            currentObserver.disconnect();
        };
    }, [containerRef, observer]);
    return height;
};
const NARROW_WIDTH_REM = 30;
/**
 * Utility function to determine if container width is narrow
 * @param containerWidthRem  container width in rem
 * @returns boolean
 */
const isNarrowWidth = (containerWidthRem) => containerWidthRem <= _convertRemToPx(NARROW_WIDTH_REM);

/**
 * @private
 *logic: Looking at message A, how do we know it's read number?
 * Assumption: if user read the latest message, user has read all messages before that
 * ReadReceipt behaviour: read receipt is only sent to the last message
 *
 * If participant read a message that is sent later than message A, then the participant has read message A
 * How do we check if the message is sent later than message A?
 * We compare if the messageID of the last read message is larger than or equal to the message A's id
 * Because messageID is the creation timestamp of each message
 * Timestamps are in epoch time so lecixographical ordering is the same as time ordering.
 *
 * if MessageId of B is larger than message Id of A, then B is created after A
 * if the last read message is created after the message A is sent, then user should have read message A as well */
const getParticipantsWhoHaveReadMessage = (message, readReceiptsBySenderId) => {
    return Object.entries(readReceiptsBySenderId) // Filter to only read receipts that match the message OR the participant has read a different message after this message has been created
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        .filter(([_, readReceipt]) => readReceipt.lastReadMessage >= message.messageId) // make sure the person is not removed from chat
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        .filter(([_, readReceipt]) => readReceipt.displayName && readReceipt.displayName !== '') // Map properties to useful array
        .map(([id, readReceipt]) => ({
        id,
        displayName: readReceipt.displayName
    }));
};

var __awaiter$q = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const isMessageSame = (first, second) => {
    return first.messageId === second.messageId && first.content === second.content && first.contentType === second.contentType && JSON.stringify(first.createdOn) === JSON.stringify(second.createdOn) && first.senderId === second.senderId && first.senderDisplayName === second.senderDisplayName && first.status === second.status;
};
/**
 * Get the latest message from the message array.
 *
 * @param messages
 */
const getLatestChatMessage = (messages) => {
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.messageType === 'chat' && !!message.createdOn) {
            return message;
        }
    }
    return undefined;
};
/**
 * Compare latestMessageFromPreviousMessages & latestMessageFromNewMessages to see if the new message is not from
 * current user.
 */
const isThereNewMessageNotFromCurrentUser = (userId, latestMessageFromPreviousMessages, latestMessageFromNewMessages) => {
    if (latestMessageFromNewMessages === undefined) {
        return false;
    }
    if (latestMessageFromPreviousMessages === undefined) {
        return latestMessageFromNewMessages.senderId !== userId;
    }
    return !isMessageSame(latestMessageFromNewMessages, latestMessageFromPreviousMessages) && latestMessageFromNewMessages.senderId !== userId;
};
/**
 * Returns true if the current user sent the latest message and false otherwise. It will ignore messages that have no
 * sender, messages that have failed to send, and messages from the current user that is marked as SEEN. This is meant
 * as an indirect way to detect if user is at bottom of the chat when the component updates with new messages. If we
 * updated this component due to current user sending a message we want to then call scrollToBottom.
 */
const didUserSendTheLatestMessage = (userId, latestMessageFromPreviousMessages, latestMessageFromNewMessages) => {
    if (latestMessageFromNewMessages === undefined) {
        return false;
    }
    if (latestMessageFromPreviousMessages === undefined) {
        return latestMessageFromNewMessages.senderId === userId;
    }
    return !isMessageSame(latestMessageFromNewMessages, latestMessageFromPreviousMessages) && latestMessageFromNewMessages.senderId === userId;
};
const DefaultJumpToNewMessageButton = (props) => {
    const { text, onClick } = props;
    return React__default['default'].createElement(react.PrimaryButton, { className: newMessageButtonStyle, styles: buttonWithIconStyles$1, text: text, onClick: onClick, onRenderIcon: () => React__default['default'].createElement(react.Icon, { iconName: "Down", className: DownIconStyle }) });
};
const generateParticipantsStr = (participants, defaultName) => participants.map(participant => `${!participant.displayName || participant.displayName === '' ? defaultName : participant.displayName}`).join(', ');
const ParticipantSystemMessageComponent = ({ message, style, defaultName }) => {
    const { strings } = useLocale$1();
    const participantsStr = generateParticipantsStr(message.participants, defaultName);
    const messageSuffix = message.systemMessageType === 'participantAdded' ? strings.messageThread.participantJoined : strings.messageThread.participantLeft;
    if (participantsStr !== '') {
        return React__default['default'].createElement(SystemMessage, { iconName: (message.iconName ? message.iconName : ''), content: `${participantsStr} ${messageSuffix}`, containerStyle: style });
    }
    return React__default['default'].createElement(React__default['default'].Fragment, null);
};
const DefaultSystemMessage = (props) => {
    var _a;
    const message = props.message;
    switch (message.messageType) {
        case 'system':
            switch (message.systemMessageType) {
                case 'content':
                    return React__default['default'].createElement(SystemMessage, { iconName: (message.iconName ? message.iconName : ''), content: (_a = message.content) !== null && _a !== void 0 ? _a : '', containerStyle: props === null || props === void 0 ? void 0 : props.messageContainerStyle });
                case 'participantAdded':
                case 'participantRemoved':
                    return React__default['default'].createElement(ParticipantSystemMessageComponent, { message: message, style: props.messageContainerStyle, defaultName: props.strings.noDisplayNameSub });
            }
    }
    return React__default['default'].createElement(React__default['default'].Fragment, null);
};
const memoizeAllMessages = memoizeFnAll((_messageKey, message, showMessageDate, showMessageStatus, onRenderAvatar, shouldOverlapAvatarAndMessage, styles, onRenderMessageStatus, defaultStatusRenderer, defaultChatMessageRenderer, strings, _attached, statusToRender, participantCount, readCount, onRenderMessage, onUpdateMessage, onDeleteMessage, onSendMessage) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const messageProps = {
        message,
        strings,
        showDate: showMessageDate,
        onUpdateMessage,
        onDeleteMessage,
        onSendMessage
    };
    switch (message.messageType) {
        case 'chat':
            {
                const myChatMessageStyle = message.status === 'failed' ? (_b = (_a = styles === null || styles === void 0 ? void 0 : styles.failedMyChatMessageContainer) !== null && _a !== void 0 ? _a : styles === null || styles === void 0 ? void 0 : styles.myChatMessageContainer) !== null && _b !== void 0 ? _b : FailedMyChatMessageContainer : (_c = styles === null || styles === void 0 ? void 0 : styles.myChatMessageContainer) !== null && _c !== void 0 ? _c : defaultMyChatMessageContainer;
                const chatMessageStyle = (_d = styles === null || styles === void 0 ? void 0 : styles.chatMessageContainer) !== null && _d !== void 0 ? _d : defaultChatMessageContainer;
                messageProps.messageContainerStyle = message.mine ? myChatMessageStyle : chatMessageStyle;
                const chatMessageComponent = onRenderMessage === undefined ? defaultChatMessageRenderer(messageProps) : onRenderMessage(messageProps, defaultChatMessageRenderer);
                const personaOptions = {
                    hidePersonaDetails: true,
                    size: react.PersonaSize.size32,
                    text: message.senderDisplayName,
                    showOverflowTooltip: false
                };
                const chatItemMessageStyle = (message.mine ? styles === null || styles === void 0 ? void 0 : styles.myChatItemMessageContainer : styles === null || styles === void 0 ? void 0 : styles.chatItemMessageContainer) || defaultChatItemMessageContainer(shouldOverlapAvatarAndMessage);
                const chatGutterStyles = message.attached === 'top' || message.attached === false ? gutterWithAvatar : gutterWithHiddenAvatar;
                return {
                    gutter: {
                        styles: chatGutterStyles,
                        content: message.mine ? '' : onRenderAvatar ? onRenderAvatar((_e = message.senderId) !== null && _e !== void 0 ? _e : '', personaOptions) : React__default['default'].createElement(react.Persona, Object.assign({}, personaOptions))
                    },
                    contentPosition: message.mine ? 'end' : 'start',
                    message: {
                        styles: chatItemMessageStyle,
                        content: React__default['default'].createElement(reactNorthstar.Flex, { hAlign: message.mine ? 'end' : undefined, vAlign: "end" },
                            chatMessageComponent,
                            React__default['default'].createElement("div", { className: react.mergeStyles(messageStatusContainerStyle((_f = message.mine) !== null && _f !== void 0 ? _f : false), (styles === null || styles === void 0 ? void 0 : styles.messageStatusContainer) ? styles.messageStatusContainer((_g = message.mine) !== null && _g !== void 0 ? _g : false) : '') }, showMessageStatus && statusToRender ? onRenderMessageStatus ? onRenderMessageStatus({
                                status: statusToRender
                            }) : defaultStatusRenderer(message, statusToRender, participantCount !== null && participantCount !== void 0 ? participantCount : 0, readCount !== null && readCount !== void 0 ? readCount : 0) : React__default['default'].createElement("div", { className: react.mergeStyles(noMessageStatusStyle) })))
                    },
                    attached: message.attached,
                    key: _messageKey
                };
            }
        case 'system':
            {
                messageProps.messageContainerStyle = styles === null || styles === void 0 ? void 0 : styles.systemMessageContainer;
                const systemMessageComponent = onRenderMessage === undefined ? React__default['default'].createElement(DefaultSystemMessage, Object.assign({}, messageProps)) : onRenderMessage(messageProps, props => React__default['default'].createElement(DefaultSystemMessage, Object.assign({}, props)));
                return {
                    children: systemMessageComponent,
                    key: _messageKey
                };
            }
        default:
            {
                // We do not handle custom type message by default, users can handle custom type by using onRenderMessage function.
                const customMessageComponent = onRenderMessage === undefined ? React__default['default'].createElement(React__default['default'].Fragment, null) : onRenderMessage(messageProps);
                return {
                    children: customMessageComponent,
                    key: _messageKey
                };
            }
    }
});
const getLastChatMessageIdWithStatus = (messages, status) => {
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.messageType === 'chat' && message.status === status && message.mine) {
            return message.messageId;
        }
    }
    return undefined;
};
/**
 * `MessageThread` allows you to easily create a component for rendering chat messages, handling scrolling behavior of new/old messages and customizing icons & controls inside the chat thread.
 * @param props - of type MessageThreadProps
 *
 * Users will need to provide at least chat messages and userId to render the `MessageThread` component.
 * Users can also customize `MessageThread` by passing in their own Avatar, `MessageStatusIndicator` icon, `JumpToNewMessageButton`, `LoadPreviousMessagesButton` and the behavior of these controls.
 *
 * `MessageThread` internally uses the `Chat` & `Chat.Message` component from `@fluentui/react-northstar`. You can checkout the details about these [two components](https://fluentsite.z22.web.core.windows.net/0.53.0/components/chat/props).
 *
 * @public
 */
const MessageThread = (props) => {
    var _a;
    const { messages: newMessages, userId, participantCount, readReceiptsBySenderId, styles, disableJumpToNewMessageButton = false, showMessageDate = false, showMessageStatus = false, numberOfChatMessagesToReload = 5, onMessageSeen, onRenderMessageStatus, onRenderAvatar, onLoadPreviousChatMessages, onRenderJumpToNewMessageButton, onRenderMessage, onUpdateMessage, onDeleteMessage, onSendMessage } = props;
    const onRenderFileDownloads = onRenderFileDownloadsTrampoline();
    const [messages, setMessages] = React.useState([]); // We need this state to wait for one tick and scroll to bottom after messages have been initialized.
    // Otherwise chatScrollDivRef.current.clientHeight is wrong if we scroll to bottom before messages are initialized.
    const [chatMessagesInitialized, setChatMessagesInitialized] = React.useState(false);
    const [isAtBottomOfScroll, setIsAtBottomOfScroll] = React.useState(true);
    const [forceUpdate, setForceUpdate] = React.useState(0); // Used to decide if should auto scroll to bottom or show "new message" button
    const [latestPreviousChatMessage, setLatestPreviousChatMessage] = React.useState(undefined);
    const [latestCurrentChatMessage, setLatestCurrentChatMessage] = React.useState(undefined);
    const [existsNewChatMessage, setExistsNewChatMessage] = React.useState(false);
    const [lastSeenChatMessage, setLastSeenChatMessage] = React.useState(undefined);
    const [lastDeliveredChatMessage, setLastDeliveredChatMessage] = React.useState(undefined);
    const [lastSendingChatMessage, setLastSendingChatMessage] = React.useState(undefined); // readCount and participantCount will only need to be updated on-fly when user hover on an indicator
    const [readCountForHoveredIndicator, setReadCountForHoveredIndicator] = React.useState(undefined);
    const isAllChatMessagesLoadedRef = React.useRef(false);
    const previousTopRef = React.useRef(-1);
    const previousHeightRef = React.useRef(-1);
    const messageIdSeenByMeRef = React.useRef('');
    const chatScrollDivRef = React.useRef(null);
    const chatThreadRef = React.useRef(null);
    const isLoadingChatMessagesRef = React.useRef(false); // When the chat thread is narrow, we perform space optimizations such as overlapping
    // the avatar on top of the chat message and moving the chat accept/reject edit buttons
    // to a new line
    const chatThreadWidth = _useContainerWidth(chatThreadRef);
    const isNarrow = chatThreadWidth ? isNarrowWidth(chatThreadWidth) : false;
    const messagesRef = React.useRef(messages);
    const setMessagesRef = (messagesWithAttachedValue) => {
        messagesRef.current = messagesWithAttachedValue;
        setMessages(messagesWithAttachedValue);
    };
    const isAtBottomOfScrollRef = React.useRef(isAtBottomOfScroll);
    const setIsAtBottomOfScrollRef = (isAtBottomOfScrollValue) => {
        isAtBottomOfScrollRef.current = isAtBottomOfScrollValue;
        setIsAtBottomOfScroll(isAtBottomOfScrollValue);
    };
    const chatMessagesInitializedRef = React.useRef(chatMessagesInitialized);
    const setChatMessagesInitializedRef = (chatMessagesInitialized) => {
        chatMessagesInitializedRef.current = chatMessagesInitialized;
        setChatMessagesInitialized(chatMessagesInitialized);
    }; // we try to only send those message status if user is scrolled to the bottom.
    const sendMessageStatusIfAtBottom = React.useCallback(() => __awaiter$q(void 0, void 0, void 0, function* () {
        if (!isAtBottomOfScrollRef.current || !document.hasFocus() || !messagesRef.current || messagesRef.current.length === 0 || !showMessageStatus) {
            return;
        }
        const messagesWithId = messagesRef.current.filter(message => {
            return message.messageType === 'chat' && !message.mine && !!message.messageId;
        });
        if (messagesWithId.length === 0) {
            return;
        }
        const lastMessage = messagesWithId[messagesWithId.length - 1];
        try {
            if (onMessageSeen && lastMessage && lastMessage.messageId && lastMessage.messageId !== messageIdSeenByMeRef.current) {
                yield onMessageSeen(lastMessage.messageId);
                messageIdSeenByMeRef.current = lastMessage.messageId;
            }
        }
        catch (e) {
            console.log('onMessageSeen Error', lastMessage, e);
        }
    }), [showMessageStatus, onMessageSeen]);
    const scrollToBottom = React.useCallback(() => {
        if (chatScrollDivRef.current) {
            chatScrollDivRef.current.scrollTop = chatScrollDivRef.current.scrollHeight;
        }
        setExistsNewChatMessage(false);
        setIsAtBottomOfScrollRef(true);
        sendMessageStatusIfAtBottom();
    }, [sendMessageStatusIfAtBottom]);
    const handleScrollToTheBottom = React.useCallback(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        const atBottom = Math.ceil(chatScrollDivRef.current.scrollTop) >= chatScrollDivRef.current.scrollHeight - chatScrollDivRef.current.clientHeight;
        if (atBottom) {
            sendMessageStatusIfAtBottom();
            if (!isAtBottomOfScrollRef.current) {
                scrollToBottom();
            }
        }
        setIsAtBottomOfScrollRef(atBottom);
    }, [scrollToBottom, sendMessageStatusIfAtBottom]); // Infinite scrolling + threadInitialize function
    const fetchNewMessageWhenAtTop = React.useCallback(() => __awaiter$q(void 0, void 0, void 0, function* () {
        if (chatScrollDivRef.current && !isLoadingChatMessagesRef.current) {
            if (onLoadPreviousChatMessages) {
                isLoadingChatMessagesRef.current = true; // Fetch message until scrollTop reach the threshold for fetching new message
                while (!isAllChatMessagesLoadedRef.current && chatScrollDivRef.current.scrollTop <= 500) {
                    isAllChatMessagesLoadedRef.current = yield onLoadPreviousChatMessages(numberOfChatMessagesToReload);
                    yield delay(200);
                }
                isLoadingChatMessagesRef.current = false;
            }
        }
    }), [numberOfChatMessagesToReload, onLoadPreviousChatMessages]);
    const handleInfiniteScroll = React.useCallback(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        fetchNewMessageWhenAtTop();
    }, [fetchNewMessageWhenAtTop]); // The below 2 of useEffects are design for fixing infinite scrolling problem
    // Scrolling element will behave differently when scrollTop = 0(it sticks at the top)
    // we need to get previousTop before it prepend contents
    // Execute order [newMessage useEffect] => get previousTop => dom update => [messages useEffect]
    React.useEffect(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        previousTopRef.current = chatScrollDivRef.current.scrollTop;
        previousHeightRef.current = chatScrollDivRef.current.scrollHeight;
    }, [newMessages]);
    React.useEffect(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        chatScrollDivRef.current.scrollTop = chatScrollDivRef.current.scrollHeight - (previousHeightRef.current - previousTopRef.current);
    }, [messages]); // Fetch more messages to make the scroll bar appear, infinity scroll is then handled in the handleScroll function.
    React.useEffect(() => {
        fetchNewMessageWhenAtTop();
    }, [fetchNewMessageWhenAtTop]);
    /**
     * One time run useEffects. Sets up listeners when component is mounted and tears down listeners when component
     * unmounts unless these function changed
     */
    React.useEffect(() => {
        window && window.addEventListener('click', sendMessageStatusIfAtBottom);
        window && window.addEventListener('focus', sendMessageStatusIfAtBottom);
        return () => {
            window && window.removeEventListener('click', sendMessageStatusIfAtBottom);
            window && window.removeEventListener('focus', sendMessageStatusIfAtBottom);
        };
    }, [sendMessageStatusIfAtBottom]);
    React.useEffect(() => {
        const chatScrollDiv = chatScrollDivRef.current;
        chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.addEventListener('scroll', handleScrollToTheBottom);
        chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.addEventListener('scroll', handleInfiniteScroll);
        return () => {
            chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.removeEventListener('scroll', handleScrollToTheBottom);
            chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.removeEventListener('scroll', handleInfiniteScroll);
        };
    }, [handleInfiniteScroll, handleScrollToTheBottom]);
    /**
     * ClientHeight controls the number of messages to render. However ClientHeight will not be initialized after the
     * first render (not sure but I guess Fluent is updating it in hook which is after render maybe?) so we need to
     * trigger a re-render until ClientHeight is initialized. This force re-render should only happen once.
     */
    const clientHeight = (_a = chatThreadRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight;
    React.useEffect(() => {
        if (clientHeight === undefined) {
            setForceUpdate(forceUpdate + 1);
            return;
        } // Only scroll to bottom if isAtBottomOfScrollRef is true
        isAtBottomOfScrollRef.current && scrollToBottom();
    }, [clientHeight, forceUpdate, scrollToBottom, chatMessagesInitialized]);
    /**
     * This needs to run to update latestPreviousChatMessage & latestCurrentChatMessage.
     * These two states are used to manipulate scrollbar
     */
    React.useEffect(() => {
        setLatestPreviousChatMessage(getLatestChatMessage(messagesRef.current));
        setLatestCurrentChatMessage(getLatestChatMessage(newMessages));
        setMessagesRef(newMessages);
        !chatMessagesInitializedRef.current && setChatMessagesInitializedRef(true);
        setLastDeliveredChatMessage(getLastChatMessageIdWithStatus(newMessages, 'delivered'));
        setLastSeenChatMessage(getLastChatMessageIdWithStatus(newMessages, 'seen'));
        setLastSendingChatMessage(getLastChatMessageIdWithStatus(newMessages, 'sending'));
    }, [newMessages]);
    /**
     * This needs to run after messages are rendererd so we can manipulate the scroll bar.
     */
    React.useEffect(() => {
        // If user just sent the latest message then we assume we can move user to bottom of scroll.
        if (isThereNewMessageNotFromCurrentUser(userId, latestPreviousChatMessage, latestCurrentChatMessage) && !isAtBottomOfScrollRef.current) {
            setExistsNewChatMessage(true);
        }
        else if (didUserSendTheLatestMessage(userId, latestPreviousChatMessage, latestCurrentChatMessage) || isAtBottomOfScrollRef.current) {
            scrollToBottom();
        } // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [messages]);
    const participantCountRef = React.useRef(participantCount);
    const readReceiptsBySenderIdRef = React.useRef(readReceiptsBySenderId);
    participantCountRef.current = participantCount;
    readReceiptsBySenderIdRef.current = readReceiptsBySenderId;
    const onActionButtonClickMemo = React.useCallback((message, setMessageReadBy) => {
        if (participantCountRef.current && participantCountRef.current - 1 > 1 && readReceiptsBySenderIdRef.current) {
            setMessageReadBy(getParticipantsWhoHaveReadMessage(message, readReceiptsBySenderIdRef.current));
        }
    }, []);
    const localeStrings = useLocale$1().strings.messageThread;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]); // To rerender the defaultChatMessageRenderer if app running across days(every new day chat time stamp need to be regenerated)
    const defaultChatMessageRenderer = React.useCallback((messageProps) => {
        if (messageProps.message.messageType === 'chat') {
            return React__default['default'].createElement(ChatMessageComponent, Object.assign({}, messageProps, { onRenderFileDownloads: onRenderFileDownloads, message: messageProps.message, userId: props.userId, remoteParticipantsCount: participantCount ? participantCount - 1 : 0, inlineAcceptRejectEditButtons: !isNarrow, onRenderAvatar: onRenderAvatar, showMessageStatus: showMessageStatus, messageStatus: messageProps.message.status, onActionButtonClick: onActionButtonClickMemo }));
        }
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }, [onRenderFileDownloads, props.userId, participantCount, isNarrow, onRenderAvatar, showMessageStatus, onActionButtonClickMemo]);
    const defaultStatusRenderer = React.useCallback((message, status, participantCount, readCount) => {
        const onToggleToolTip = (isToggled) => {
            if (isToggled && readReceiptsBySenderIdRef.current) {
                setReadCountForHoveredIndicator(getParticipantsWhoHaveReadMessage(message, readReceiptsBySenderIdRef.current).length);
            }
            else {
                setReadCountForHoveredIndicator(undefined);
            }
        };
        return React__default['default'].createElement(MessageStatusIndicator, { status: status, readCount: readCount, onToggleToolTip: onToggleToolTip, remoteParticipantsCount: participantCount ? participantCount - 1 : 0 });
    }, []);
    const messagesToDisplay = React.useMemo(() => memoizeAllMessages(memoizedMessageFn => {
        return messages.map((message, index) => {
            let key = message.messageId;
            let statusToRender = undefined;
            if (message.messageType === 'chat') {
                if (!message.messageId || message.messageId === '') {
                    key = message.clientMessageId;
                }
                if (showMessageStatus && message.mine) {
                    switch (message.messageId) {
                        case lastSeenChatMessage:
                            {
                                statusToRender = 'seen';
                                break;
                            }
                        case lastSendingChatMessage:
                            {
                                statusToRender = 'sending';
                                break;
                            }
                        case lastDeliveredChatMessage:
                            {
                                statusToRender = 'delivered';
                                break;
                            }
                    }
                }
                if (message.mine && message.status === 'failed') {
                    statusToRender = 'failed';
                }
            }
            return memoizedMessageFn(key !== null && key !== void 0 ? key : 'id_' + index, message, showMessageDate, showMessageStatus, onRenderAvatar, isNarrow, styles, onRenderMessageStatus, defaultStatusRenderer, defaultChatMessageRenderer, strings, // Temporary solution to make sure we re-render if attach attribute is changed.
            // The proper fix should be in selector.
            message.messageType === 'chat' ? message.attached : undefined, statusToRender, participantCount, readCountForHoveredIndicator, onRenderMessage, onUpdateMessage, onDeleteMessage, onSendMessage);
        });
    }), [messages, showMessageDate, showMessageStatus, onRenderAvatar, isNarrow, styles, onRenderMessageStatus, defaultStatusRenderer, defaultChatMessageRenderer, strings, participantCount, readCountForHoveredIndicator, onRenderMessage, onUpdateMessage, onDeleteMessage, onSendMessage, lastSeenChatMessage, lastSendingChatMessage, lastDeliveredChatMessage]);
    const theme = useTheme();
    const chatBody = React.useMemo(() => {
        var _a;
        return React__default['default'].createElement(reactAriaLive.LiveAnnouncer, null,
            React__default['default'].createElement(reactNorthstar.Chat, { styles: reactNorthstar.mergeStyles(chatStyle, linkStyles(theme), (_a = styles === null || styles === void 0 ? void 0 : styles.chatContainer) !== null && _a !== void 0 ? _a : {}), items: messagesToDisplay }));
    }, [theme, styles === null || styles === void 0 ? void 0 : styles.chatContainer, messagesToDisplay]);
    return React__default['default'].createElement(reactNorthstar.Ref, { innerRef: chatThreadRef },
        React__default['default'].createElement(react.Stack, { className: react.mergeStyles(messageThreadContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root), grow: true },
            existsNewChatMessage && !disableJumpToNewMessageButton && React__default['default'].createElement("div", { className: react.mergeStyles(newMessageButtonContainerStyle, styles === null || styles === void 0 ? void 0 : styles.newMessageButtonContainer) }, onRenderJumpToNewMessageButton ? onRenderJumpToNewMessageButton({
                text: strings.newMessagesIndicator,
                onClick: scrollToBottom
            }) : React__default['default'].createElement(DefaultJumpToNewMessageButton, { text: strings.newMessagesIndicator, onClick: scrollToBottom })),
            React__default['default'].createElement(reactNorthstar.Ref, { innerRef: chatScrollDivRef }, chatBody)));
};
const onRenderFileDownloadsTrampoline = (props) => {
    return undefined;
};
const linkStyles = (theme) => {
    return {
        '& a:link': {
            color: theme.palette.themePrimary
        },
        '& a:visited': {
            color: theme.palette.themeDarker
        },
        '& a:hover': {
            color: theme.palette.themeDarker
        },
        '& a:selected': {
            color: theme.palette.themeDarker
        }
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const container = () => react.mergeStyles({
    position: 'relative',
    // ensures child element's `position: absolute` is relative to this container
    display: 'contents'
});
/**
 * @private
 */
const loadingSpinnerContainer = () => react.mergeStyles({
    // Position centrally on top of content. Parent must have position: relative.
    position: 'absolute',
    top: '50%',
    bottom: '0',
    left: '50%',
    right: '0',
    transform: 'translate(-50%, -50%)'
});
/**
 * @private
 */
const loadSpinnerStyles = {
    root: {
        height: '100%' // ensure height fills container
    },
    circle: {
        maxHeight: '5rem',
        height: '50%',
        width: 'unset',
        // remove default width applied by fluent for spinners
        aspectRatio: '1 / 1',
        // make height match width to ensure a circle shape
        borderWidth: '0.25em'
    }
};
/**
 * @private
 */
const mediaContainer = (theme) => react.mergeStyles({
    position: 'relative',
    height: '100%',
    width: '100%',
    background: 'transparent',
    display: 'flex',
    '& video': {
        borderRadius: theme.effects.roundedCorner4
    }
});
/**
 * @private
 */
const invertedVideoInPipStyle = (theme) => react.mergeStyles(mediaContainer(theme), {
    // The HTMLElement returned by the headless SDK is already inverted.
    // But in picture-in-picture mode, we do not want to invert the host HTMLElement.
    // Instead, we need to target the :picture-in-picture pseudoclass.
    //
    // First reset the host HTMLElement.
    transform: 'rotateY(180deg)',
    // This doesn't work yet on latest Edge.
    // Probably just not implemented yet.
    // picture-in-picture API is not yet stable: https://www.w3.org/TR/picture-in-picture/#css-pseudo-class
    '& video:picture-in-picture': {
        transform: 'rotateY(180deg)'
    }
});

// Copyright (c) Microsoft Corporation.
/**
 * Utility component to convert an HTMLElement with a video stream into a JSX element.
 *
 * Use to convert an HTMLElement returned by headless calling API into a component that can be rendered as a {@link VideoTile}.
 *
 * @public
 */
const StreamMedia = (props) => {
    const containerEl = React.useRef(null);
    const theme = useTheme();
    const { isMirrored, videoStreamElement, styles, loadingState = 'none' } = props;
    const [pipEnabled, setPipEnabled] = React.useState(false);
    React.useEffect(() => {
        const container = containerEl.current;
        if (!container) {
            return;
        } // If videoStreamElement changes, we clear the container to make sure we don't have duplicate, and replace it with
        // the new videoStreamElement. If videoStreamElement is undefined nothing is appended and container should be empty
        // and we don't render anyting.
        container.innerHTML = '';
        setPipEnabled(false);
        if (videoStreamElement) {
            videoStreamElement.addEventListener('enterpictureinpicture', () => {
                setPipEnabled(true);
            });
            videoStreamElement.addEventListener('leavepictureinpicture', () => {
                setPipEnabled(false);
            });
            container.appendChild(videoStreamElement);
        }
        return () => {
            container.innerHTML = '';
            setPipEnabled(false);
        };
    }, [videoStreamElement]);
    return React__default['default'].createElement("div", { className: container() },
        React__default['default'].createElement("div", { "data-ui-id": "stream-media-container", className: react.mergeStyles(isMirrored && pipEnabled ? invertedVideoInPipStyle(theme) : mediaContainer(theme), styles === null || styles === void 0 ? void 0 : styles.root), ref: containerEl }),
        loadingState === 'loading' && React__default['default'].createElement("div", { className: loadingSpinnerContainer() },
            React__default['default'].createElement(react.Spinner, { "data-ui-id": "stream-media-loading-spinner", styles: loadSpinnerStyles })));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const participantItemContainerStyle = (options) => {
    return {
        paddingTop: '0.25rem',
        paddingBottom: '0.25rem',
        display: 'flex',
        maxWidth: '100%',
        minWidth: '8rem',
        cursor: options.localparticipant || !options.clickable ? 'default' : 'pointer',
        alignItems: 'center'
    };
};
/**
 * @private
 */
const menuButtonContainerStyle = {
    width: '1.5rem'
};
/**
 * @private
 */
const participantStateMaxWidth = '5rem';
/**
 * @private
 */
const participantStateStringStyles = {
    maxWidth: participantStateMaxWidth,
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    lineHeight: 'normal',
    paddingLeft: '1rem',
    marginLeft: 'auto',
    marginRight: 0
};
/**
 * @private
 */
const iconContainerStyle$1 = {
    display: 'flex',
    alignItems: 'center',
    height: '100%',
    paddingTop: '0.2rem'
};
/**
 * @private
 */
const iconStyles$2 = react.mergeStyles({
    display: 'flex',
    lineHeight: 0,
    // ensure the icon center is on the center line and not slightly above it
    alignItems: 'center'
});
/**
 * @private
 */
const meContainerStyle = {
    paddingRight: '0.5rem'
};

// Copyright (c) Microsoft Corporation.
/**
 * Component to render a calling or chat participant.
 *
 * Displays the participant's avatar, displayName and status as well as optional icons and context menu.
 *
 * @public
 */
const ParticipantItem = (props) => {
    const { userId, displayName, onRenderAvatar, menuItems, onRenderIcon, presence, styles, me, onClick, showParticipantOverflowTooltip
    /* @conditional-compile-remove(PSTN-calls) */
     } = props;
    const [itemHovered, setItemHovered] = React.useState(false);
    const [itemFocused, setItemFocused] = React.useState(false);
    const [menuHidden, setMenuHidden] = React.useState(true);
    const containerRef = React.useRef(null);
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.participantItem;
    const ids = useIdentifiers();
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const avatarOptions = {
        text: displayName,
        size: react.PersonaSize.size32,
        presence: presence,
        initialsTextColor: 'white',
        showOverflowTooltip: showParticipantOverflowTooltip
    };
    const avatar = onRenderAvatar ? onRenderAvatar(userId !== null && userId !== void 0 ? userId : '', avatarOptions) : React__default['default'].createElement(react.Persona, Object.assign({ className: react.mergeStyles({
            // Prevents persona text from being vertically truncated if a global line height is less than 1.15.
            lineHeight: '1.15rem'
        }, styles === null || styles === void 0 ? void 0 : styles.avatar) }, avatarOptions));
    const meTextStyle = React.useMemo(() => react.mergeStyles(meContainerStyle, {
        color: theme.palette.neutralTertiary
    }, styles === null || styles === void 0 ? void 0 : styles.me), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.me]);
    const contextualMenuStyle = React.useMemo(() => react.mergeStyles({
        background: theme.palette.neutralLighterAlt
    }, styles === null || styles === void 0 ? void 0 : styles.menu), [theme.palette.neutralLighterAlt, styles === null || styles === void 0 ? void 0 : styles.menu]);
    const infoContainerStyle = React.useMemo(() => react.mergeStyles(iconContainerStyle$1, {
        color: theme.palette.neutralTertiary
    }, styles === null || styles === void 0 ? void 0 : styles.iconContainer), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.iconContainer]);
    const menuButton = React.useMemo(() => React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "end", className: react.mergeStyles(menuButtonContainerStyle), title: strings.menuTitle, "data-ui-id": ids.participantItemMenuButton },
        React__default['default'].createElement(react.Icon, { iconName: itemHovered || itemFocused || !menuHidden ? 'ParticipantItemOptionsHovered' : 'ParticipantItemOptions', className: iconStyles$2 })), [strings.menuTitle, ids.participantItemMenuButton, itemHovered, itemFocused, menuHidden]);
    const onDismissMenu = () => {
        setItemHovered(false);
        setItemFocused(false);
        setMenuHidden(true);
    };
    const participantStateString = participantStateStringTrampoline$1();
    return React__default['default'].createElement("div", { ref: containerRef, role: 'menuitem', "data-is-focusable": true, "data-ui-id": "participant-item", className: react.mergeStyles(participantItemContainerStyle({
            localparticipant: me,
            clickable: !!menuItems
        }), styles === null || styles === void 0 ? void 0 : styles.root), onMouseEnter: () => setItemHovered(true), onMouseLeave: () => setItemHovered(false), onFocus: () => setItemFocused(true), onBlur: () => setItemFocused(false), onClick: () => {
            {
                setItemHovered(true);
                setMenuHidden(false);
                onClick === null || onClick === void 0 ? void 0 : onClick(props);
            }
        }, tabIndex: 0 },
        React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles({
                width: `calc(100% - ${!me && participantStateString ? participantStateMaxWidth : menuButtonContainerStyle.width})`,
                alignItems: 'center'
            }) },
            avatar,
            me && React__default['default'].createElement(react.Text, { className: meTextStyle }, strings.isMeText),
            React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(infoContainerStyle) }, onRenderIcon && onRenderIcon(props))),
        !me && participantStateString ? React__default['default'].createElement(react.Text, { "data-ui-id": "participant-item-state-string", className: react.mergeStyles(participantStateStringStyles) }, participantStateString) : React__default['default'].createElement("div", null, menuItems && menuItems.length > 0 && React__default['default'].createElement(React__default['default'].Fragment, null,
            menuButton,
            React__default['default'].createElement(react.ContextualMenu, { items: menuItems, hidden: menuHidden, target: containerRef, onItemClick: onDismissMenu, onDismiss: onDismissMenu, directionalHint: react.DirectionalHint.bottomRightEdge, className: contextualMenuStyle, calloutProps: {
                    preventDismissOnEvent: _preventDismissOnEvent
                } }))));
};
const participantStateStringTrampoline$1 = (props, strings) => {
    return undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const participantListStyle$1 = react.mergeStyles({
    height: '100%',
    padding: '0.125rem'
});
/**
 * @private
 */
const participantListItemStyle = {
    root: {
        paddingLeft: '1rem',
        paddingRight: '1rem'
    }
};
/**
 * @private
 */
const iconStyles$1 = react.mergeStyles({
    display: 'flex',
    lineHeight: 0,
    alignItems: 'center'
});

// Copyright (c) Microsoft Corporation.
const onRenderParticipantDefault = (participant, strings, myUserId, onRenderAvatar, createParticipantMenuItems, styles, onParticipantClick, showParticipantOverflowTooltip) => {
    const callingParticipant = participant;
    let presence = undefined;
    if (callingParticipant) {
        if (callingParticipant.state === 'Connected') {
            presence = react.PersonaPresence.online;
        }
        else if (callingParticipant.state === 'Idle') {
            presence = react.PersonaPresence.away;
        }
    }
    const menuItems = createParticipantMenuItems && createParticipantMenuItems(participant);
    const onRenderIcon = (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.isScreenSharing) || (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.isMuted) ? () => React__default['default'].createElement(react.Stack, { horizontal: true, tokens: {
            childrenGap: '0.5rem'
        } },
        callingParticipant.isScreenSharing && React__default['default'].createElement(react.Icon, { iconName: "ParticipantItemScreenShareStart", className: iconStyles$1, ariaLabel: strings.sharingIconLabel }),
        callingParticipant.isMuted && React__default['default'].createElement(react.Icon, { iconName: "ParticipantItemMicOff", className: iconStyles$1, ariaLabel: strings.mutedIconLabel })) : () => null;
    const displayName = !participant.displayName ? strings.displayNamePlaceholder : participant.displayName;
    return React__default['default'].createElement(ParticipantItem, { styles: styles, key: participant.userId, userId: participant.userId, displayName: displayName, me: myUserId ? participant.userId === myUserId : false, menuItems: menuItems, presence: presence, onRenderIcon: onRenderIcon, onRenderAvatar: onRenderAvatar, onClick: () => onParticipantClick === null || onParticipantClick === void 0 ? void 0 : onParticipantClick(participant), showParticipantOverflowTooltip: showParticipantOverflowTooltip });
};
const getParticipantsForDefaultRender = (participants, excludeMe, myUserId) => {
    if (!excludeMe || !myUserId) {
        return [...participants];
    }
    const userIndex = participants.map(p => p.userId).indexOf(myUserId);
    if (userIndex === -1) {
        return [...participants];
    }
    const remoteParticipants = [...participants];
    remoteParticipants.splice(userIndex, 1);
    return remoteParticipants;
};
/**
 * Component to render all calling or chat participants.
 *
 * By default, each participant is rendered with {@link ParticipantItem}. See {@link ParticipantListProps.onRenderParticipant} to override.
 *
 * @public
 */
const ParticipantList = (props) => {
    var _a, _b, _c, _d;
    const { excludeMe = false, myUserId, participants, onRemoveParticipant, onRenderAvatar, onRenderParticipant, onFetchParticipantMenuItems, showParticipantOverflowTooltip } = props;
    const ids = useIdentifiers();
    const strings = useLocale$1().strings.participantItem;
    const displayedParticipants = React.useMemo(() => {
        return onRenderParticipant ? participants : getParticipantsForDefaultRender(participants, excludeMe, myUserId);
    }, [participants, excludeMe, myUserId, onRenderParticipant]);
    const createParticipantMenuItems = React.useCallback((participant) => {
        var _a, _b;
        let menuItems = [];
        let participantIsRemovable = participant.isRemovable;
        if (participant.userId !== myUserId && onRemoveParticipant && participantIsRemovable) {
            menuItems.push({
                key: 'remove',
                text: strings.removeButtonLabel,
                onClick: () => onRemoveParticipant(participant.userId),
                itemProps: {
                    styles: (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles) === null || _b === void 0 ? void 0 : _b.participantSubMenuItemsStyles
                },
                'data-ui-id': ids.participantListRemoveParticipantButton
            });
        }
        if (onFetchParticipantMenuItems) {
            menuItems = onFetchParticipantMenuItems(participant.userId, myUserId, menuItems);
        }
        return menuItems;
    }, [ids.participantListRemoveParticipantButton, myUserId, onFetchParticipantMenuItems, onRemoveParticipant, (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles) === null || _b === void 0 ? void 0 : _b.participantSubMenuItemsStyles, strings.removeButtonLabel]);
    const participantItemStyles = React.useMemo(() => { var _a; return react.merge(participantListItemStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles); }, [(_c = props.styles) === null || _c === void 0 ? void 0 : _c.participantItemStyles]);
    return React__default['default'].createElement(react.Stack, { "data-ui-id": ids.participantList, className: react.mergeStyles(participantListStyle$1, (_d = props.styles) === null || _d === void 0 ? void 0 : _d.root) }, displayedParticipants.map((participant) => onRenderParticipant ? onRenderParticipant(participant) : onRenderParticipantDefault(participant, strings, myUserId, onRenderAvatar, createParticipantMenuItems, participantItemStyles, props.onParticipantClick, showParticipantOverflowTooltip)));
};

/**
 * Calculates the participants that should be rendered based on the list of dominant
 * speakers and currently rendered participants in a call.
 * @param args - SmartDominantSpeakerParticipantsArgs
 * @returns VideoGalleryRemoteParticipant[] {@link @azure/communication-react#VideoGalleryRemoteParticipant}
 */
const smartDominantSpeakerParticipants = (args) => {
    const { participants, dominantSpeakers = [], lastVisibleParticipants = [], maxDominantSpeakers } = args; // Don't apply any logic if total number of video streams is less than max dominant speakers.
    if (participants.length <= maxDominantSpeakers) {
        return participants;
    }
    const participantsMap = participantsById(participants); // Only use the Max allowed dominant speakers that exist in participants
    const dominantSpeakerIds = Array.from(new Set(dominantSpeakers).values()).filter(id => !!participantsMap[id]).slice(0, maxDominantSpeakers);
    const lastVisibleParticipantIds = lastVisibleParticipants.map(p => p.userId);
    const newVisibleParticipantIds = lastVisibleParticipants.map(p => p.userId).slice(0, maxDominantSpeakers);
    const newDominantSpeakerIds = dominantSpeakerIds.filter(id => !newVisibleParticipantIds.includes(id)); // Remove participants that are no longer dominant and replace them with new dominant speakers.
    for (let index = 0; index < maxDominantSpeakers; index++) {
        const newVisibleParticipantId = newVisibleParticipantIds[index];
        if (newVisibleParticipantId === undefined || !dominantSpeakerIds.includes(newVisibleParticipantId)) {
            const replacement = newDominantSpeakerIds.shift();
            if (!replacement) {
                break;
            }
            newVisibleParticipantIds[index] = replacement;
        }
    }
    const removedVisibleParticipantIds = lastVisibleParticipantIds.filter(p => !newVisibleParticipantIds.includes(p));
    removedVisibleParticipantIds.forEach(p => newVisibleParticipantIds.push(p));
    const newVisibleParticipantIdSet = new Set(newVisibleParticipantIds);
    const leftoverParticipants = participants.filter(p => !newVisibleParticipantIdSet.has(p.userId));
    leftoverParticipants.forEach(p => {
        newVisibleParticipantIds.push(p.userId);
    }); // newVisibleParticipantIds can contain identifiers for participants that are no longer in the call. So we ignore those IDs.
    const newVisibleParticipants = newVisibleParticipantIds.map(participantId => participantsMap[participantId]).filter(p => !!p);
    return newVisibleParticipants;
};
const participantsById = (participants) => {
    const response = {};
    participants.forEach(p => response[p.userId] = p);
    return response;
};

// Copyright (c) Microsoft Corporation.
/**
 * Helper hook to maintain the video stream lifecycle. This calls onCreateStreamView and onDisposeStreamView
 * appropriately based on react lifecycle events and prop changes.
 *
 * @remarks
 *
 * Notes on handling changes to scaling mode:
 *
 * Ideally we have access to the original StreamRenderView and can call view.updateScalingMode() and do not need to recreate the stream view.
 * However, to support backwards compat we cannot guarantee this. If we don't have access to the original StreamRenderView we need to dispose
 * the old view and create a new one.
 *
 * Supporting both of these scenarios became too complex and fragile. When we introduce a breaking change this should be update to ensure that
 * onCreateStreamView _must_ return a view object with updateScalingMode and update logic in this hook to call view.updateScalingMode instead
 * of recreating the stream.
 *
 * @private
 */
const useVideoStreamLifecycleMaintainer = (props) => {
    const { isMirrored, isScreenSharingOn, isStreamAvailable, onCreateStreamView, onDisposeStreamView, renderElementExists, scalingMode } = props;
    React.useEffect(() => {
        if (isStreamAvailable && !renderElementExists) {
            onCreateStreamView === null || onCreateStreamView === void 0 ? void 0 : onCreateStreamView({
                isMirrored,
                scalingMode
            });
        } // Always clean up element to make tile up to date and be able to dispose correctly
        return () => {
            if (renderElementExists) {
                // TODO: Remove `if isScreenSharingOn` when we isolate dispose behavior for screen share
                if (!isScreenSharingOn) {
                    onDisposeStreamView === null || onDisposeStreamView === void 0 ? void 0 : onDisposeStreamView();
                }
            }
        };
    }, [isMirrored, isScreenSharingOn, isStreamAvailable, onCreateStreamView, onDisposeStreamView, renderElementExists, scalingMode]); // The execution order for above useEffect is onCreateRemoteStreamView =>(async time gap) RenderElement generated => element disposed => onDisposeRemoteStreamView
    // Element disposed could happen during async time gap, which still cause leaks for unused renderElement.
    // Need to do an entire cleanup when remoteTile gets disposed and make sure element gets correctly disposed
    React.useEffect(() => {
        return () => {
            // TODO: Remove `if isScreenSharingOn` when we isolate dispose behavior for screen share
            if (!isScreenSharingOn) {
                onDisposeStreamView === null || onDisposeStreamView === void 0 ? void 0 : onDisposeStreamView();
            }
        };
    }, [isScreenSharingOn, onDisposeStreamView]);
};
/**
 * Extension of {@link useVideoStreamLifecycleMaintainer} specifically for local video streams
 *
 * @private
 */
const useLocalVideoStreamLifecycleMaintainer = (props) => {
    const { onCreateLocalStreamView, onDisposeLocalStreamView } = props;
    const onCreateStreamView = React.useMemo(() => (options) => {
        return onCreateLocalStreamView === null || onCreateLocalStreamView === void 0 ? void 0 : onCreateLocalStreamView(options);
    }, [onCreateLocalStreamView]);
    const onDisposeStreamView = React.useMemo(() => () => {
        onDisposeLocalStreamView === null || onDisposeLocalStreamView === void 0 ? void 0 : onDisposeLocalStreamView();
    }, [onDisposeLocalStreamView]);
    return useVideoStreamLifecycleMaintainer(Object.assign(Object.assign({}, props), { onCreateStreamView,
        onDisposeStreamView }));
};
/**
 * Extension of {@link useVideoStreamLifecycleMaintainer} specifically for remote video streams
 *
 * @private
 */
const useRemoteVideoStreamLifecycleMaintainer = (props) => {
    const { remoteParticipantId, onCreateRemoteStreamView, onDisposeRemoteStreamView } = props;
    const onCreateStreamView = React.useMemo(() => (options) => {
        return onCreateRemoteStreamView === null || onCreateRemoteStreamView === void 0 ? void 0 : onCreateRemoteStreamView(remoteParticipantId, options);
    }, [onCreateRemoteStreamView, remoteParticipantId]);
    const onDisposeStreamView = React.useMemo(() => () => {
        onDisposeRemoteStreamView === null || onDisposeRemoteStreamView === void 0 ? void 0 : onDisposeRemoteStreamView(remoteParticipantId);
    }, [onDisposeRemoteStreamView, remoteParticipantId]);
    return useVideoStreamLifecycleMaintainer(Object.assign(Object.assign({}, props), { onCreateStreamView,
        onDisposeStreamView }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const rootStyles = {
    position: 'relative',
    height: '100%',
    width: '100%'
};
/**
 * @private
 */
const videoContainerStyles = {
    position: 'absolute',
    top: '0',
    left: '0',
    width: '100%',
    height: '100%',
    minWidth: '100%',
    minHeight: '100%',
    objectPosition: 'center',
    objectFit: 'cover',
    zIndex: 0
};
/**
 * @private
 */
const overlayContainerStyles = {
    width: '100%',
    height: '100%',
    zIndex: 5
};
/**
 * @private
 */
const tileInfoContainerStyle = react.mergeStyles({
    position: 'absolute',
    bottom: '0',
    left: '0',
    padding: '0.5rem',
    width: '100%'
});
/**
 * @private
 */
const disabledVideoHint = react.mergeStyles({
    backgroundColor: 'inherit',
    boxShadow: 'none',
    textAlign: 'left',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    alignItems: 'center',
    padding: '0.15rem',
    maxWidth: '100%'
});
/**
 * @private
 */
const videoHint = react.mergeStyles(disabledVideoHint, {
    // This will appear on top of the video stream, so no dependency on theme and explicitly use a translucent white
    backgroundColor: 'rgba(255,255,255,0.8)'
});
/**
 * @private
 */
const displayNameStyle = {
    padding: '0.1rem',
    fontSize: '0.75rem',
    fontWeight: 600,
    // Text component will take body color by default (white in Dark Mode), so forcing it to be parent container color
    color: 'inherit',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    maxWidth: '100%'
};
/**
 * @private
 */
const iconContainerStyle = {
    margin: 'auto',
    alignItems: 'center',
    '& svg': {
        display: 'block',
        // Similar to text color, icon color will be inherited from parent container
        color: 'inherit'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const getVideoTileOverrideColor = (isVideoRendered, theme, color) => {
    // when video is being rendered, the info has a grey-ish background, so no use of theme
    return {
        color: isVideoRendered ? react.DefaultPalette[color] : theme.palette[color]
    };
};

// Copyright (c) Microsoft Corporation.
const DEFAULT_PERSONA_MAX_SIZE_PX = 100; // Coin min size is set PersonaSize.size32
const DEFAULT_PERSONA_MIN_SIZE_PX = 32;
const DefaultPlaceholder = (props) => {
    const { text, noVideoAvailableAriaLabel, coinSize, hidePersonaDetails } = props;
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles({
            position: 'absolute',
            height: '100%',
            width: '100%'
        }) },
        React__default['default'].createElement(react.Stack, { styles: defaultPersonaStyles },
            React__default['default'].createElement(react.Persona, { coinSize: coinSize, hidePersonaDetails: hidePersonaDetails, text: text !== null && text !== void 0 ? text : '', initialsTextColor: "white", "aria-label": noVideoAvailableAriaLabel !== null && noVideoAvailableAriaLabel !== void 0 ? noVideoAvailableAriaLabel : '', showOverflowTooltip: false })));
};
const defaultPersonaStyles = {
    root: {
        margin: 'auto',
        maxHeight: '100%'
    }
};
/**
 * A component to render the video stream for a single call participant.
 *
 * Use with {@link GridLayout} in a {@link VideoGallery}.
 *
 * @public
 */
const VideoTile = (props) => {
    const { children, displayName, initialsName, isMirrored, isMuted, onRenderPlaceholder, renderElement, showLabel = true, showMuteIndicator = true, styles, userId, noVideoAvailableAriaLabel, isSpeaking, personaMinSize = DEFAULT_PERSONA_MIN_SIZE_PX, personaMaxSize = DEFAULT_PERSONA_MAX_SIZE_PX } = props;
    const [personaSize, setPersonaSize] = React.useState(100);
    const videoTileRef = React.useRef(null);
    useLocale$1();
    const theme = useTheme();
    const isVideoRendered = !!renderElement;
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        const personaSize = Math.min(width, height) / 3;
        setPersonaSize(Math.max(Math.min(personaSize, personaMaxSize), personaMinSize));
    }));
    React.useLayoutEffect(() => {
        if (videoTileRef.current) {
            observer.current.observe(videoTileRef.current);
        }
        const currentObserver = observer.current;
        return () => currentObserver.disconnect();
    }, [observer, videoTileRef]);
    const placeholderOptions = {
        userId,
        text: initialsName || displayName,
        noVideoAvailableAriaLabel,
        coinSize: personaSize,
        styles: defaultPersonaStyles,
        hidePersonaDetails: true
    };
    const videoHintWithBorderRadius = react.mergeStyles(videoHint, {
        borderRadius: theme.effects.roundedCorner4
    });
    const tileInfoStyle = React.useMemo(() => react.mergeStyles(isVideoRendered ? videoHintWithBorderRadius : disabledVideoHint, getVideoTileOverrideColor(isVideoRendered, theme, 'neutralPrimary'), styles === null || styles === void 0 ? void 0 : styles.displayNameContainer), [isVideoRendered, videoHintWithBorderRadius, theme, styles === null || styles === void 0 ? void 0 : styles.displayNameContainer]);
    const ids = useIdentifiers();
    const canShowLabel = showLabel && (displayName || showMuteIndicator && isMuted);
    const participantStateString = participantStateStringTrampoline();
    return React__default['default'].createElement(reactNorthstar.Ref, { innerRef: videoTileRef },
        React__default['default'].createElement(react.Stack, { "data-ui-id": ids.videoTile, className: react.mergeStyles(rootStyles, {
                background: theme.palette.neutralLighter,
                borderRadius: theme.effects.roundedCorner4
            }, isSpeaking && {
                '&::before': {
                    content: `''`,
                    position: 'absolute',
                    zIndex: 1,
                    border: `0.25rem solid ${theme.palette.themePrimary}`,
                    borderRadius: theme.effects.roundedCorner4,
                    width: '100%',
                    height: '100%'
                }
            }, styles === null || styles === void 0 ? void 0 : styles.root) },
            isVideoRendered ? React__default['default'].createElement(react.Stack, { className: react.mergeStyles(videoContainerStyles, isMirrored && {
                    transform: 'scaleX(-1)'
                }, styles === null || styles === void 0 ? void 0 : styles.videoContainer) }, renderElement) : React__default['default'].createElement(react.Stack, { className: react.mergeStyles(videoContainerStyles), style: {
                    opacity: 1
                } }, onRenderPlaceholder ? onRenderPlaceholder(userId !== null && userId !== void 0 ? userId : '', placeholderOptions, DefaultPlaceholder) : React__default['default'].createElement(DefaultPlaceholder, Object.assign({}, placeholderOptions))),
            (canShowLabel || participantStateString) && React__default['default'].createElement(react.Stack, { horizontal: true, className: tileInfoContainerStyle, tokens: tileInfoContainerTokens },
                React__default['default'].createElement(react.Stack, { horizontal: true, className: tileInfoStyle },
                    canShowLabel && React__default['default'].createElement(react.Text, { className: react.mergeStyles(displayNameStyle), title: displayName, style: {
                            color: 'inherit'
                        } }, displayName),
                    participantStateString ,
                    showMuteIndicator && isMuted && React__default['default'].createElement(react.Stack, { className: react.mergeStyles(iconContainerStyle) },
                        React__default['default'].createElement(react.Icon, { iconName: "VideoTileMicOff" })))),
            children && React__default['default'].createElement(react.Stack, { className: react.mergeStyles(overlayContainerStyles, styles === null || styles === void 0 ? void 0 : styles.overlayContainer) }, children)));
};
const participantStateStringTrampoline = (props, locale) => {
    return undefined;
};
const tileInfoContainerTokens = {
    // A horizontal Stack sets the left margin to 0 for all it's children.
    // We need to allow the children to set their own margins
    childrenGap: 'none'
};

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of VideoTile for rendering remote participants. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering a VideoTile when its position in the
 * array changes causing a rerender in the parent component. https://reactjs.org/docs/react-api.html#reactmemo
 *
 * @internal
 */
const _RemoteVideoTile = React__default['default'].memo((props) => {
    const { isAvailable, isReceiving = true, 
    // default to true to prevent any breaking change
    isMuted, isSpeaking, isScreenSharingOn, onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions, renderElement, userId, displayName, onRenderAvatar, showMuteIndicator } = props;
    const remoteVideoStreamProps = React.useMemo(() => ({
        isMirrored: remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.isMirrored,
        isScreenSharingOn,
        isStreamAvailable: isAvailable,
        isStreamReceiving: isReceiving,
        onCreateRemoteStreamView,
        onDisposeRemoteStreamView,
        remoteParticipantId: userId,
        renderElementExists: !!renderElement,
        scalingMode: remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.scalingMode
    }), [isAvailable, isReceiving, isScreenSharingOn, onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.isMirrored, remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.scalingMode, renderElement, userId]); // Handle creating, destroying and updating the video stream as necessary
    useRemoteVideoStreamLifecycleMaintainer(remoteVideoStreamProps);
    const showLoadingIndicator = isAvailable && isReceiving === false && props.participantState !== 'Disconnected';
    const renderVideoStreamElement = React.useMemo(() => {
        // Checking if renderElement is well defined or not as calling SDK has a number of video streams limitation which
        // implies that, after their threshold, all streams have no child (blank video)
        if (!renderElement || !renderElement.childElementCount) {
            // Returning `undefined` results in the placeholder with avatar being shown
            return undefined;
        }
        return React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement, loadingState: showLoadingIndicator ? 'loading' : 'none' });
    }, [renderElement, showLoadingIndicator]);
    return React__default['default'].createElement(VideoTile, { key: userId, userId: userId, renderElement: renderVideoStreamElement, displayName: displayName, onRenderPlaceholder: onRenderAvatar, isMuted: isMuted, isSpeaking: isSpeaking, showMuteIndicator: showMuteIndicator, personaMinSize: props.personaMinSize, showLabel: props.showLabel });
});

/**
 * Horizontal Gallery button width in rem
 */
const HORIZONTAL_GALLERY_BUTTON_WIDTH = 1.75;
/**
 * @private
 */
const leftRightButtonStyles = (theme) => {
    return {
        background: 'none',
        padding: 0,
        height: 'auto',
        minWidth: `${HORIZONTAL_GALLERY_BUTTON_WIDTH}rem`,
        maxWidth: `${HORIZONTAL_GALLERY_BUTTON_WIDTH}rem`,
        border: `1px solid ${theme.palette.neutralLight}`,
        borderRadius: theme.effects.roundedCorner4
    };
};
/**
 * Horizontal Gallery gap size in rem between tiles and buttons
 */
const HORIZONTAL_GALLERY_GAP = 0.5;
/**
 * @private
 */
const rootStyle = {
    height: '100%',
    width: '100%',
    gap: `${HORIZONTAL_GALLERY_GAP}rem`
};
/**
 * @private
 */
const childrenContainerStyle = {
    height: '100%',
    gap: `${HORIZONTAL_GALLERY_GAP}rem`
};

// Copyright (c) Microsoft Corporation.
/**
 * {@link HorizontalGallery} default children per page
 */
const DEFAULT_CHILDREN_PER_PAGE = 5;
/**
 * Renders a horizontal gallery that parents children horizontally. Handles pagination based on the childrenPerPage prop.
 * @param props - HorizontalGalleryProps {@link @azure/communication-react#HorizontalGalleryProps}
 * @returns
 */
const HorizontalGallery = (props) => {
    var _a, _b;
    const { children, childrenPerPage = DEFAULT_CHILDREN_PER_PAGE, styles } = props;
    const ids = useIdentifiers();
    const [page, setPage] = React.useState(0);
    const numberOfChildren = React__default['default'].Children.count(children);
    const lastPage = Math.ceil(numberOfChildren / childrenPerPage) - 1;
    const paginatedChildren = React.useMemo(() => {
        return bucketize(React__default['default'].Children.toArray(children), childrenPerPage);
    }, [children, childrenPerPage]); // If children per page is 0 or less return empty element
    if (childrenPerPage <= 0) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    const firstIndexOfCurrentPage = page * childrenPerPage;
    const clippedPage = firstIndexOfCurrentPage < numberOfChildren - 1 ? page : lastPage;
    const childrenOnCurrentPage = paginatedChildren[clippedPage];
    const showButtons = numberOfChildren > childrenPerPage;
    const disablePreviousButton = page === 0;
    const disableNextButton = page === lastPage;
    return React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(rootStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root) },
        showButtons && React__default['default'].createElement(HorizontalGalleryNavigationButton, { key: "previous-nav-button", icon: React__default['default'].createElement(react.Icon, { iconName: "HorizontalGalleryLeftButton" }), styles: styles === null || styles === void 0 ? void 0 : styles.previousButton, onClick: () => setPage(Math.max(0, Math.min(lastPage, page - 1))), disabled: disablePreviousButton, identifier: ids.horizontalGalleryLeftNavButton }),
        React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(childrenContainerStyle, {
                '> *': (_b = props.styles) === null || _b === void 0 ? void 0 : _b.children
            }) }, childrenOnCurrentPage),
        showButtons && React__default['default'].createElement(HorizontalGalleryNavigationButton, { key: "next-nav-button", icon: React__default['default'].createElement(react.Icon, { iconName: "HorizontalGalleryRightButton" }), styles: styles === null || styles === void 0 ? void 0 : styles.nextButton, onClick: () => setPage(Math.min(lastPage, page + 1)), disabled: disableNextButton, identifier: ids.horizontalGalleryRightNavButton }));
};
const HorizontalGalleryNavigationButton = (props) => {
    const theme = useTheme();
    return React__default['default'].createElement(react.DefaultButton, { className: react.mergeStyles(leftRightButtonStyles(theme), props.styles), onClick: props.onClick, disabled: props.disabled, "data-ui-id": props.identifier }, props.icon);
};
function bucketize(arr, bucketSize) {
    const bucketArray = [];
    if (bucketSize <= 0) {
        return bucketArray;
    }
    for (let i = 0; i < arr.length; i += bucketSize) {
        bucketArray.push(arr.slice(i, i + bucketSize));
    }
    return bucketArray;
}

// Copyright (c) Microsoft Corporation.
/**
 * Wrapped HorizontalGallery that adjusts the number of items per page based on the
 * available width obtained from a ResizeObserver, width per child, gap width, and button width
 */
const ResponsiveHorizontalGallery = (props) => {
    const { childWidthRem, gapWidthRem, buttonWidthRem = 0 } = props;
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const leftPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingLeft) : 0;
    const rightPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingRight) : 0;
    const childrenPerPage = calculateChildrenPerPage({
        numberOfChildren: React__default['default'].Children.count(props.children),
        containerWidth: (containerWidth !== null && containerWidth !== void 0 ? containerWidth : 0) - leftPadding - rightPadding,
        childWidthRem,
        gapWidthRem,
        buttonWidthRem
    });
    return React__default['default'].createElement("div", { ref: containerRef, className: react.mergeStyles(props.containerStyles) },
        React__default['default'].createElement(HorizontalGallery, { childrenPerPage: childrenPerPage, styles: props.horizontalGalleryStyles }, props.children));
};
/**
 * Helper function to calculate children per page for HorizontalGallery based on width of container, child, buttons, and
 * gaps in between
 */
const calculateChildrenPerPage = (args) => {
    const { numberOfChildren, containerWidth, buttonWidthRem, childWidthRem, gapWidthRem } = args;
    const childWidth = _convertRemToPx(childWidthRem);
    const gapWidth = _convertRemToPx(gapWidthRem);
    /** First check how many children can fit in containerWidth.
     *    __________________________________
     *   |                ||                |
     *   |                ||                |
     *   |________________||________________|
     *   <-----------containerWidth--------->
     *  containerWidth = n * childWidth + (n - 1) * gapWidth. Isolate n and take the floor.
     */
    const numberOfChildrenInContainer = Math.floor((containerWidth + gapWidth) / (childWidth + gapWidth)); // If all children fit then return numberOfChildrenInContainer
    if (numberOfChildren <= numberOfChildrenInContainer) {
        return numberOfChildrenInContainer;
    }
    const buttonWidth = _convertRemToPx(buttonWidthRem);
    /** We know we need to paginate. So we need to subtract the buttonWidth twice and gapWidth twice from
     * containerWidth to compute childrenSpace
     *   <-----------containerWidth--------->
     *    __________________________________
     *   | ||             ||             || |
     *   |<||             ||             ||>|
     *   |_||_____________||_____________||_|
     *       <-------childrenSpace------>
     */
    const childrenSpace = containerWidth - 2 * buttonWidth - 2 * gapWidth; // Now that we have childrenSpace width we can figure out how many children can fit in childrenSpace.
    // childrenSpace = n * childWidth + (n - 1) * gapWidth. Isolate n and take the floor.
    return Math.floor((childrenSpace + gapWidth) / (childWidth + gapWidth));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const videoGalleryOuterDivStyle = react.mergeStyles({
    position: 'relative',
    width: '100%',
    height: '100%'
});
/**
 * @private
 */
const videoGalleryContainerStyle = {
    root: {
        position: 'relative',
        height: '100%',
        width: '100%',
        padding: '0.5rem'
    }
};
/**
 * Small floating modal width and height in rem for small screen
 */
const SMALL_FLOATING_MODAL_SIZE_PX = {
    width: 64,
    height: 88
};
/**
 * Large floating modal width and height in rem for large screen
 */
const LARGE_FLOATING_MODAL_SIZE_PX = {
    width: 160,
    height: 120
};
/**
 * @private
 * z-index to ensure that the local video tile is above the video gallery.
 */
const LOCAL_VIDEO_TILE_ZINDEX = 2;
/**
 * @private
 */
const floatingLocalVideoModalStyle = (theme, isNarrow) => {
    return react.concatStyleSets({
        main: localVideoTileContainerStyle(theme, isNarrow)
    }, {
        main: {
            boxShadow: theme.effects.elevation8,
            ':focus-within': {
                boxShadow: theme.effects.elevation16,
                border: `${_pxToRem(2)} solid ${theme.palette.neutralPrimary}`
            }
        }
    }, localVideoModalStyles);
};
/**
 * Padding equal to the amount the modal should stay inside the bounds of the container.
 * i.e. if this is 8px, the modal should always be at least 8px inside the container at all times on all sides.
 * @private
 */
const localVideoTileOuterPaddingPX = 8;
/**
 * @private
 */
const localVideoTileContainerStyle = (theme, isNarrow) => {
    return Object.assign({ minWidth: isNarrow ? _pxToRem(SMALL_FLOATING_MODAL_SIZE_PX.width) : _pxToRem(LARGE_FLOATING_MODAL_SIZE_PX.width), minHeight: isNarrow ? _pxToRem(SMALL_FLOATING_MODAL_SIZE_PX.height) : _pxToRem(LARGE_FLOATING_MODAL_SIZE_PX.height), position: 'absolute', bottom: _pxToRem(localVideoTileOuterPaddingPX), borderRadius: theme.effects.roundedCorner4, overflow: 'hidden' }, (theme.rtl ? {
        left: _pxToRem(localVideoTileOuterPaddingPX)
    } : {
        right: _pxToRem(localVideoTileOuterPaddingPX)
    }));
};
/**
 * @private
 */
const localVideoTileWithControlsContainerStyle = (theme, isNarrow) => {
    return react.concatStyleSets(localVideoTileContainerStyle(theme, isNarrow), {
        root: {
            boxShadow: theme.effects.elevation8
        }
    });
};
/**
 * @private
 */
const floatingLocalVideoTileStyle = {
    root: {
        position: 'absolute',
        zIndex: LOCAL_VIDEO_TILE_ZINDEX,
        height: '100%',
        width: '100%'
    }
};
/**
 * @private
 */
const horizontalGalleryContainerStyle = (shouldFloatLocalVideo, isNarrow) => {
    return {
        minHeight: isNarrow ? `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem` : `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
        width: shouldFloatLocalVideo ? isNarrow ? `calc(100% - ${_pxToRem(SMALL_FLOATING_MODAL_SIZE_PX.width)})` : `calc(100% - ${_pxToRem(LARGE_FLOATING_MODAL_SIZE_PX.width)})` : '100%',
        paddingRight: '0.5rem'
    };
};
/**
 * @private
 */
const horizontalGalleryStyle = (isNarrow) => {
    return {
        children: isNarrow ? SMALL_HORIZONTAL_GALLERY_TILE_STYLE : LARGE_HORIZONTAL_GALLERY_TILE_STYLE
    };
};
/**
 * Small horizontal gallery tile size in rem
 * @private
 */
const SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM = {
    height: 5.5,
    width: 5.5
};
/**
 * Large horizontal gallery tile size in rem
 * @private
 */
const LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM = {
    height: 7.5,
    width: 10
};
/**
 * @private
 */
const SMALL_HORIZONTAL_GALLERY_TILE_STYLE = {
    minHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    minWidth: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`,
    maxHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    maxWidth: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`
};
/**
 * @private
 */
const LARGE_HORIZONTAL_GALLERY_TILE_STYLE = {
    minHeight: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    minWidth: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`,
    maxHeight: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    maxWidth: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`
};
/**
 * @private
 */
const layerHostStyle = {
    position: 'absolute',
    left: 0,
    top: 0,
    width: '100%',
    height: '100%',
    overflow: 'hidden',
    // pointer events for layerHost set to none to make descendants interactive
    pointerEvents: 'none'
};
/**
 * @private
 */
const localVideoCameraCycleButtonStyles = (theme) => {
    return {
        root: {
            position: 'absolute',
            width: _pxToRem(32),
            height: _pxToRem(32),
            right: '0rem',
            top: '0rem',
            color: '#FFFFFF',
            // only shows up on running video feed to we want to force specific colours.
            zIndex: 2,
            // shows the button directly over the local video feed.
            background: 'rgba(0,0,0,0.4)',
            borderRadius: theme.effects.roundedCorner2
        },
        rootFocused: {
            // styles to remove the unwanted white highlight and blue colour after tapping on button.
            color: '#FFFFFF',
            background: 'rgba(0,0,0,0.4)' // sets opacity of background to be visible on all backdrops in video stream.
        },
        icon: {
            paddingLeft: _pxToRem(3),
            paddingRight: _pxToRem(3),
            margin: 0
        },
        flexContainer: {
            paddingBottom: _pxToRem(8)
        }
    };
};
/**
 * Styles for the local video tile modal when it is focused, will cause keyboard move icon to appear over video
 * @private
 */
const localVideoModalStyles = {
    keyboardMoveIconContainer: {
        zIndex: LOCAL_VIDEO_TILE_ZINDEX + 1 // zIndex to set the keyboard movement Icon above the other layers in the video tile.
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const screenSharingContainerStyle = react.mergeStyles({
    width: '100%',
    height: '100%'
});
/**
 * @private
 */
const screenSharingNotificationContainerStyle = (theme) => react.mergeStyles({
    backgroundColor: 'inherit',
    padding: '1rem',
    maxWidth: '95%',
    borderRadius: theme.effects.roundedCorner4,
    color: theme.palette.neutralSecondary
});
/**
 * @private
 */
const screenSharingNotificationIconContainerStyle = react.mergeStyles({
    height: '2rem',
    lineHeight: 0
});
/**
 * @private
 */
const screenSharingNotificationIconStyle = (theme) => react.mergeStyles({
    // svg is (20px x 20px) but path is only (16px x 12px), so need to scale at 2.5 to get 40px
    transform: 'scale(2.5)',
    color: theme.palette.neutralTertiary
});
/**
 * @private
 */
const screenSharingNotificationTextStyle = react.mergeStyles({
    fontSize: '1rem',
    // Text component will take body color by default (white in Dark Mode), so forcing it to be parent container color
    color: 'inherit'
});

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of local screen share component. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering this when the parent component rerenders.
 * https://reactjs.org/docs/react-api.html#reactmemo
 */
const LocalScreenShare = React__default['default'].memo((props) => {
    const { localParticipant } = props;
    const theme = useTheme();
    const locale = useLocale$1();
    if (!localParticipant || !localParticipant.isScreenSharingOn) {
        return null;
    }
    const localScreenSharingNotification = React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: screenSharingContainerStyle },
        React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: screenSharingNotificationContainerStyle(theme), tokens: {
                childrenGap: '1rem'
            } },
            React__default['default'].createElement(react.Stack, { horizontal: true, verticalAlign: "center", className: screenSharingNotificationIconContainerStyle },
                React__default['default'].createElement(react.Icon, { iconName: "ControlButtonScreenShareStart", className: screenSharingNotificationIconStyle(theme) })),
            React__default['default'].createElement(react.Text, { className: screenSharingNotificationTextStyle, "aria-live": "polite" }, locale.strings.videoGallery.screenIsBeingSharedMessage)));
    const displayName = !(localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.displayName) ? locale.strings.videoGallery.displayNamePlaceholder : localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.displayName;
    return React__default['default'].createElement(VideoTile, { displayName: displayName, isMuted: localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isMuted, onRenderPlaceholder: () => React__default['default'].createElement(React__default['default'].Fragment, null) }, localScreenSharingNotification);
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const loadingStyle = react.mergeStyles({
    height: '100%',
    width: '100%'
});

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of VideoTile for rendering the remote screen share stream. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering this when the parent component rerenders.
 * https://reactjs.org/docs/react-api.html#reactmemo
 */
const RemoteScreenShare = React__default['default'].memo((props) => {
    const { userId, displayName, isMuted, renderElement, onCreateRemoteStreamView, onDisposeRemoteStreamView, isReceiving } = props;
    const locale = useLocale$1();
    if (!renderElement) {
        onCreateRemoteStreamView && onCreateRemoteStreamView(userId);
    }
    React.useEffect(() => {
        return () => {
            // TODO: Isolate disposing behaviors for screenShare and videoStream
            onDisposeRemoteStreamView && onDisposeRemoteStreamView(userId);
        };
    }, [onDisposeRemoteStreamView, userId]);
    const loadingMessage = displayName ? _formatString(locale.strings.videoGallery.screenShareLoadingMessage, {
        participant: displayName
    }) : '';
    return React__default['default'].createElement(VideoTile, { displayName: displayName, isMuted: isMuted, renderElement: renderElement ? React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement, loadingState: isReceiving === false ? 'loading' : 'none' }) : undefined, onRenderPlaceholder: () => React__default['default'].createElement(LoadingSpinner, { loadingMessage: loadingMessage }) });
});
const LoadingSpinner = (props) => {
    return React__default['default'].createElement(react.Stack, { verticalAlign: "center", className: loadingStyle },
        React__default['default'].createElement(react.Spinner, { label: props.loadingMessage, size: react.SpinnerSize.xSmall, "aria-live": 'assertive' }));
};

// Copyright (c) Microsoft Corporation.
const animationDuration = react.AnimationVariables.durationValue2;
const ZERO = {
    x: 0,
    y: 0
};
const DEFAULT_PROPS = {
    isOpen: false,
    isDarkOverlay: true,
    className: '',
    containerClassName: '',
    enableAriaHiddenSiblings: true
};
const getModalClassNames = react.classNamesFunction();
const getMoveDelta = (ev) => {
    let delta = 10;
    if (ev.shiftKey) {
        if (!ev.ctrlKey) {
            delta = 50;
        }
    }
    else if (ev.ctrlKey) {
        delta = 1;
    }
    return delta;
};
const useComponentRef = (props, focusTrapZone) => {
    React__namespace.useImperativeHandle(props.componentRef, () => ({
        focus() {
            if (focusTrapZone.current) {
                focusTrapZone.current.focus();
            }
        }
    }), [focusTrapZone]);
};
const ModalBase = React__namespace.forwardRef((propsWithoutDefaults, ref) => {
    const props = react.getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
    const { allowTouchBodyScroll, className, children, containerClassName, scrollableContentClassName, elementToFocusOnDismiss, firstFocusableSelector, forceFocusInsideTrap, ignoreExternalFocusing, isBlocking, isAlert, isClickableOutsideFocusTrap, isDarkOverlay, onDismiss, layerProps, overlay, isOpen, titleAriaId, styles, subtitleAriaId, theme, topOffsetFixed, responsiveMode, onLayerDidMount, isModeless, dragOptions, onDismissed, minDragPosition, maxDragPosition } = props;
    const rootRef = React__namespace.useRef(null);
    const focusTrapZone = React__namespace.useRef(null);
    const focusTrapZoneElm = React__namespace.useRef(null);
    const mergedRef = reactHooks.useMergedRefs(rootRef, ref);
    const modalResponsiveMode = react.useResponsiveMode(mergedRef);
    const focusTrapZoneId = reactHooks.useId('ModalFocusTrapZone');
    const win = reactWindowProvider.useWindow();
    const { setTimeout, clearTimeout } = reactHooks.useSetTimeout();
    const [isModalOpen, setIsModalOpen] = React__namespace.useState(isOpen);
    const [isVisible, setIsVisible] = React__namespace.useState(isOpen);
    const [coordinates, setCoordinates] = React__namespace.useState(ZERO);
    const [modalRectangleTop, setModalRectangleTop] = React__namespace.useState();
    const [isModalMenuOpen, { toggle: toggleModalMenuOpen, setFalse: setModalMenuClose }] = reactHooks.useBoolean(false);
    const internalState = reactHooks.useConst(() => ({
        onModalCloseTimer: 0,
        allowTouchBodyScroll,
        scrollableContent: null,
        lastSetCoordinates: ZERO,
        events: new react.EventGroup({})
    }));
    const { keepInBounds } = dragOptions || {};
    const isAlertRole = isAlert !== null && isAlert !== void 0 ? isAlert : (isBlocking && !isModeless);
    const layerClassName = layerProps === undefined ? '' : layerProps.className;
    const classNames = getModalClassNames(styles, {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        theme: theme,
        className,
        containerClassName,
        scrollableContentClassName,
        isOpen,
        isVisible,
        hasBeenOpened: internalState.hasBeenOpened,
        modalRectangleTop,
        topOffsetFixed,
        isModeless,
        layerClassName,
        windowInnerHeight: win === null || win === void 0 ? void 0 : win.innerHeight,
        isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector
    });
    const mergedLayerProps = Object.assign(Object.assign({ eventBubblingEnabled: false }, layerProps), { onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount, insertFirst: isModeless, className: classNames.layer }); // Allow the user to scroll within the modal but not on the body
    const allowScrollOnModal = React__namespace.useCallback((elt) => {
        if (elt) {
            if (internalState.allowTouchBodyScroll) {
                react.allowOverscrollOnElement(elt, internalState.events);
            }
            else {
                react.allowScrollOnElement(elt, internalState.events);
            }
        }
        else {
            internalState.events.off(internalState.scrollableContent);
        }
        internalState.scrollableContent = elt;
    }, [internalState]);
    const registerInitialModalPosition = () => {
        const dialogMain = focusTrapZoneElm.current;
        const modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();
        if (modalRectangle) {
            if (topOffsetFixed) {
                setModalRectangleTop(modalRectangle.top);
            }
            if (keepInBounds) {
                // x/y are unavailable in IE, so use the equivalent left/top
                internalState.minPosition = minDragPosition !== null && minDragPosition !== void 0 ? minDragPosition : {
                    x: -modalRectangle.left,
                    y: -modalRectangle.top
                };
                internalState.maxPosition = maxDragPosition !== null && maxDragPosition !== void 0 ? maxDragPosition : {
                    x: modalRectangle.left,
                    y: modalRectangle.top
                }; // Make sure the initial co-ordinates are within clamp bounds.
                setCoordinates({
                    x: getClampedAxis('x', coordinates.x),
                    y: getClampedAxis('y', coordinates.y)
                });
            }
        }
    };
    /**
     * Clamps an axis to a specified min and max position.
     *
     * @param axis A string that represents the axis (x/y).
     * @param position The position on the axis.
     */
    const getClampedAxis = React__namespace.useCallback((axis, position) => {
        const { minPosition, maxPosition } = internalState;
        if (keepInBounds && minPosition && maxPosition) {
            position = Math.max(minPosition[axis], position);
            position = Math.min(maxPosition[axis], position);
        }
        return position;
    }, [keepInBounds, internalState]);
    const handleModalClose = () => {
        var _a;
        internalState.lastSetCoordinates = ZERO;
        setModalMenuClose();
        internalState.isInKeyboardMoveMode = false;
        setIsModalOpen(false);
        setCoordinates(ZERO);
        (_a = internalState.disposeOnKeyUp) === null || _a === void 0 ? void 0 : _a.call(internalState);
        onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();
    };
    const handleDragStart = React__namespace.useCallback(() => {
        setModalMenuClose();
        internalState.isInKeyboardMoveMode = false;
    }, [internalState, setModalMenuClose]);
    const handleDrag = React__namespace.useCallback(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    (ev, dragData) => {
        setCoordinates(prevValue => ({
            x: getClampedAxis('x', prevValue.x + dragData.delta.x),
            y: getClampedAxis('y', prevValue.y + dragData.delta.y)
        }));
    }, [getClampedAxis]);
    const handleDragStop = React__namespace.useCallback(() => {
        if (focusTrapZone.current) {
            focusTrapZone.current.focus();
        }
    }, []);
    const handleEnterKeyboardMoveMode = () => {
        // We need a global handleKeyDown event when we are in the move mode so that we can
        // handle the key presses and the components inside the modal do not get the events
        const handleKeyDown = (ev) => {
            if (ev.altKey && ev.ctrlKey && ev.keyCode === react.KeyCodes.space) {
                // CTRL + ALT + SPACE is handled during keyUp
                ev.preventDefault();
                ev.stopPropagation();
                return;
            }
            const newLocal = ev.altKey || ev.keyCode === react.KeyCodes.escape;
            if (isModalMenuOpen && newLocal) {
                setModalMenuClose();
            }
            if (internalState.isInKeyboardMoveMode && (ev.keyCode === react.KeyCodes.escape || ev.keyCode === react.KeyCodes.enter)) {
                internalState.isInKeyboardMoveMode = false;
                ev.preventDefault();
                ev.stopPropagation();
            }
            if (internalState.isInKeyboardMoveMode) {
                let handledEvent = true;
                const delta = getMoveDelta(ev);
                switch (ev.keyCode) {
                    /* eslint-disable no-fallthrough */
                    case react.KeyCodes.escape:
                        setCoordinates(internalState.lastSetCoordinates);
                    case react.KeyCodes.enter:
                        {
                            // TODO: determine if fallthrough was intentional
                            /* eslint-enable no-fallthrough */
                            internalState.lastSetCoordinates = ZERO; // setIsInKeyboardMoveMode(false);
                            break;
                        }
                    case react.KeyCodes.up:
                        {
                            setCoordinates(prevValue => ({
                                x: prevValue.x,
                                y: getClampedAxis('y', prevValue.y - delta)
                            }));
                            break;
                        }
                    case react.KeyCodes.down:
                        {
                            setCoordinates(prevValue => ({
                                x: prevValue.x,
                                y: getClampedAxis('y', prevValue.y + delta)
                            }));
                            break;
                        }
                    case react.KeyCodes.left:
                        {
                            setCoordinates(prevValue => ({
                                x: getClampedAxis('x', prevValue.x - delta),
                                y: prevValue.y
                            }));
                            break;
                        }
                    case react.KeyCodes.right:
                        {
                            setCoordinates(prevValue => ({
                                x: getClampedAxis('x', prevValue.x + delta),
                                y: prevValue.y
                            }));
                            break;
                        }
                    default:
                        {
                            handledEvent = false;
                        }
                }
                if (handledEvent) {
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        internalState.lastSetCoordinates = coordinates;
        setModalMenuClose();
        internalState.isInKeyboardMoveMode = true;
        internalState.events.on(win, 'keydown', handleKeyDown, true
        /* useCapture */
        );
        internalState.disposeOnKeyDown = () => {
            internalState.events.off(win, 'keydown', handleKeyDown, true
            /* useCapture */
            );
            internalState.disposeOnKeyDown = undefined;
        };
    };
    const handleExitKeyboardMoveMode = () => {
        var _a;
        internalState.lastSetCoordinates = ZERO;
        internalState.isInKeyboardMoveMode = false;
        (_a = internalState.disposeOnKeyDown) === null || _a === void 0 ? void 0 : _a.call(internalState);
    };
    const registerForKeyUp = () => {
        const handleKeyUp = (ev) => {
            // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143
            if (ev.altKey && ev.ctrlKey && ev.keyCode === react.KeyCodes.space) {
                if (react.elementContains(internalState.scrollableContent, ev.target)) {
                    toggleModalMenuOpen();
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        if (!internalState.disposeOnKeyUp) {
            internalState.events.on(win, 'keyup', handleKeyUp, true
            /* useCapture */
            );
            internalState.disposeOnKeyUp = () => {
                internalState.events.off(win, 'keyup', handleKeyUp, true
                /* useCapture */
                );
                internalState.disposeOnKeyUp = undefined;
            };
        }
    };
    React__namespace.useEffect(() => {
        clearTimeout(internalState.onModalCloseTimer); // Opening the dialog
        if (isOpen) {
            // This must be done after the modal content has rendered
            requestAnimationFrame(() => setTimeout(registerInitialModalPosition, 0));
            setIsModalOpen(true); // Add a keyUp handler for all key up events once the dialog is open.
            if (dragOptions) {
                registerForKeyUp();
            }
            internalState.hasBeenOpened = true;
            setIsVisible(true);
        } // Closing the dialog
        if (!isOpen && isModalOpen) {
            internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);
            setIsVisible(false);
        } // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates or if min/max drag bounds are updated.
    }, [isModalOpen, isOpen, minDragPosition, maxDragPosition]);
    reactHooks.useUnmount(() => {
        internalState.events.dispose();
    });
    useComponentRef(props, focusTrapZone);
    const modalContent = React__namespace.createElement(react.FocusTrapZone, { disabled: true, id: focusTrapZoneId, ref: focusTrapZoneElm, componentRef: focusTrapZone, className: classNames.main, elementToFocusOnDismiss: elementToFocusOnDismiss, isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking, ignoreExternalFocusing: ignoreExternalFocusing, forceFocusInsideTrap: forceFocusInsideTrap && !isModeless, firstFocusableSelector: firstFocusableSelector, focusPreviouslyFocusedInnerElement: true, onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined },
        dragOptions && internalState.isInKeyboardMoveMode && React__namespace.createElement("div", { className: classNames.keyboardMoveIconContainer }, dragOptions.keyboardMoveIconProps ? React__namespace.createElement(react.Icon, Object.assign({}, dragOptions.keyboardMoveIconProps)) : React__namespace.createElement(react.Icon, { iconName: "move", className: classNames.keyboardMoveIcon })),
        React__namespace.createElement("div", { ref: allowScrollOnModal, className: classNames.scrollableContent, "data-is-scrollable": true },
            dragOptions && isModalMenuOpen && React__namespace.createElement(dragOptions.menu, { items: [{
                        key: 'move',
                        text: dragOptions.moveMenuItemText,
                        onClick: handleEnterKeyboardMoveMode
                    }, {
                        key: 'close',
                        text: dragOptions.closeMenuItemText,
                        onClick: handleModalClose
                    }], onDismiss: setModalMenuClose, alignTargetEdge: true, coverTarget: true, directionalHint: react.DirectionalHint.topLeftEdge, directionalHintFixed: true, shouldFocusOnMount: true, target: internalState.scrollableContent }),
            children));
    return ( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    isModalOpen && modalResponsiveMode >= (responsiveMode || react.ResponsiveMode.small) && React__namespace.createElement(react.Layer, Object.assign({ ref: mergedRef }, mergedLayerProps),
        React__namespace.createElement(react.Popup, { role: isAlertRole ? 'alertdialog' : 'dialog', ariaLabelledBy: titleAriaId, ariaDescribedBy: subtitleAriaId, shouldRestoreFocus: !ignoreExternalFocusing, "aria-modal": !isModeless },
            React__namespace.createElement("div", { className: classNames.root, role: !isModeless ? 'document' : undefined },
                !isModeless && React__namespace.createElement(react.Overlay, Object.assign({ "aria-hidden": true, isDarkThemed: isDarkOverlay, onClick: isBlocking ? undefined : onDismiss, allowTouchBodyScroll: allowTouchBodyScroll }, overlay)),
                dragOptions ? React__namespace.createElement(DraggableZone, { handleSelector: dragOptions.dragHandleSelector || `#${focusTrapZoneId}`, preventDragSelector: "button", onStart: handleDragStart, onDragChange: handleDrag, onStop: handleDragStop, position: coordinates }, modalContent) : modalContent))) || null);
});
ModalBase.displayName = 'ModalBase';
const getDraggableZoneClassNames = react.memoizeFunction((className, isDragging) => {
    return {
        root: react.mergeStyles(className, isDragging && {
            touchAction: 'none',
            selectors: {
                '& *': {
                    userSelect: 'none'
                }
            }
        })
    };
});
const eventMapping = {
    touch: {
        start: 'touchstart',
        move: 'touchmove',
        stop: 'touchend'
    },
    mouse: {
        start: 'mousedown',
        move: 'mousemove',
        stop: 'mouseup'
    }
}; // These are needed so that we can generalize the events
class DraggableZone extends React__namespace.Component {
    constructor(props) {
        super(props);
        this._currentEventType = eventMapping.mouse;
        this._events = [];
        this._onMouseDown = (event) => {
            const onMouseDown = React__namespace.Children.only(this.props.children).props.onMouseDown;
            if (onMouseDown) {
                onMouseDown(event);
            }
            this._currentEventType = eventMapping.mouse;
            return this._onDragStart(event);
        };
        this._onMouseUp = (event) => {
            const onMouseUp = React__namespace.Children.only(this.props.children).props.onMouseUp;
            if (onMouseUp) {
                onMouseUp(event);
            }
            this._currentEventType = eventMapping.mouse;
            return this._onDragStop(event);
        };
        this._onTouchStart = (event) => {
            const onTouchStart = React__namespace.Children.only(this.props.children).props.onTouchStart;
            if (onTouchStart) {
                onTouchStart(event);
            }
            this._currentEventType = eventMapping.touch;
            return this._onDragStart(event);
        };
        this._onTouchEnd = (event) => {
            const onTouchEnd = React__namespace.Children.only(this.props.children).props.onTouchEnd;
            if (onTouchEnd) {
                onTouchEnd(event);
            }
            this._currentEventType = eventMapping.touch;
            this._onDragStop(event);
        };
        this._onDragStart = (event) => {
            // Only handle left click for dragging
            if (typeof event.button === 'number' && event.button !== 0) {
                return false;
            } // If the target doesn't match the handleSelector OR
            // if the target does match the preventDragSelector, bail out
            if (this.props.handleSelector && !this._matchesSelector(event.target, this.props.handleSelector) || this.props.preventDragSelector && this._matchesSelector(event.target, this.props.preventDragSelector)) {
                return;
            } // Remember the touch identifier if this is a touch event so we can
            // distinguish between individual touches in multitouch scenarios
            // by remembering which touch point we were given
            this._touchId = this._getTouchId(event);
            const position = this._getControlPosition(event);
            if (position === undefined) {
                return;
            }
            const dragData = this._createDragDataFromPosition(position);
            this.props.onStart && this.props.onStart(event, dragData);
            this.setState({
                isDragging: true,
                lastPosition: position
            }); // hook up the appropriate mouse/touch events to the body to ensure
            // smooth dragging
            this._events = [react.on(document.body, this._currentEventType.move, this._onDrag, true
                /* use capture phase */
                ), react.on(document.body, this._currentEventType.stop, this._onDragStop, true
                /* use capture phase */
                )];
            return;
        };
        this._onDrag = (event) => {
            // Prevent scrolling on mobile devices
            if (event.type === 'touchmove') {
                event.preventDefault();
            }
            const position = this._getControlPosition(event);
            if (!position) {
                return;
            } // create the updated drag data from the position data
            const updatedData = this._createUpdatedDragData(this._createDragDataFromPosition(position));
            const updatedPosition = updatedData.position;
            this.props.onDragChange && this.props.onDragChange(event, updatedData);
            this.setState({
                position: updatedPosition,
                lastPosition: position
            });
        };
        this._onDragStop = (event) => {
            if (!this.state.isDragging) {
                return;
            }
            const position = this._getControlPosition(event);
            if (!position) {
                return;
            }
            const baseDragData = this._createDragDataFromPosition(position); // Set dragging to false and reset the lastPosition
            this.setState({
                isDragging: false,
                lastPosition: undefined
            });
            this.props.onStop && this.props.onStop(event, baseDragData);
            if (this.props.position) {
                this.setState({
                    position: this.props.position
                });
            } // Remove event handlers
            this._events.forEach(dispose => dispose());
        };
        this.state = {
            isDragging: false,
            position: this.props.position || {
                x: 0,
                y: 0
            },
            lastPosition: undefined
        };
    }
    componentDidUpdate(prevProps) {
        if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {
            this.setState({
                position: this.props.position
            });
        }
    }
    componentWillUnmount() {
        this._events.forEach(dispose => dispose());
    }
    render() {
        const child = React__namespace.Children.only(this.props.children);
        const { props } = child;
        const { position } = this.props;
        const { position: statePosition, isDragging } = this.state;
        let x = statePosition.x;
        let y = statePosition.y;
        if (position && !isDragging) {
            x = position.x;
            y = position.y;
        }
        return React__namespace.cloneElement(child, {
            style: Object.assign(Object.assign({}, props.style), { transform: `translate(${x}px, ${y}px)` }),
            className: getDraggableZoneClassNames(props.className, this.state.isDragging).root,
            onMouseDown: this._onMouseDown,
            onMouseUp: this._onMouseUp,
            onTouchStart: this._onTouchStart,
            onTouchEnd: this._onTouchEnd
        });
    }
    /**
     * Get the control position based off the event that fired
     * @param event - The event to get offsets from
     */
    _getControlPosition(event) {
        const touchObj = this._getActiveTouch(event); // did we get the right touch?
        if (this._touchId !== undefined && !touchObj) {
            return undefined;
        }
        const eventToGetOffset = touchObj || event;
        return {
            x: eventToGetOffset.clientX,
            y: eventToGetOffset.clientY
        };
    }
    /**
     * Get the active touch point that we have saved from the event's TouchList
     * @param event - The event used to get the TouchList for the active touch point
     */
    _getActiveTouch(event) {
        return event.targetTouches && this._findTouchInTouchList(event.targetTouches) || event.changedTouches && this._findTouchInTouchList(event.changedTouches);
    }
    /**
     * Get the initial touch identifier associated with the given event
     * @param event - The event that contains the TouchList
     */
    _getTouchId(event) {
        const touch = event.targetTouches && event.targetTouches[0] || event.changedTouches && event.changedTouches[0];
        if (touch) {
            return touch.identifier;
        }
        return;
    }
    /**
     * Returns if an element (or any of the element's parents) match the given selector
     */
    _matchesSelector(element, selector) {
        if (!element || element === document.body) {
            return false;
        } // eslint-disable-next-line @typescript-eslint/ban-types
        const matchesSelectorFn = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
        /* for IE */
        if (!matchesSelectorFn) {
            return false;
        }
        return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);
    }
    /**
     * Attempts to find the Touch that matches the identifier  we stored in dragStart
     * @param touchList The TouchList to look for the stored identifier from dragStart
     */
    _findTouchInTouchList(touchList) {
        if (this._touchId === undefined) {
            return;
        }
        for (let i = 0; i < touchList.length; i++) {
            if (touchList[i].identifier === this._touchId) {
                return touchList[i];
            }
        }
        return undefined;
    }
    /**
     * Create DragData based off of the last known position and the new position passed in
     * @param position The new position as part of the drag
     */
    _createDragDataFromPosition(position) {
        const { lastPosition } = this.state; // If we have no lastPosition, use the given position
        // for last position
        if (lastPosition === undefined) {
            return {
                delta: {
                    x: 0,
                    y: 0
                },
                lastPosition: position,
                position
            };
        }
        return {
            delta: {
                x: position.x - lastPosition.x,
                y: position.y - lastPosition.y
            },
            lastPosition,
            position
        };
    }
    /**
     * Creates an updated DragData based off the current position and given baseDragData
     * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions
     */
    _createUpdatedDragData(baseDragData) {
        const { position } = this.state;
        return {
            position: {
                x: position.x + baseDragData.delta.x,
                y: position.y + baseDragData.delta.y
            },
            delta: baseDragData.delta,
            lastPosition: position
        };
    }
}
const globalClassNames = {
    root: 'ms-Modal',
    main: 'ms-Dialog-main',
    scrollableContent: 'ms-Modal-scrollableContent',
    isOpen: 'is-open',
    layer: 'ms-Modal-Layer'
};
const getStyles = (props) => {
    const { className, containerClassName, scrollableContentClassName, isOpen, isVisible, hasBeenOpened, modalRectangleTop, theme, topOffsetFixed, isModeless, layerClassName, isDefaultDragHandle, windowInnerHeight } = props;
    const { palette, effects, fonts } = theme;
    const classNames = react.getGlobalClassNames(globalClassNames, theme);
    return {
        root: [classNames.root, fonts.medium, {
                backgroundColor: 'transparent',
                position: isModeless ? 'absolute' : 'fixed',
                height: '100%',
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                opacity: 0,
                pointerEvents: 'none',
                transition: `opacity ${animationDuration}`
            }, topOffsetFixed && typeof modalRectangleTop === 'number' && hasBeenOpened && {
                alignItems: 'flex-start'
            }, isOpen && classNames.isOpen, isVisible && {
                opacity: 1,
                pointerEvents: 'auto'
            }, className],
        main: [classNames.main, {
                boxShadow: effects.elevation64,
                borderRadius: effects.roundedCorner2,
                backgroundColor: palette.white,
                boxSizing: 'border-box',
                position: 'relative',
                textAlign: 'left',
                outline: '3px solid transparent',
                maxHeight: 'calc(100% - 32px)',
                maxWidth: 'calc(100% - 32px)',
                minHeight: '176px',
                minWidth: '288px',
                overflowY: 'auto',
                zIndex: isModeless ? react.ZIndexes.Layer : undefined
            }, topOffsetFixed && typeof modalRectangleTop === 'number' && hasBeenOpened && {
                top: modalRectangleTop
            }, isDefaultDragHandle && {
                cursor: 'move'
            }, containerClassName],
        scrollableContent: [classNames.scrollableContent, {
                overflowY: 'auto',
                flexGrow: 1,
                maxHeight: '100vh',
                selectors: {
                    ['@supports (-webkit-overflow-scrolling: touch)']: {
                        maxHeight: windowInnerHeight
                    }
                }
            }, scrollableContentClassName],
        layer: isModeless && [layerClassName, classNames.layer, {
                position: 'static',
                width: 'unset',
                height: 'unset'
            }],
        keyboardMoveIconContainer: {
            position: 'absolute',
            display: 'flex',
            justifyContent: 'center',
            width: '100%',
            padding: '3px 0px'
        },
        keyboardMoveIcon: {
            fontSize: fonts.xLargePlus.fontSize,
            width: '24px'
        }
    };
};
/** @internal */
const _ModalClone = react.styled(ModalBase, getStyles, undefined, {
    scope: 'Modal',
    fields: ['theme', 'styles', 'enableAriaHiddenSiblings']
});
_ModalClone.displayName = 'Modal';

// Copyright (c) Microsoft Corporation.
/**
 * local video tile camera cycle button - for use on mobile screens only.
 * @internal
 */
const LocalVideoCameraCycleButton = (props) => {
    const { cameras, selectedCamera, onSelectCamera, label, ariaDescription } = props;
    const theme = react.useTheme();
    return React__default['default'].createElement(react.IconButton, { "data-ui-id": 'local-camera-switcher-button', styles: localVideoCameraCycleButtonStyles(theme), iconProps: {
            iconName: 'LocalCameraSwitch'
        }, ariaLabel: label, ariaDescription: ariaDescription, "aria-live": 'polite', onClick: () => {
            if (cameras && cameras.length > 1 && selectedCamera !== undefined) {
                const index = cameras.findIndex(camera => selectedCamera.id === camera.id);
                const newCamera = cameras[(index + 1) % cameras.length];
                if (onSelectCamera !== undefined) {
                    onSelectCamera(newCamera);
                }
            }
        } });
};

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of VideoTile for rendering local participant.
 *
 * @internal
 */
const _LocalVideoTile = React__default['default'].memo((props) => {
    const { isAvailable, isMuted, onCreateLocalStreamView, onDisposeLocalStreamView, localVideoViewOptions, renderElement, userId, showLabel, displayName, initialsName, onRenderAvatar, showMuteIndicator, styles, showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel, localVideoSelectedDescription } = props;
    const localVideoStreamProps = React.useMemo(() => ({
        isMirrored: localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.isMirrored,
        isStreamAvailable: isAvailable,
        onCreateLocalStreamView,
        onDisposeLocalStreamView,
        renderElementExists: !!renderElement,
        scalingMode: localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.scalingMode
    }), [isAvailable, localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.isMirrored, localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.scalingMode, onCreateLocalStreamView, onDisposeLocalStreamView, renderElement]); // Handle creating, destroying and updating the video stream as necessary
    useLocalVideoStreamLifecycleMaintainer(localVideoStreamProps);
    const renderVideoStreamElement = React.useMemo(() => {
        // Checking if renderElement is well defined or not as calling SDK has a number of video streams limitation which
        // implies that, after their threshold, all streams have no child (blank video)
        if (!renderElement || !renderElement.childElementCount) {
            // Returning `undefined` results in the placeholder with avatar being shown
            return undefined;
        }
        return React__default['default'].createElement(React__default['default'].Fragment, null,
            React__default['default'].createElement(FloatingLocalCameraCycleButton, { showCameraSwitcherInLocalPreview: showCameraSwitcherInLocalPreview !== null && showCameraSwitcherInLocalPreview !== void 0 ? showCameraSwitcherInLocalPreview : false, localVideoCameraCycleButtonProps: localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel: localVideoCameraSwitcherLabel, localVideoSelectedDescription: localVideoSelectedDescription }),
            React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement, isMirrored: true }));
    }, [localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel, localVideoSelectedDescription, renderElement, showCameraSwitcherInLocalPreview]);
    return React__default['default'].createElement(VideoTile, { key: userId !== null && userId !== void 0 ? userId : 'local-video-tile', userId: userId, renderElement: renderVideoStreamElement, showLabel: showLabel, displayName: displayName, initialsName: initialsName, styles: styles, onRenderPlaceholder: onRenderAvatar, isMuted: isMuted, showMuteIndicator: showMuteIndicator, personaMinSize: props.personaMinSize });
});
const FloatingLocalCameraCycleButton = (props) => {
    const { showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel, localVideoSelectedDescription } = props;
    const ariaDescription = (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.selectedCamera) && localVideoSelectedDescription && _formatString(localVideoSelectedDescription, {
        cameraName: localVideoCameraCycleButtonProps.selectedCamera.name
    });
    return React__default['default'].createElement(react.Stack, { horizontalAlign: "end" }, showCameraSwitcherInLocalPreview && (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.cameras) !== undefined && (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.selectedCamera) !== undefined && (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.onSelectCamera) !== undefined && React__default['default'].createElement(LocalVideoCameraCycleButton, { cameras: localVideoCameraCycleButtonProps.cameras, selectedCamera: localVideoCameraCycleButtonProps.selectedCamera, onSelectCamera: localVideoCameraCycleButtonProps.onSelectCamera, label: localVideoCameraSwitcherLabel, ariaDescription: ariaDescription }));
};

// Copyright (c) Microsoft Corporation.
// Currently the Calling JS SDK supports up to 4 remote video streams
const DEFAULT_MAX_REMOTE_VIDEO_STREAMS = 4; // Set aside only 6 dominant speakers for remaining audio participants
const MAX_AUDIO_DOMINANT_SPEAKERS = 6;
const DRAG_OPTIONS$1 = {
    moveMenuItemText: 'Move',
    closeMenuItemText: 'Close',
    menu: react.ContextualMenu,
    keepInBounds: true
}; // Manually override the max position used to keep the modal in the bounds of its container.
// This is a workaround for: https://github.com/microsoft/fluentui/issues/20122
// Because our modal starts in the bottom right corner, we can say that this is the max (i.e. rightmost and bottomost)
// position the modal can be dragged to.
const modalMaxDragPosition = {
    x: localVideoTileOuterPaddingPX,
    y: localVideoTileOuterPaddingPX
};
/**
 * VideoGallery represents a layout of video tiles for a specific call.
 * It displays a {@link VideoTile} for the local user as well as for each remote participant who has joined the call.
 *
 * @public
 */
const VideoGallery = (props) => {
    var _a, _b, _c, _d;
    const { localParticipant, remoteParticipants = [], localVideoViewOptions, remoteVideoViewOptions, dominantSpeakers, onRenderLocalVideoTile, onRenderRemoteVideoTile, onCreateLocalStreamView, onDisposeLocalStreamView, onCreateRemoteStreamView, onDisposeRemoteStreamView, styles, layout, onRenderAvatar, showMuteIndicator, maxRemoteVideoStreams = DEFAULT_MAX_REMOTE_VIDEO_STREAMS, showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps } = props;
    const ids = useIdentifiers();
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.videoGallery;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const shouldFloatLocalVideo = !!(layout === 'floatingLocalVideo' && remoteParticipants.length > 0);
    const shouldFloatNonDraggableLocalVideo = !!(showCameraSwitcherInLocalPreview && shouldFloatLocalVideo);
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    const isNarrow = containerWidth ? isNarrowWidth(containerWidth) : false;
    const visibleVideoParticipants = React.useRef([]);
    const visibleAudioParticipants = React.useRef([]);
    const modalWidth = isNarrow ? SMALL_FLOATING_MODAL_SIZE_PX.width : LARGE_FLOATING_MODAL_SIZE_PX.width;
    const modalHeight = isNarrow ? SMALL_FLOATING_MODAL_SIZE_PX.height : LARGE_FLOATING_MODAL_SIZE_PX.height; // The minimum drag position is the top left of the video gallery. i.e. the modal (PiP) should not be able
    // to be dragged offscreen and these are the top and left bounds of that calculation.
    const modalMinDragPosition = React.useMemo(() => containerWidth && containerHeight ? {
        // We use -containerWidth/Height because our modal is positioned to start in the bottom right,
        // hence (0,0) is the bottom right of the video gallery.
        x: -containerWidth + modalWidth + localVideoTileOuterPaddingPX,
        y: -containerHeight + modalHeight + localVideoTileOuterPaddingPX
    } : undefined, [containerHeight, containerWidth, modalHeight, modalWidth]);
    visibleVideoParticipants.current = smartDominantSpeakerParticipants({
        participants: (_a = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter(p => { var _a; return (_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable; })) !== null && _a !== void 0 ? _a : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleVideoParticipants.current,
        maxDominantSpeakers: maxRemoteVideoStreams
    }).slice(0, maxRemoteVideoStreams);
    // This set will be used to filter out participants already in visibleVideoParticipants
    const visibleVideoParticipantsSet = new Set(visibleVideoParticipants.current.map(p => p.userId));
    visibleAudioParticipants.current = smartDominantSpeakerParticipants({
        participants: (_b = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter(p => !visibleVideoParticipantsSet.has(p.userId))) !== null && _b !== void 0 ? _b : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleAudioParticipants.current,
        maxDominantSpeakers: MAX_AUDIO_DOMINANT_SPEAKERS
    });
    /**
     * Utility function for memoized rendering of LocalParticipant.
     */
    const localVideoTile = React.useMemo(() => {
        var _a, _b;
        if (onRenderLocalVideoTile) {
            return onRenderLocalVideoTile(localParticipant);
        }
        const localVideoTileStyles = react.concatStyleSets(shouldFloatLocalVideo ? floatingLocalVideoTileStyle : {}, {
            root: {
                borderRadius: theme.effects.roundedCorner4
            }
        }, styles === null || styles === void 0 ? void 0 : styles.localVideo);
        const initialsName = !localParticipant.displayName ? strings.displayNamePlaceholder : localParticipant.displayName;
        return React__default['default'].createElement(react.Stack, { key: "local-video-tile-key", tabIndex: 0, "aria-label": strings.localVideoMovementLabel, role: 'dialog' },
            React__default['default'].createElement(_LocalVideoTile, { userId: localParticipant.userId, onCreateLocalStreamView: onCreateLocalStreamView, onDisposeLocalStreamView: onDisposeLocalStreamView, isAvailable: (_a = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable, isMuted: localParticipant.isMuted, renderElement: (_b = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement, displayName: isNarrow ? '' : strings.localVideoLabel, initialsName: initialsName, localVideoViewOptions: localVideoViewOptions, onRenderAvatar: onRenderAvatar, showLabel: !(shouldFloatLocalVideo && isNarrow), showMuteIndicator: showMuteIndicator, showCameraSwitcherInLocalPreview: showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps: localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel: strings.localVideoCameraSwitcherLabel, localVideoSelectedDescription: strings.localVideoSelectedDescription, styles: localVideoTileStyles }));
    }, [isNarrow, localParticipant, localVideoCameraCycleButtonProps, localVideoViewOptions, onCreateLocalStreamView, onDisposeLocalStreamView, onRenderAvatar, onRenderLocalVideoTile, shouldFloatLocalVideo, showCameraSwitcherInLocalPreview, showMuteIndicator, strings.localVideoCameraSwitcherLabel, strings.localVideoLabel, strings.localVideoMovementLabel, strings.localVideoSelectedDescription, strings.displayNamePlaceholder, styles === null || styles === void 0 ? void 0 : styles.localVideo, theme.effects.roundedCorner4]);
    const defaultOnRenderVideoTile = React.useCallback((participant, isVideoParticipant) => {
        const remoteVideoStream = participant.videoStream;
        return React__default['default'].createElement(_RemoteVideoTile, Object.assign({ key: participant.userId }, participant, { onCreateRemoteStreamView: isVideoParticipant ? onCreateRemoteStreamView : undefined, onDisposeRemoteStreamView: isVideoParticipant ? onDisposeRemoteStreamView : undefined, isAvailable: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isAvailable : false, isReceiving: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isReceiving : false, renderElement: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.renderElement : undefined, remoteVideoViewOptions: isVideoParticipant ? remoteVideoViewOptions : undefined, onRenderAvatar: onRenderAvatar, showMuteIndicator: showMuteIndicator }));
    }, [onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions, onRenderAvatar, showMuteIndicator]);
    const videoTiles = onRenderRemoteVideoTile ? visibleVideoParticipants.current.map(participant => onRenderRemoteVideoTile(participant)) : visibleVideoParticipants.current.map((participant) => {
        return defaultOnRenderVideoTile(participant, true);
    });
    const audioTiles = onRenderRemoteVideoTile ? visibleAudioParticipants.current.map(participant => onRenderRemoteVideoTile(participant)) : visibleAudioParticipants.current.map((participant) => {
        return defaultOnRenderVideoTile(participant, false);
    });
    const screenShareParticipant = remoteParticipants.find(participant => { var _a; return (_a = participant.screenShareStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    const screenShareActive = screenShareParticipant || (localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isScreenSharingOn);
    const createGridTiles = () => {
        return videoTiles.length > 0 ? videoTiles : audioTiles;
    };
    const gridTiles = createGridTiles();
    const createHorizontalGalleryTiles = () => {
        if (screenShareActive) {
            // If screen sharing is active, assign video and audio participants as horizontal gallery participants
            return videoTiles.concat(audioTiles);
        }
        else {
            // If screen sharing is not active, then assign all video tiles as grid tiles.
            // If there are no video tiles, then assign audio tiles as grid tiles.
            return videoTiles.length > 0 ? audioTiles : [];
        }
    };
    const horizontalGalleryTiles = createHorizontalGalleryTiles();
    if (!shouldFloatLocalVideo && localVideoTile) {
        gridTiles.push(localVideoTile);
    }
    const localScreenShareStreamComponent = React__default['default'].createElement(LocalScreenShare, { localParticipant: localParticipant });
    const remoteScreenShareComponent = screenShareParticipant && React__default['default'].createElement(RemoteScreenShare, Object.assign({}, screenShareParticipant, { renderElement: (_c = screenShareParticipant.screenShareStream) === null || _c === void 0 ? void 0 : _c.renderElement, onCreateRemoteStreamView: onCreateRemoteStreamView, onDisposeRemoteStreamView: onDisposeRemoteStreamView, isReceiving: (_d = screenShareParticipant.screenShareStream) === null || _d === void 0 ? void 0 : _d.isReceiving }));
    const horizontalGalleryPresent = horizontalGalleryTiles && horizontalGalleryTiles.length > 0;
    const layerHostId = reactHooks.useId('layerhost');
    return React__default['default'].createElement("div", { "data-ui-id": ids.videoGallery, ref: containerRef, className: react.mergeStyles(videoGalleryOuterDivStyle, styles === null || styles === void 0 ? void 0 : styles.root) },
        shouldFloatLocalVideo && !shouldFloatNonDraggableLocalVideo && localVideoTile && (horizontalGalleryPresent ? React__default['default'].createElement(react.Stack, { className: react.mergeStyles(localVideoTileContainerStyle(theme, isNarrow)) }, localVideoTile) : React__default['default'].createElement(_ModalClone, { isOpen: true, isModeless: true, dragOptions: DRAG_OPTIONS$1, styles: floatingLocalVideoModalStyle(theme, isNarrow), layerProps: {
                hostId: layerHostId
            }, maxDragPosition: modalMaxDragPosition, minDragPosition: modalMinDragPosition }, localVideoTile)),
        shouldFloatNonDraggableLocalVideo && localVideoTile && remoteParticipants.length > 0 && React__default['default'].createElement(react.Stack, { className: react.mergeStyles(localVideoTileWithControlsContainerStyle(theme, isNarrow), {
                boxShadow: theme.effects.elevation8,
                zIndex: LOCAL_VIDEO_TILE_ZINDEX
            }) }, localVideoTile),
        React__default['default'].createElement(react.Stack, { horizontal: false, styles: videoGalleryContainerStyle },
            screenShareParticipant ? remoteScreenShareComponent : (localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isScreenSharingOn) ? localScreenShareStreamComponent : React__default['default'].createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
            horizontalGalleryPresent && React__default['default'].createElement("div", { style: {
                    paddingTop: '0.5rem'
                } },
                React__default['default'].createElement(ResponsiveHorizontalGallery, { key: "responsive-horizontal-gallery", containerStyles: horizontalGalleryContainerStyle(shouldFloatLocalVideo, isNarrow), horizontalGalleryStyles: react.concatStyleSets(horizontalGalleryStyle(isNarrow), styles === null || styles === void 0 ? void 0 : styles.horizontalGallery), childWidthRem: isNarrow ? SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width : LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.width, buttonWidthRem: HORIZONTAL_GALLERY_BUTTON_WIDTH, gapWidthRem: HORIZONTAL_GALLERY_GAP }, horizontalGalleryTiles)),
            React__default['default'].createElement(react.LayerHost, { id: layerHostId, className: react.mergeStyles(layerHostStyle) })));
};

/**
 * @private
 */
const controlBarStyles$1 = {
    horizontal: {
        flexFlow: 'row nowrap'
    },
    vertical: {
        flexFlow: 'column nowrap',
        width: 'fit-content',
        maxWidth: '8rem'
    },
    dockedTop: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        minWidth: 'fit-content'
    },
    dockedBottom: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        bottom: 0,
        left: 0,
        width: '100%',
        minWidth: 'fit-content'
    },
    dockedLeft: {
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        left: 0,
        height: '100%'
    },
    dockedRight: {
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        right: 0,
        height: '100%'
    },
    floatingTop: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '1rem',
        left: '50%',
        transform: 'translateX(-50%)',
        minWidth: 'fit-content',
        zIndex: 10
    },
    floatingBottom: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        bottom: '1rem',
        left: '50%',
        transform: 'translateX(-50%)',
        minWidth: 'fit-content',
        zIndex: 10
    },
    floatingLeft: {
        flexFlow: 'column nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '50%',
        left: '1rem',
        transform: 'translateY(-50%)',
        zIndex: 10
    },
    floatingRight: {
        flexFlow: 'column nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '50%',
        right: '1rem',
        transform: 'translateY(-50%)',
        zIndex: 10
    }
};
/**
 * @private
 */
const controlButtonStyles = {
    root: {
        background: 'none',
        border: 'none',
        borderRadius: 0,
        minHeight: '3.5rem',
        minWidth: '3.5rem',
        width: '100%',
        maxWidth: '8rem',
        svg: {
            verticalAlign: 'text-top'
        }
    },
    splitButtonMenuButton: {
        border: 'none'
    },
    flexContainer: {
        flexFlow: 'column',
        display: 'contents'
    },
    label: {
        fontSize: '0.625rem',
        fontWeight: '400',
        lineHeight: '1rem',
        cursor: 'pointer',
        display: 'block',
        margin: '0rem 0.25rem',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
    }
};
/**
 * making it Partial as IContextualMenuStyles has all its props non-optional and we only need title to be defined here.
 *
 * @private
 */
const participantsButtonMenuPropsStyle = {
    title: {
        background: 'initial',
        paddingLeft: '.5rem',
        fontWeight: 600,
        fontSize: '.75rem'
    }
};
/**
 * Default styles for button flyout items
 *
 * @private
 */
const buttonFlyoutItemStyles = {
    icon: {
        lineHeight: 0
    },
    checkmarkIcon: {
        lineHeight: 0
    }
};

// Copyright (c) Microsoft Corporation.
// To prevent sizing issues or tooltip positioning issues, we override to inline-block.
// For more details see "Icon Button with Tooltip" on https://developer.microsoft.com/en-us/fluentui#/controls/web/button
const hostStyles = {
    root: {
        display: 'inline-block'
    }
};
/**
 * Tooltip that should wrap control bar buttons.
 *
 * @private
 */
const ControlButtonTooltip = (props) => {
    const theme = react.useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    }; // Place callout with no gap between it and the button.
    const calloutProps = {
        gapSpace: 0,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    return React__default['default'].createElement(react.TooltipHost, Object.assign({}, props, { "data-ui-id": props.id, calloutProps: Object.assign(Object.assign({}, calloutProps), props.calloutProps), styles: react.mergeStyleSets(hostStyles, props.styles) }), props.children);
};

// Copyright (c) Microsoft Corporation.
const DefaultRenderIcon = (props) => {
    return (props === null || props === void 0 ? void 0 : props.checked) ? (props === null || props === void 0 ? void 0 : props.onRenderOnIcon) ? props === null || props === void 0 ? void 0 : props.onRenderOnIcon() : null : (props === null || props === void 0 ? void 0 : props.onRenderOffIcon) ? props === null || props === void 0 ? void 0 : props.onRenderOffIcon() : null;
};
/**
 * Default button styled for the {@link ControlBar}.
 *
 * Use this component create custom buttons that are styled the same as other buttons provided by the UI Library.
 *
 * @public
 */
const ControlBarButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    const componentStyles = react.concatStyleSets(controlButtonStyles, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    const labelText = (_d = (_b = props === null || props === void 0 ? void 0 : props.text) !== null && _b !== void 0 ? _b : (_c = props === null || props === void 0 ? void 0 : props.strings) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : ((props === null || props === void 0 ? void 0 : props.checked) ? (_e = props === null || props === void 0 ? void 0 : props.strings) === null || _e === void 0 ? void 0 : _e.onLabel : (_f = props === null || props === void 0 ? void 0 : props.strings) === null || _f === void 0 ? void 0 : _f.offLabel);
    const tooltipContent = (_h = (_g = props === null || props === void 0 ? void 0 : props.strings) === null || _g === void 0 ? void 0 : _g.tooltipContent) !== null && _h !== void 0 ? _h : ((props === null || props === void 0 ? void 0 : props.disabled) ? (_j = props === null || props === void 0 ? void 0 : props.strings) === null || _j === void 0 ? void 0 : _j.tooltipDisabledContent : (props === null || props === void 0 ? void 0 : props.checked) ? (_k = props === null || props === void 0 ? void 0 : props.strings) === null || _k === void 0 ? void 0 : _k.tooltipOnContent : (_l = props === null || props === void 0 ? void 0 : props.strings) === null || _l === void 0 ? void 0 : _l.tooltipOffContent);
    const tooltipId = ((_m = props.tooltipId) !== null && _m !== void 0 ? _m : props.labelKey) ? props.labelKey + '-tooltip' : undefined;
    return React__default['default'].createElement(ControlButtonTooltip, { content: tooltipContent, id: tooltipId },
        React__default['default'].createElement(react.DefaultButton, Object.assign({}, props, { styles: componentStyles, onRenderText: props.showLabel && props.onRenderText ? props.onRenderText : undefined, onRenderIcon: (_o = props.onRenderIcon) !== null && _o !== void 0 ? _o : DefaultRenderIcon, ariaLabel: (_r = (_q = (_p = props.splitButtonAriaLabel) !== null && _p !== void 0 ? _p : props.ariaLabel) !== null && _q !== void 0 ? _q : tooltipContent) !== null && _r !== void 0 ? _r : labelText, allowDisabledFocus: (_s = props.allowDisabledFocus) !== null && _s !== void 0 ? _s : true, menuTriggerKeyCode: react.KeyCodes.down }), props.showLabel ? labelText : React__default['default'].createElement(React__default['default'].Fragment, null)));
};

// Copyright (c) Microsoft Corporation.
/**
 * This is a helper component to define and unify icon colors
 *
 * @internal
 */
const _HighContrastAwareIcon = (props) => {
    const { iconName, disabled } = props;
    const theme = useTheme(); // setting colors for the icons using color from theme, so in dark mode or other accessibility modes, they have pre-defined contrast colors
    // the media query is for when in specific window accessibility mode, change the svg colors
    return React__default['default'].createElement(react.Icon, { iconName: iconName, className: react.mergeStyles({
            svg: {
                fill: disabled ? theme.palette.neutralTertiary : theme.palette.neutralPrimaryAlt,
                '@media (forced-colors: active) and (prefers-color-scheme: dark)': {
                    fill: disabled ? theme.palette.neutralPrimaryAlt : theme.palette.neutralTertiary
                }
            }
        }) });
};

// Copyright (c) Microsoft Corporation.
/**
 * Generates default {@link IContextualMenuProps} for buttons that
 * show a drop-down to select devices to use.
 *
 * @private
 */
const generateDefaultDeviceMenuProps = (props, strings, isSelectCamAllowed = true, isSelectMicAllowed = true) => {
    var _a, _b;
    const { microphones, speakers, cameras, selectedMicrophone, selectedSpeaker, selectedCamera, onSelectCamera, onSelectMicrophone, onSelectSpeaker } = props;
    const defaultMenuProps = {
        items: [],
        styles: props.styles,
        calloutProps: {
            styles: {
                root: {
                    // Confine the menu to the parents bounds.
                    // More info: https://github.com/microsoft/fluentui/issues/18835
                    // NB: 95% to keep some space for margin, drop shadow etc around the Callout.
                    maxWidth: '95%'
                }
            },
            preventDismissOnEvent: _preventDismissOnEvent
        }
    };
    const menuItemStyles = react.merge(buttonFlyoutItemStyles, (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.menuItemStyles) !== null && _b !== void 0 ? _b : {});
    if (cameras && selectedCamera && onSelectCamera && isSelectCamAllowed) {
        defaultMenuProps.items.push({
            key: 'sectionCamera',
            title: strings.cameraMenuTooltip,
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.cameraMenuTitle,
                items: cameras.map(camera => ({
                    key: camera.id,
                    text: camera.name,
                    title: camera.name,
                    iconProps: {
                        iconName: 'OptionsCamera',
                        styles: {
                            root: {
                                lineHeight: 0
                            }
                        }
                    },
                    itemProps: {
                        styles: menuItemStyles
                    },
                    canCheck: true,
                    isChecked: camera.id === (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id),
                    onClick: () => {
                        if (camera.id !== (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id)) {
                            onSelectCamera(camera);
                        }
                    }
                }))
            }
        });
    }
    if (microphones && selectedMicrophone && onSelectMicrophone && isSelectMicAllowed) {
        // Set props as Microphone if speakers can be enumerated else set as Audio Device
        const speakersAvailable = speakers && speakers.length > 0;
        const key = speakersAvailable ? 'sectionMicrophone' : 'sectionAudioDevice';
        const title = speakersAvailable ? strings.microphoneMenuTooltip : strings.audioDeviceMenuTooltip;
        const sectionPropsTitle = speakersAvailable ? strings.microphoneMenuTitle : strings.audioDeviceMenuTitle;
        const iconName = speakersAvailable ? 'OptionsMic' : 'OptionsSpeaker';
        defaultMenuProps.items.push({
            key: key,
            title: title,
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: sectionPropsTitle,
                items: microphones.map(microphone => ({
                    key: microphone.id,
                    text: microphone.name,
                    title: microphone.name,
                    iconProps: {
                        iconName: iconName,
                        styles: {
                            root: {
                                lineHeight: 0
                            }
                        }
                    },
                    itemProps: {
                        styles: menuItemStyles
                    },
                    canCheck: true,
                    isChecked: microphone.id === (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id),
                    onClick: () => {
                        if (microphone.id !== (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id)) {
                            onSelectMicrophone(microphone);
                        }
                    }
                }))
            }
        });
    }
    if (speakers && selectedSpeaker && onSelectSpeaker) {
        defaultMenuProps.items.push({
            key: 'sectionSpeaker',
            title: strings.speakerMenuTooltip,
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.speakerMenuTitle,
                items: speakers.map(speaker => ({
                    key: speaker.id,
                    text: speaker.name,
                    title: speaker.name,
                    iconProps: {
                        iconName: 'OptionsSpeaker',
                        styles: {
                            root: {
                                lineHeight: 0
                            }
                        }
                    },
                    itemProps: {
                        styles: menuItemStyles
                    },
                    canCheck: true,
                    isChecked: speaker.id === (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id),
                    onClick: () => {
                        if (speaker.id !== (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id)) {
                            onSelectSpeaker(speaker);
                        }
                    }
                }))
            }
        });
    }
    if (defaultMenuProps.items.length === 0) {
        // Avoids creating an empty context menu.
        return undefined;
    }
    return defaultMenuProps;
};
/**
 * A button to open a menu that controls device options.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const DevicesButton = (props) => {
    var _a, _b, _c;
    const { onRenderIcon } = props;
    const localeStrings = useLocale$1().strings.devicesButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const devicesButtonMenu = (_a = props.menuProps) !== null && _a !== void 0 ? _a : generateDefaultDeviceMenuProps(Object.assign(Object.assign({}, props), { styles: (_b = props.styles) === null || _b === void 0 ? void 0 : _b.menuStyles }), strings);
    const onRenderOptionsIcon = () => {
        return React__default['default'].createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonOptions" });
    };
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { menuProps: devicesButtonMenu, menuIconProps: {
            hidden: true
        }, onRenderIcon: onRenderIcon !== null && onRenderIcon !== void 0 ? onRenderIcon : onRenderOptionsIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'devicesButtonLabel' }));
};

var __awaiter$p = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const defaultLocalVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * A button to turn camera on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const CameraButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const { localVideoViewOptions, onToggleCamera } = props;
    const [waitForCamera, setWaitForCamera] = React.useState(false);
    const localeStrings = useLocale$1().strings.cameraButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const [announcerString, setAnnouncerString] = React.useState(undefined);
    const disabled = props.disabled || waitForCamera;
    const onRenderCameraOnIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonCameraOn" });
    const onRenderCameraOffIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonCameraOff" });
    if (waitForCamera && strings.tooltipVideoLoadingContent) {
        strings.tooltipDisabledContent = strings.tooltipVideoLoadingContent;
    }
    const cameraOn = props.checked;
    const splitButtonAriaString = cameraOn ? strings.onSplitButtonAriaLabel : strings.offSplitButtonAriaLabel;
    const toggleAnnouncerString = React.useCallback((isCameraOn) => {
        setAnnouncerString(!isCameraOn ? strings.cameraActionTurnedOffAnnouncement : strings.cameraActionTurnedOnAnnouncement);
    }, [strings.cameraActionTurnedOffAnnouncement, strings.cameraActionTurnedOnAnnouncement]);
    const onToggleClick = React.useCallback(() => __awaiter$p(void 0, void 0, void 0, function* () {
        // Throttle click on camera, need to await onToggleCamera then allow another click
        if (onToggleCamera) {
            setWaitForCamera(true);
            try {
                yield onToggleCamera(localVideoViewOptions !== null && localVideoViewOptions !== void 0 ? localVideoViewOptions : defaultLocalVideoViewOptions); // allows for the setting of narrator strings triggering the announcer when camera is turned on or off.
                toggleAnnouncerString(!cameraOn);
            }
            finally {
                setWaitForCamera(false);
            }
        }
    }), [cameraOn, localVideoViewOptions, onToggleCamera, toggleAnnouncerString]);
    return React__default['default'].createElement(React__default['default'].Fragment, null,
        React__default['default'].createElement(Announcer, { announcementString: announcerString, ariaLive: 'polite' }),
        React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { disabled: disabled, onClick: onToggleCamera ? onToggleClick : props.onClick, onRenderOnIcon: (_a = props.onRenderOnIcon) !== null && _a !== void 0 ? _a : onRenderCameraOnIcon, onRenderOffIcon: (_b = props.onRenderOffIcon) !== null && _b !== void 0 ? _b : onRenderCameraOffIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'cameraButtonLabel', menuProps: (_d = props.menuProps) !== null && _d !== void 0 ? _d : (props.enableDeviceSelectionMenu ? generateDefaultDeviceMenuProps(Object.assign(Object.assign({}, props), { styles: (_e = props.styles) === null || _e === void 0 ? void 0 : _e.menuStyles }), strings) : undefined), menuIconProps: ((_f = props.menuIconProps) !== null && _f !== void 0 ? _f : !props.enableDeviceSelectionMenu) ? {
                hidden: true
            } : undefined, split: (_g = props.split) !== null && _g !== void 0 ? _g : props.enableDeviceSelectionMenu, "aria-roledescription": props.enableDeviceSelectionMenu ? strings.cameraButtonSplitRoleDescription : undefined, splitButtonAriaLabel: props.enableDeviceSelectionMenu ? splitButtonAriaString : undefined })));
};

// Copyright (c) Microsoft Corporation.
const mainDivStyle = {
    position: 'relative',
    height: '100%',
    width: '100%'
};
/**
 * A container for various buttons for call controls.
 *
 * Use with various call control buttons in this library, e.g., {@link CameraButton}, or your own instances of
 * {@link ControlBarButton} directly.
 *
 * @public
 */
const ControlBar = (props) => {
    const { styles, layout } = props;
    const theme = useTheme();
    const controlBarClassName = React.useMemo(() => {
        const controlBarStyle = controlBarStyles$1[layout !== null && layout !== void 0 ? layout : 'horizontal']; // if theme is dark and layout is floating then use palette.neutralQuaternaryAlt as background, otherwise use theme.palette.white
        const backgroundStyle = {
            background: isDarkThemed(theme) && (layout === null || layout === void 0 ? void 0 : layout.startsWith('floating')) ? theme.palette.neutralQuaternaryAlt : theme.palette.white
        };
        const borderAndBoxShadowStyle = (layout === null || layout === void 0 ? void 0 : layout.startsWith('floating')) ? {
            boxShadow: theme.effects.elevation16,
            borderRadius: theme.effects.roundedCorner6
        } : {}; // if rtl is true and layout is either floatingTop or floatingBottom then we need to override the transform-style property
        // to translate 50% to right instead of the left
        const transformOverrideStyle = theme.rtl && (layout === 'floatingTop' || layout === 'floatingBottom') ? {
            transform: 'translateX(50%)'
        } : {};
        return react.mergeStyles(controlBarStyle, backgroundStyle, borderAndBoxShadowStyle, transformOverrideStyle, styles === null || styles === void 0 ? void 0 : styles.root);
    }, [layout, styles === null || styles === void 0 ? void 0 : styles.root, theme]);
    return React__default['default'].createElement("div", { className: react.mergeStyles(mainDivStyle) },
        React__default['default'].createElement(react.Stack, { className: controlBarClassName }, props.children));
};

// Copyright (c) Microsoft Corporation.
const onRenderEndCallIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonEndCall" });
/**
 * A button to end an ongoing call.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const EndCallButton = (props) => {
    var _a, _b, _c;
    const { styles } = props;
    const localeStrings = useLocale$1().strings.endCallButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = useTheme();
    const isDarkTheme = isDarkThemed(theme);
    const componentStyles = react.concatStyleSets(isDarkTheme ? darkThemeCallButtonStyles : lightThemeCallButtonStyles, styles !== null && styles !== void 0 ? styles : {});
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { onClick: (_a = props.onHangUp) !== null && _a !== void 0 ? _a : props.onClick, styles: componentStyles, onRenderIcon: (_b = props.onRenderIcon) !== null && _b !== void 0 ? _b : onRenderEndCallIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'endCallButtonLabel' }));
}; // using media query to prevent windows from overwriting the button color
const darkThemeCallButtonStyles = {
    root: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        },
        ':focus::after': {
            outlineColor: `${darkTheme.callingPalette.iconWhite} !important`
        } // added !important to avoid override by FluentUI button styles
    },
    rootHovered: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        }
    },
    rootPressed: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        }
    },
    label: {
        color: darkTheme.callingPalette.iconWhite
    }
};
const lightThemeCallButtonStyles = {
    root: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        },
        ':focus::after': {
            outlineColor: `${lightTheme.callingPalette.iconWhite} !important`
        } // added !important to avoid override by FluentUI button styles
    },
    rootHovered: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        }
    },
    rootPressed: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        }
    },
    label: {
        color: lightTheme.callingPalette.iconWhite
    }
};

var __awaiter$o = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * A button to turn microphone on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const MicrophoneButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const { onToggleMicrophone } = props;
    const localeStrings = useLocale$1().strings.microphoneButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const [announcerString, setAnnouncerString] = React.useState(undefined);
    const isSplit = (_a = props.split) !== null && _a !== void 0 ? _a : props.enableDeviceSelectionMenu; // The button should be disabled when there are no mics. However if the button is a split button, if there are
    // no mics but there are speakers, then only the primary part of the button should be disabled to allow for
    // speaker change.
    const primaryDisabled = props.primaryDisabled || (isSplit && !((_b = props.microphones) === null || _b === void 0 ? void 0 : _b.length) ? true : undefined);
    const disabled = props.disabled || isSplit && !((_c = props.microphones) === null || _c === void 0 ? void 0 : _c.length) && !((_d = props.speakers) === null || _d === void 0 ? void 0 : _d.length) || !isSplit && props.microphones && ((_e = props.microphones) === null || _e === void 0 ? void 0 : _e.length) === 0;
    const onRenderMicOnIcon = () => {
        return React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonMicOn" });
    };
    const onRenderMicOffIcon = () => {
        return React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonMicOff" });
    };
    const isMicOn = props.checked;
    const splitButtonAriaString = isMicOn ? strings.onSplitButtonAriaLabel : strings.offSplitButtonAriaLabel;
    const toggleAnnouncerString = React.useCallback((isMicOn) => {
        setAnnouncerString(!isMicOn ? strings.microphoneActionTurnedOffAnnouncement : strings.microphoneActionTurnedOnAnnouncement);
    }, [strings.microphoneActionTurnedOffAnnouncement, strings.microphoneActionTurnedOnAnnouncement]);
    const onToggleClick = React.useCallback(() => __awaiter$o(void 0, void 0, void 0, function* () {
        if (onToggleMicrophone) {
            try {
                yield onToggleMicrophone(); // allows for the setting of narrator strings triggering the announcer when microphone is turned on or off.
                toggleAnnouncerString(!isMicOn); // eslint-disable-next-line no-empty
            }
            finally { }
        }
    }), [isMicOn, onToggleMicrophone, toggleAnnouncerString]);
    return React__default['default'].createElement(React__default['default'].Fragment, null,
        React__default['default'].createElement(Announcer, { announcementString: announcerString, ariaLive: 'polite' }),
        React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { onClick: props.onToggleMicrophone ? onToggleClick : props.onClick, onRenderOnIcon: (_f = props.onRenderOnIcon) !== null && _f !== void 0 ? _f : onRenderMicOnIcon, onRenderOffIcon: (_g = props.onRenderOffIcon) !== null && _g !== void 0 ? _g : onRenderMicOffIcon, strings: strings, labelKey: (_h = props.labelKey) !== null && _h !== void 0 ? _h : 'microphoneButtonLabel', menuProps: (_j = props.menuProps) !== null && _j !== void 0 ? _j : (props.enableDeviceSelectionMenu ? generateDefaultDeviceMenuProps(Object.assign(Object.assign({}, props), { styles: (_k = props.styles) === null || _k === void 0 ? void 0 : _k.menuStyles }), strings) : undefined), menuIconProps: ((_l = props.menuIconProps) !== null && _l !== void 0 ? _l : !props.enableDeviceSelectionMenu) ? {
                hidden: true
            } : undefined, split: (_m = props.split) !== null && _m !== void 0 ? _m : props.enableDeviceSelectionMenu, "aria-roledescription": props.enableDeviceSelectionMenu ? strings.microphoneButtonSplitRoleDescription : undefined, splitButtonAriaLabel: props.enableDeviceSelectionMenu ? splitButtonAriaString : undefined, disabled: disabled, primaryDisabled: primaryDisabled })));
};

// Copyright (c) Microsoft Corporation.
/**
 * A button to show a menu with calling or chat participants.
 *
 * Can be used with {@link ControlBar}.
 *
 * This button contains dropdown menu items defined through its property `menuProps`. By default, it can display the number of remote participants with the full list
 * as sub-menu and an option to mute all participants, as well as a copy-to-clipboard button to copy the call invitation URL.
 * This `menuProps` can be fully redefined and its property is of type [IContextualMenuProps](https://developer.microsoft.com/fluentui#/controls/web/contextualmenu#IContextualMenuProps).
 *
 * @public
 */
const ParticipantsButton = (props) => {
    var _a, _b, _c, _d;
    const { callInvitationURL, styles, onMuteAll, onRenderIcon, onRenderParticipantList, participants, myUserId, excludeMe, onRenderParticipant, onRenderAvatar, onRemoveParticipant, onFetchParticipantMenuItems, showParticipantOverflowTooltip } = props;
    const disabled = props.disabled;
    const onRenderPeopleIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonParticipants" });
    const ids = useIdentifiers();
    const onMuteAllCallback = React.useCallback(() => {
        if (onMuteAll) {
            onMuteAll();
        }
    }, [onMuteAll]);
    const defaultParticipantList = React.useCallback(() => {
        var _a;
        return React__default['default'].createElement(ParticipantList, { participants: participants, myUserId: myUserId, excludeMe: excludeMe, onRenderParticipant: onRenderParticipant, onRenderAvatar: onRenderAvatar, onRemoveParticipant: onRemoveParticipant, onFetchParticipantMenuItems: onFetchParticipantMenuItems, styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.participantListStyles, showParticipantOverflowTooltip: showParticipantOverflowTooltip });
    }, [excludeMe, myUserId, onRemoveParticipant, onRenderAvatar, onRenderParticipant, participants, (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.participantListStyles, onFetchParticipantMenuItems, showParticipantOverflowTooltip]);
    const onCopyCallback = React.useCallback(() => {
        if (callInvitationURL) {
            return copy__default['default'](callInvitationURL);
        }
        return false;
    }, [callInvitationURL]);
    const localeStrings = useLocale$1().strings.participantsButton;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]);
    const participantCount = participants.length;
    const generateDefaultParticipantsSubMenuProps = React.useCallback(() => {
        var _a;
        const items = [];
        if (participantCount > 0) {
            items.push({
                key: 'participantListMenuItemKey',
                onRender: onRenderParticipantList !== null && onRenderParticipantList !== void 0 ? onRenderParticipantList : defaultParticipantList
            });
            items.push({
                key: 'participantsDivider1',
                itemType: react.ContextualMenuItemType.Divider
            });
            if (onMuteAll) {
                items.push({
                    key: 'muteAllKey',
                    text: strings.muteAllButtonLabel,
                    title: strings.muteAllButtonLabel,
                    styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.menuItemStyles,
                    iconProps: {
                        iconName: 'MicOff2'
                    },
                    onClick: onMuteAllCallback
                });
            }
        }
        return items;
    }, [participantCount, onRenderParticipantList, defaultParticipantList, onMuteAll, strings.muteAllButtonLabel, (_b = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _b === void 0 ? void 0 : _b.menuItemStyles, onMuteAllCallback]);
    const defaultMenuProps = React.useMemo(() => {
        var _a, _b;
        const menuProps = {
            title: strings.menuHeader,
            styles: react.merge(participantsButtonMenuPropsStyle, styles === null || styles === void 0 ? void 0 : styles.menuStyles),
            items: [],
            calloutProps: {
                preventDismissOnEvent: _preventDismissOnEvent
            }
        };
        if (participantCount > 0) {
            const participantIds = participants.map(p => p.userId);
            let participantCountWithoutMe = participantIds.length;
            if (excludeMe) {
                participantCountWithoutMe -= 1;
            }
            menuProps.items.push({
                key: 'participantCountKey',
                name: _formatString(strings.participantsListButtonLabel, {
                    numParticipants: `${participantCountWithoutMe}`
                }),
                itemProps: {
                    styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.menuItemStyles
                },
                iconProps: {
                    iconName: 'People'
                },
                subMenuProps: {
                    items: generateDefaultParticipantsSubMenuProps(),
                    calloutProps: {
                        styles: {
                            root: {
                                // Confine the menu to the parents bounds.
                                // More info: https://github.com/microsoft/fluentui/issues/18835
                                maxWidth: '100%'
                            }
                        },
                        style: {
                            maxHeight: '20rem'
                        },
                        // Disable dismiss on resize to work around a couple Fluent UI bugs
                        // See reasoning in the props for the parent menu.
                        preventDismissOnEvent: _preventDismissOnEvent
                    }
                },
                'data-ui-id': ids.participantButtonPeopleMenuItem
            });
        }
        if (callInvitationURL) {
            menuProps.items.push({
                key: 'InviteLinkKey',
                name: strings.copyInviteLinkButtonLabel,
                title: strings.copyInviteLinkButtonLabel,
                itemProps: {
                    styles: (_b = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _b === void 0 ? void 0 : _b.menuItemStyles
                },
                iconProps: {
                    iconName: 'Link'
                },
                onClick: onCopyCallback
            });
        }
        return menuProps;
    }, [strings.menuHeader, strings.participantsListButtonLabel, strings.copyInviteLinkButtonLabel, styles === null || styles === void 0 ? void 0 : styles.menuStyles, participantCount, callInvitationURL, participants, excludeMe, ids.participantButtonPeopleMenuItem, generateDefaultParticipantsSubMenuProps, onCopyCallback]);
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { disabled: disabled, menuProps: (_c = props.menuProps) !== null && _c !== void 0 ? _c : defaultMenuProps, menuIconProps: {
            hidden: true
        }, onRenderIcon: onRenderIcon !== null && onRenderIcon !== void 0 ? onRenderIcon : onRenderPeopleIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'participantsButtonLabel' }));
};

// Copyright (c) Microsoft Corporation.
/**
 * A button to start / stop screen sharing.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const ScreenShareButton = (props) => {
    var _a, _b, _c, _d;
    const localeStrings = useLocale$1().strings.screenShareButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = react.useTheme();
    const styles = screenshareButtonStyles(theme);
    const onRenderScreenShareOnIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonScreenShareStop" });
    const onRenderScreenShareOffIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonScreenShareStart" });
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { className: react.mergeStyles(styles, props.styles), onClick: (_a = props.onToggleScreenShare) !== null && _a !== void 0 ? _a : props.onClick, onRenderOnIcon: (_b = props.onRenderOnIcon) !== null && _b !== void 0 ? _b : onRenderScreenShareOnIcon, onRenderOffIcon: (_c = props.onRenderOffIcon) !== null && _c !== void 0 ? _c : onRenderScreenShareOffIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'screenShareButtonLabel', disabled: props.disabled }));
};
const screenshareButtonStyles = (theme) => ({
    rootChecked: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': {
            outlineColor: `${react.DefaultPalette.white} !important`
        } // added !important to avoid override by FluentUI button styles
    },
    rootCheckedHovered: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': {
            outlineColor: `${react.DefaultPalette.white} !important`
        } // added !important to avoid override by FluentUI button styles
    },
    labelChecked: {
        color: react.DefaultPalette.white
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * For keyboard navigation - when this component has active focus, enter key and space keys should have the same behavior as mouse click.
 *
 * @private
 */
const submitWithKeyboard = (e, onSubmit) => {
    if (e.key === 'Enter' || e.key === ' ') {
        onSubmit(e);
    }
};

// Copyright (c) Microsoft Corporation.
/** @private */
const PictureInPictureInPicturePrimaryTile = (props) => {
    const boxShadow = useTheme().effects.elevation8;
    return React__default['default'].createElement(PictureInPictureInPictureTile, { styles: primaryTileStyles(props.orientation, boxShadow) }, props.children);
};
/** @private */
const PictureInPictureInPictureSecondaryTile = (props) => React__default['default'].createElement(PictureInPictureInPictureTile, { styles: secondaryTileStyles(props.orientation) }, props.children);
const PictureInPictureInPictureTile = (props) => React__default['default'].createElement(react.Stack, { styles: props.styles }, props.children);
const primaryTileStyles = react.memoizeFunction((orientation, themeElevation) => ({
    root: {
        borderRadius: '0.25rem',
        height: orientation === 'landscape' ? '5.5rem' : '8rem',
        width: orientation === 'landscape' ? '8rem' : '5.5rem',
        boxShadow: themeElevation,
        // PiPiP tiles were not designed to host scrollable content. If removed check no scrollbar is showing in e2e tests
        overflow: 'hidden'
    }
}));
const secondaryTileStyles = react.memoizeFunction((orientation) => ({
    root: {
        borderRadius: '0.25rem',
        height: orientation === 'landscape' ? '1.625rem' : '2rem',
        width: orientation === 'landscape' ? '2rem' : '1.625rem',
        // PiPiP tiles were not designed to host scrollable content. If removed check no scrollbar is showing in e2e tests
        overflow: 'hidden'
    }
}));

// Copyright (c) Microsoft Corporation.
/**
 * Component that displays a video feed for use as a Picture-in-Picture style component.
 * It contains a secondary video feed resulting in an inner Picture-in-Picture style feed.
 *
 * @remarks
 * The double nature of the Picture-in-Picture styles is where this component gets its name; Picture-in-Picture-in-Picture.
 *
 * @internal
 */
const _PictureInPictureInPicture = (props) => {
    return React__default['default'].createElement(PictureInPictureInPictureContainer, { onClick: props.onClick, primaryView: React__default['default'].createElement(PictureInPictureInPicturePrimaryTile, Object.assign({}, props.primaryTile)), secondaryView: props.secondaryTile && React__default['default'].createElement(PictureInPictureInPictureSecondaryTile, Object.assign({}, props.secondaryTile)), ariaLabel: props.strings.rootAriaLabel });
};
/**
 * Container for the picture in picture in picture component.
 * This governs positioning and floating of the secondary PiP.
 */
const PictureInPictureInPictureContainer = (props) => {
    const onKeyPress = (e) => props.onClick && submitWithKeyboard(e, props.onClick);
    return React__default['default'].createElement("aside", { style: tileContainerStyles, onClick: props.onClick, onKeyPress: onKeyPress, "aria-label": props.ariaLabel, tabIndex: props.onClick ? 0 : -1, "data-ui-id": "picture-in-picture-in-picture-root" },
        props.primaryView,
        React__default['default'].createElement("div", { style: secondaryTileFloatingStyles }, props.secondaryView));
};
const tileContainerStyles = {
    display: 'flex',
    width: 'min-content',
    position: 'relative',
    cursor: 'pointer'
};
const secondaryTileFloatingStyles = {
    // The secondary tile should float above the primary tile, aligned to the bottom right.
    position: 'absolute',
    bottom: '0.125rem',
    right: '0.125rem'
};

// Copyright (c) Microsoft Corporation.
/**
 * Maps the individual item in menuProps.items passed in the {@link DrawerMenu} into a UI component.
 *
 * @private
 */
const DrawerMenuItem = (props) => {
    var _a;
    const theme = useTheme();
    const onClick = (ev) => props.onItemClick && props.onItemClick(ev, props.itemKey);
    const onKeyPress = (ev) => onClick && submitWithKeyboard(ev, onClick);
    const secondaryIcon = props.secondaryIconProps ? React__default['default'].createElement(MenuItemIcon, Object.assign({}, props.secondaryIconProps)) : props.subMenuProps ? React__default['default'].createElement(MenuItemIcon, { iconName: "ChevronRight" }) : undefined;
    return React__default['default'].createElement(react.Stack, { tabIndex: 0, role: "menuitem", horizontal: true, className: react.mergeStyles(drawerMenuItemRootStyles(theme.palette.neutralLight, theme.fonts.small), props.disabled ? disabledDrawerMenuItemRootStyles(theme.palette.neutralQuaternaryAlt) : undefined, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root), onKeyPress: props.disabled ? undefined : onKeyPress, onClick: props.disabled ? undefined : onClick, tokens: menuItemChildrenGap, id: props.id },
        props.iconProps && React__default['default'].createElement(react.Stack.Item, { role: "presentation", styles: props.disabled ? {
                root: {
                    color: theme.palette.neutralTertiaryAlt
                }
            } : undefined },
            React__default['default'].createElement(MenuItemIcon, Object.assign({}, props.iconProps))),
        React__default['default'].createElement(react.Stack.Item, { styles: drawerMenuItemTextStyles, grow: true },
            React__default['default'].createElement(react.Text, { styles: props.disabled ? {
                    root: {
                        color: theme.palette.neutralTertiaryAlt
                    }
                } : undefined }, props.text)),
        props.secondaryText && React__default['default'].createElement(react.Stack.Item, { styles: drawerMenuItemTextStyles, className: react.mergeStyles(secondaryTextStyles) },
            React__default['default'].createElement(react.Text, { styles: {
                    root: {
                        color: props.disabled ? theme.palette.neutralTertiaryAlt : theme.palette.neutralSecondary
                    }
                } }, props.secondaryText)),
        secondaryIcon && React__default['default'].createElement(react.Stack.Item, null, secondaryIcon));
};
const MenuItemIcon = (props) => React__default['default'].createElement(react.FontIcon, Object.assign({ className: react.mergeStyles(iconStyles) }, props));
const menuItemChildrenGap = {
    childrenGap: '0.5rem'
};
const drawerMenuItemRootStyles = (hoverBackground, fontSize) => (Object.assign(Object.assign({}, fontSize), { height: '3rem', lineHeight: '3rem', padding: '0rem 0.75rem', cursor: 'pointer', ':hover, :focus': {
        background: hoverBackground
    } }));
const disabledDrawerMenuItemRootStyles = (background) => ({
    pointerEvents: 'none',
    background: background,
    ':hover, :focus': {
        background: background
    }
});
/** Ensure long text entries appropriately show ellipsis instead of wrapping to a new line or showing a scrollbar */
const drawerMenuItemTextStyles = {
    root: {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
    }
};
const iconStyles = {
    // Vertically center icons in the menu item. Using line-height does not work for centering fluent SVG icons.
    display: 'flex',
    alignItems: 'center',
    height: '100%',
    // This can be removed when we upgrade to fluent-react-icons v2 (that removes the inner span element)
    ' span': {
        display: 'flex',
        alignItems: 'center',
        height: '100%'
    }
};
const secondaryTextStyles = {
    // limit width for secondaryText in the menu item so it does not overlap with text on left.
    maxWidth: '50%'
};

// Copyright (c) Microsoft Corporation.
/**
 * Container that holds the content of the drawer
 *
 * @private
 */
const DrawerContentContainer = (props) => {
    var _a;
    const theme = react.useTheme();
    const backgroundColor = theme.palette.white;
    const borderRadius = theme.effects.roundedCorner4;
    const rootStyles = react.mergeStyles(containerStyles$1(backgroundColor, borderRadius), (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root);
    return React__default['default'].createElement(react.Stack, { className: rootStyles }, props.children);
};
const containerStyles$1 = (backgroundColor, borderRadius) => (Object.assign({ background: backgroundColor, borderTopRightRadius: borderRadius, borderTopLeftRadius: borderRadius }, react.AnimationStyles.slideUpIn10));

// Copyright (c) Microsoft Corporation.
/**
 * An element that fills the space the DrawerContentContainer does not take up.
 * This is the element that enables the light dismiss feature.
 *
 * @private
 */
const DrawerLightDismiss = (props) => {
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(lightDismissContainerStyles, props.styles), grow: true, onClick: () => props.onDismiss() });
};
const lightDismissContainerStyles = {
    root: {
        height: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * A `Drawer` can be used to reveal lightweight views inside your application.
 * They appear from the bottom of the screen upwards and are light-dismissed.
 *
 * @internal
 */
const _DrawerSurface = (props) => {
    var _a, _b, _c;
    const rootStyles = react.mergeStyles(drawerSurfaceStyles, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root);
    return React__default['default'].createElement(react.Stack, { className: rootStyles },
        React__default['default'].createElement(DrawerLightDismiss, { styles: (_b = props.styles) === null || _b === void 0 ? void 0 : _b.lightDismissRoot, onDismiss: props.onLightDismiss }),
        React__default['default'].createElement(react.FocusTrapZone, { onKeyDown: e => {
                if (e.key === 'Escape' || e.key === 'Esc') {
                    props.onLightDismiss && props.onLightDismiss();
                }
            }, 
            // Note: this still correctly captures keyboard focus, this just allows mouse click outside of the focus trap.
            isClickableOutsideFocusTrap: true },
            React__default['default'].createElement(DrawerContentContainer, { styles: (_c = props.styles) === null || _c === void 0 ? void 0 : _c.drawerContentContainer }, props.children)));
};
const drawerSurfaceStyles = {
    width: '100%',
    height: '100%',
    background: 'rgba(0,0,0,0.4)'
};

// Copyright (c) Microsoft Corporation.
/**
 * Takes a set of menu items and returns a created menu inside a {@link _DrawerSurface}.
 *
 * @internal
 */
const _DrawerMenu = (props) => {
    var _a, _b;
    // This component breaks from a pure component pattern in order to internally support sub menus.
    // When a sub menu item is clicked the menu items displayed is updated to be that of the submenu.
    // To track this state we store a list of the keys clicked up until this point.
    const [selectedKeyPath, setSelectedKeyPath] = React.useState([]); // Get the menu items that should be rendered
    const menuItemsToRender = React.useMemo(() => {
        var _a;
        let items = props.items;
        for (const subMenuKey of selectedKeyPath) {
            items = (_a = items === null || items === void 0 ? void 0 : items.find(item => item.itemKey === subMenuKey)) === null || _a === void 0 ? void 0 : _a.subMenuProps;
        }
        return items;
    }, [props.items, selectedKeyPath]); // When an item is clicked and it contains a submenu, push the key for the submenu. This will ensure
    // a new render is triggered, menuItemsToRender will be re-calculated and the submenu will render.
    const onItemClick = React.useCallback((item, ev, itemKey) => {
        var _a;
        if (item.subMenuProps) {
            setSelectedKeyPath([...selectedKeyPath, item.itemKey]);
        }
        (_a = item.onItemClick) === null || _a === void 0 ? void 0 : _a.call(item, ev, itemKey);
    }, [selectedKeyPath]); // Ensure the first item has a border radius that matches the DrawerSurface
    const borderRadius = useTheme().effects.roundedCorner4;
    const firstItemStyle = menuItemsToRender && ((_a = menuItemsToRender[0]) === null || _a === void 0 ? void 0 : _a.styles);
    const modifiedFirstItemStyle = React.useMemo(() => react.merge(firstItemStyle !== null && firstItemStyle !== void 0 ? firstItemStyle : {}, {
        root: {
            borderTopRightRadius: borderRadius,
            borderTopLeftRadius: borderRadius
        }
    }), [firstItemStyle, borderRadius]);
    return React__default['default'].createElement(_DrawerSurface, { styles: (_b = props.styles) === null || _b === void 0 ? void 0 : _b.drawerSurfaceStyles, onLightDismiss: props.onLightDismiss },
        React__default['default'].createElement(react.Stack, { styles: props.styles, role: "menu", "data-ui-id": "drawer-menu" }, menuItemsToRender === null || menuItemsToRender === void 0 ? void 0 :
            menuItemsToRender.slice(0, 1).map(item => React__default['default'].createElement(DrawerMenuItem, Object.assign({}, item, { key: '0', styles: modifiedFirstItemStyle, onItemClick: (ev, itemKey) => {
                    onItemClick(item, ev, itemKey);
                } }))), menuItemsToRender === null || menuItemsToRender === void 0 ? void 0 :
            menuItemsToRender.slice(1).map((item, i) => React__default['default'].createElement(DrawerMenuItem, Object.assign({}, item, { key: `${i + 1}`, onItemClick: (ev, itemKey) => {
                    onItemClick(item, ev, itemKey);
                } })))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Return different conditions based on the current and previous state of recording and transcribing
 *
 * @param callRecordState - The current call record state: on, off, stopped
 * @param callTranscribeState - The current call transcribe state: on, off, stopped
 *
 * @remarks - The stopped state means: previously on but currently off
 *
 * @private
 */
const computeVariant = (callRecordState, callTranscribeState) => {
    if (callRecordState === 'on' && callTranscribeState === 'on') {
        return 'RECORDING_AND_TRANSCRIPTION_STARTED';
    }
    else if (callRecordState === 'on' && callTranscribeState === 'off') {
        return 'RECORDING_STARTED';
    }
    else if (callRecordState === 'off' && callTranscribeState === 'on') {
        return 'TRANSCRIPTION_STARTED';
    }
    else if (callRecordState === 'on' && callTranscribeState === 'stopped') {
        return 'TRANSCRIPTION_STOPPED_STILL_RECORDING';
    }
    else if (callRecordState === 'stopped' && callTranscribeState === 'on') {
        return 'RECORDING_STOPPED_STILL_TRANSCRIBING';
    }
    else if (callRecordState === 'off' && callTranscribeState === 'stopped') {
        return 'TRANSCRIPTION_STOPPED';
    }
    else if (callRecordState === 'stopped' && callTranscribeState === 'off') {
        return 'RECORDING_STOPPED';
    }
    else if (callRecordState === 'stopped' && callTranscribeState === 'stopped') {
        return 'RECORDING_AND_TRANSCRIPTION_STOPPED';
    }
    else {
        return 'NO_STATE';
    }
};

// Copyright (c) Microsoft Corporation.
/** @private */
function BannerMessage(props) {
    const { variant, strings } = props;
    switch (variant) {
        case 'TRANSCRIPTION_STOPPED_STILL_RECORDING':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerTranscriptionStopped),
                ` ${strings.complianceBannerNowOnlyRecording}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'RECORDING_STOPPED_STILL_TRANSCRIBING':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingStopped),
                ` ${strings.complianceBannerNowOnlyTranscription}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'RECORDING_AND_TRANSCRIPTION_STOPPED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingAndTranscriptionSaved),
                ` ${strings.complianceBannerRecordingAndTranscriptionStopped}`,
                React__default['default'].createElement(LearnMore, { linkText: strings.learnMore }));
        case 'RECORDING_AND_TRANSCRIPTION_STARTED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingAndTranscriptionStarted),
                ` ${strings.complianceBannerTranscriptionConsent}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'TRANSCRIPTION_STARTED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerTranscriptionStarted),
                ` ${strings.complianceBannerTranscriptionConsent}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'RECORDING_STOPPED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingSaving),
                ` ${strings.complianceBannerRecordingStopped}`,
                React__default['default'].createElement(LearnMore, { linkText: strings.learnMore }));
        case 'RECORDING_STARTED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingStarted),
                ` ${strings.complianceBannerTranscriptionConsent}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'TRANSCRIPTION_STOPPED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerTranscriptionSaving),
                ` ${strings.complianceBannerTranscriptionStopped}`,
                React__default['default'].createElement(LearnMore, { linkText: strings.learnMore }));
    }
    return React__default['default'].createElement(React__default['default'].Fragment, null);
}
function PrivacyPolicy(props) {
    return React__default['default'].createElement(react.Link, { href: "https://privacy.microsoft.com/privacystatement#mainnoticetoendusersmodule", target: "_blank", underline: true }, props.linkText);
}
function LearnMore(props) {
    return React__default['default'].createElement(react.Link, { href: "https://support.microsoft.com/office/record-a-meeting-in-teams-34dfbe7f-b07d-4a27-b4c6-de62f1348c24", target: "_blank", underline: true }, props.linkText);
}

// Copyright (c) Microsoft Corporation.
const BANNER_OVERWRITE_DELAY_MS = 3000;
/**
 * Shows a {@link BannerMessage} in a {@link MessageBar} tracking `variant` internally.
 *
 * This component delays and combines frequent updates to `variant` such that:
 * - Updates that happen within {@link BANNER_OVERWRITE_DELAY_MS} are delayed.
 * - Once {@link BANNER_OVERWRITE_DELAY_MS} has passed since the last update, the _latest_ pending update is shown.
 *
 * This ensures that there is enough time for the user to see a banner message before it is overwritten.
 * In case of multiple delayed messages, the user always sees the final message as it reflects the final state
 * of recording and transcription.
 *
 * @private
 */
function DelayedUpdateBanner(props) {
    const { variant, lastUpdated: variantLastUpdated } = props.variant; // Tracks the variant that is currently visible in the UI.
    const [visible, setVisible] = React.useState({
        variant,
        lastUpdated: Date.now()
    });
    const pendingUpdateHandle = React.useRef(null);
    if (variant !== visible.variant && variantLastUpdated > visible.lastUpdated) {
        // Always clear pending updates.
        // We'll either update now, or schedule an update for later.
        if (pendingUpdateHandle.current) {
            clearTimeout(pendingUpdateHandle.current);
        }
        const now = Date.now();
        const timeToNextUpdate = BANNER_OVERWRITE_DELAY_MS - (now - visible.lastUpdated);
        if (variant === 'NO_STATE' || timeToNextUpdate <= 0) {
            setVisible({
                variant,
                lastUpdated: now
            });
        }
        else {
            pendingUpdateHandle.current = setTimeout(() => {
                // Set the actual update time, not the computed time when the update should happen.
                // The actual update might be later than we planned.
                setVisible({
                    variant,
                    lastUpdated: Date.now()
                });
            }, timeToNextUpdate);
        }
    }
    if (visible.variant === 'NO_STATE') {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return React__default['default'].createElement(react.MessageBar, { messageBarType: react.MessageBarType.warning, onDismiss: () => {
            // when closing the banner, change variant to nostate and change stopped state to off state.
            // Reason: on banner close, going back to the default state.
            setVisible({
                variant: 'NO_STATE',
                lastUpdated: Date.now()
            });
            props.onDismiss();
        }, dismissButtonAriaLabel: props.strings.close },
        React__default['default'].createElement(BannerMessage, { variant: visible.variant, strings: props.strings }));
}

// Copyright (c) Microsoft Corporation.
/**
 * A component that displays banners to notify the user when call recording and
 * transcription is enabled or disabled in a call.
 *
 * This component implements a state machine that tracks the changes to call
 * recording and transcription state and shows the corresponding message.
 *
 * @internal
 */
const _ComplianceBanner = (props) => {
    const cachedProps = React.useRef({
        latestBooleanState: {
            callTranscribeState: false,
            callRecordState: false
        },
        latestStringState: {
            callTranscribeState: 'off',
            callRecordState: 'off'
        },
        lastUpdated: Date.now()
    }); // Only update cached props and variant if there is _some_ change in the latest props.
    // This ensures that state machine is only updated if there is an actual change in the props.
    const shouldUpdateCached = props.callRecordState !== cachedProps.current.latestBooleanState.callRecordState || props.callTranscribeState !== cachedProps.current.latestBooleanState.callTranscribeState; // The following three operations must be performed in this exact order:
    // [1]: Update cached state to transition the state machine.
    if (shouldUpdateCached) {
        cachedProps.current = {
            latestBooleanState: props,
            latestStringState: {
                callRecordState: determineStates(cachedProps.current.latestStringState.callRecordState, props.callRecordState),
                callTranscribeState: determineStates(cachedProps.current.latestStringState.callTranscribeState, props.callTranscribeState)
            },
            lastUpdated: Date.now()
        };
    } // [2]: Compute the variant, using the transitioned state machine.
    const variant = computeVariant(cachedProps.current.latestStringState.callRecordState, cachedProps.current.latestStringState.callTranscribeState); // [3]: Transition the state machine again to deal with some end-states.
    if (shouldUpdateCached && cachedProps.current.latestStringState.callRecordState === 'stopped' && cachedProps.current.latestStringState.callTranscribeState === 'stopped') {
        // When both states are stopped, after displaying message "RECORDING_AND_TRANSCRIPTION_STOPPED", change both states to off (going back to the default state).
        cachedProps.current.latestStringState.callRecordState = 'off';
        cachedProps.current.latestStringState.callTranscribeState = 'off';
    }
    return React__default['default'].createElement(DelayedUpdateBanner, { variant: {
            variant,
            lastUpdated: cachedProps.current.lastUpdated
        }, strings: props.strings, onDismiss: () => {
            if (cachedProps.current.latestStringState.callRecordState === 'stopped') {
                cachedProps.current.latestStringState.callRecordState = 'off';
            }
            if (cachedProps.current.latestStringState.callTranscribeState === 'stopped') {
                cachedProps.current.latestStringState.callTranscribeState = 'off';
            }
        } });
};
function determineStates(previous, current) {
    // if current state is on, then return on
    if (current) {
        return 'on';
    } // if current state is off
    else {
        // if previous state is on and current state is off, return stopped (on -> off)
        if (previous === 'on') {
            return 'stopped';
        } // otherwise remain previous state unchanged
        else {
            return previous;
        }
    }
}

(window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

/**
 * @private
 */
const checkIsSpeaking = (participant) => participant.isSpeaking && !participant.isMuted;

/** @internal */
const _dominantSpeakersWithFlatId = (dominantSpeakers) => {
    var _a;
    return (_a = dominantSpeakers === null || dominantSpeakers === void 0 ? void 0 : dominantSpeakers.speakersList) === null || _a === void 0 ? void 0 : _a.map(toFlatCommunicationIdentifier);
};
/** @internal */
const _videoGalleryRemoteParticipantsMemo = (remoteParticipants) => {
    if (!remoteParticipants) {
        return [];
    }
    return memoizedAllConvertRemoteParticipant(memoizedFn => {
        return Object.values(remoteParticipants).filter((participant) => {
            return participant.state !== 'InLobby';
        }).map((participant) => {
            return memoizedFn(toFlatCommunicationIdentifier(participant.identifier), participant.isMuted, checkIsSpeaking(participant), participant.videoStreams, participant.state, participant.displayName);
        });
    });
};
const memoizedAllConvertRemoteParticipant = memoizeFnAll((userId, isMuted, isSpeaking, videoStreams, state, displayName) => {
    return convertRemoteParticipantToVideoGalleryRemoteParticipant(userId, isMuted, isSpeaking, videoStreams, state, displayName);
});
/** @private */
const convertRemoteParticipantToVideoGalleryRemoteParticipant = (userId, isMuted, isSpeaking, videoStreams, state, displayName) => {
    const rawVideoStreamsArray = Object.values(videoStreams);
    let videoStream = undefined;
    let screenShareStream = undefined;
    if (rawVideoStreamsArray[0]) {
        if (rawVideoStreamsArray[0].mediaStreamType === 'Video') {
            videoStream = convertRemoteVideoStreamToVideoGalleryStream(rawVideoStreamsArray[0]);
        }
        else {
            screenShareStream = convertRemoteVideoStreamToVideoGalleryStream(rawVideoStreamsArray[0]);
        }
    }
    if (rawVideoStreamsArray[1]) {
        if (rawVideoStreamsArray[1].mediaStreamType === 'ScreenSharing') {
            screenShareStream = convertRemoteVideoStreamToVideoGalleryStream(rawVideoStreamsArray[1]);
        }
        else {
            videoStream = convertRemoteVideoStreamToVideoGalleryStream(rawVideoStreamsArray[1]);
        }
    }
    return {
        userId,
        displayName,
        isMuted,
        isSpeaking,
        videoStream,
        screenShareStream,
        isScreenSharingOn: screenShareStream !== undefined && screenShareStream.isAvailable
    };
};
const convertRemoteVideoStreamToVideoGalleryStream = (stream) => {
    var _a, _b;
    return {
        id: stream.id,
        isAvailable: stream.isAvailable,
        isMirrored: (_a = stream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
        renderElement: (_b = stream.view) === null || _b === void 0 ? void 0 : _b.target
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * Provides data attributes to {@link VideoGallery} component.
 * @public
 */
const videoGallerySelector = reselect.createSelector([getScreenShareRemoteParticipant, getRemoteParticipants$1, getLocalVideoStreams$1, getIsMuted, getIsScreenSharingOn, getDisplayName$2, getIdentifier, getDominantSpeakers], (screenShareRemoteParticipantId, remoteParticipants, localVideoStreams, isMuted, isScreenSharingOn, displayName, identifier, dominantSpeakers) => {
    var _a, _b;
    const screenShareRemoteParticipant = screenShareRemoteParticipantId && remoteParticipants ? remoteParticipants[screenShareRemoteParticipantId] : undefined;
    const localVideoStream = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(i => i.mediaStreamType === 'Video');
    const dominantSpeakerIds = _dominantSpeakersWithFlatId(dominantSpeakers);
    dominantSpeakerIds === null || dominantSpeakerIds === void 0 ? void 0 : dominantSpeakerIds.forEach((speaker, idx) => idx);
    const noRemoteParticipants = [];
    return {
        screenShareParticipant: screenShareRemoteParticipant ? convertRemoteParticipantToVideoGalleryRemoteParticipant(toFlatCommunicationIdentifier(screenShareRemoteParticipant.identifier), screenShareRemoteParticipant.isMuted, checkIsSpeaking(screenShareRemoteParticipant), screenShareRemoteParticipant.videoStreams, screenShareRemoteParticipant.state, screenShareRemoteParticipant.displayName) : undefined,
        localParticipant: {
            userId: identifier,
            displayName: displayName !== null && displayName !== void 0 ? displayName : '',
            isMuted: isMuted,
            isScreenSharingOn: isScreenSharingOn,
            videoStream: {
                isAvailable: !!localVideoStream,
                isMirrored: (_a = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
                renderElement: (_b = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _b === void 0 ? void 0 : _b.target
            }
        },
        remoteParticipants: _videoGalleryRemoteParticipantsMemo(updateUserDisplayNamesTrampoline$2(remoteParticipants ? Object.values(remoteParticipants) : noRemoteParticipants)),
        dominantSpeakers: dominantSpeakerIds
    };
});
const updateUserDisplayNamesTrampoline$2 = (remoteParticipants) => {
    return remoteParticipants;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const memoizedConvertAllremoteParticipants = memoizeFnAll((userId, displayName, state, isMuted, isScreenSharing, isSpeaking) => {
    return convertRemoteParticipantToParticipantListParticipant(userId, displayName, state, isMuted, isScreenSharing, isSpeaking);
});
const convertRemoteParticipantToParticipantListParticipant = (userId, displayName, state, isMuted, isScreenSharing, isSpeaking) => {
    const identifier = fromFlatCommunicationIdentifier(userId);
    return {
        userId,
        displayName,
        state,
        isMuted,
        isScreenSharing,
        isSpeaking,
        // ACS users can not remove Teams users.
        // Removing unknown types of users is undefined.
        isRemovable: communicationCommon.getIdentifierKind(identifier).kind === 'communicationUser' || communicationCommon.getIdentifierKind(identifier).kind === 'phoneNumber'
    };
};

const convertRemoteParticipantsToParticipantListParticipants = (remoteParticipants) => {
    return memoizedConvertAllremoteParticipants(memoizeFn => {
        return remoteParticipants // temporarily hiding lobby participants in ACS clients till we can admit users through ACS clients
            .filter((participant) => {
            return participant.state !== 'InLobby';
        }).map((participant) => {
            const isScreenSharing = Object.values(participant.videoStreams).some(videoStream => videoStream.mediaStreamType === 'ScreenSharing' && videoStream.isAvailable);
            return memoizeFn(toFlatCommunicationIdentifier(participant.identifier), participant.displayName, participant.state, participant.isMuted, isScreenSharing, participant.isSpeaking);
        }).sort((a, b) => {
            var _a, _b;
            const nameA = ((_a = a.displayName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || '';
            const nameB = ((_b = b.displayName) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || '';
            if (nameA < nameB) {
                return -1;
            }
            else if (nameA > nameB) {
                return 1;
            }
            else {
                return 0;
            }
        });
    });
};
/**
 * Selects data that drives {@link ParticipantList} component.
 *
 * @public
 */
const participantListSelector = reselect.createSelector([getIdentifier, getDisplayName$2, getRemoteParticipants$1, getIsScreenSharingOn, getIsMuted], (userId, displayName, remoteParticipants, isScreenSharingOn, isMuted) => {
    const participants = remoteParticipants ? convertRemoteParticipantsToParticipantListParticipants(updateUserDisplayNamesTrampoline$1(Object.values(remoteParticipants))) : [];
    participants.push({
        userId: userId,
        displayName: displayName,
        isScreenSharing: isScreenSharingOn,
        isMuted: isMuted,
        state: 'Connected',
        // Local participant can never remove themselves.
        isRemovable: false
    });
    return {
        participants: participants,
        myUserId: userId
    };
});
const updateUserDisplayNamesTrampoline$1 = (remoteParticipants) => {
    return remoteParticipants;
};

/**
 * Selects data that drives {@link ParticipantsButton} component.
 *
 * @public
 */
const participantsButtonSelector = reselect.createSelector([participantListSelector], (participantListProps) => {
    return participantListProps;
});

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a handler for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers$3 = (component) => {
    var _a;
    const callClient = (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.callClient;
    const callAgent = useCallAgent();
    const deviceManager = useDeviceManager();
    const call = useCall();
    if (!callClient) {
        return undefined;
    }
    return createDefaultCallingHandlersForComponent(callClient, callAgent, deviceManager, call);
};

/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector$3 = (selector, selectorProps) => {
    var _a, _b;
    const callClient = (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.callClient;
    const callId = (_b = useCall()) === null || _b === void 0 ? void 0 : _b.id; // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const callIdConfigProps = React.useMemo(() => ({
        callId
    }), [callId]);
    const [props, setProps] = React.useState(callClient && selector ? selector(callClient.getState(), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callIdConfigProps) : undefined);
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        if (!callClient || !selector) {
            return;
        }
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(state, selectorProps !== null && selectorProps !== void 0 ? selectorProps : callIdConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        callClient.onStateChange(onStateChange);
        return () => {
            callClient.offStateChange(onStateChange);
        };
    }, [callClient, selector, selectorProps, callIdConfigProps, mounted]);
    return selector ? props : undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * Select the first 3 active errors from the state for the `ErrorBar` component.
 *
 * In case there are many errors, only the first three errors are returned to avoid
 * filling up the UI with too many errors.
 *
 * Invariants:
 *   - `ErrorType` is never repeated in the returned errors.
 *   - Errors are returned in a fixed order by `ErrorType`.
 *
 * @public
 */
const errorBarSelector$1 = reselect.createSelector([getLatestErrors$1, getDiagnostics, getDeviceManager$1], (latestErrors, diagnostics, deviceManager) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    // The order in which the errors are returned is significant: The `ErrorBar` shows errors on the UI in that order.
    // There are several options for the ordering:
    //   - Sorted by when the errors happened (latest first / oldest first).
    //   - Stable sort by error type.
    //
    // We chose to stable sort by error type: We intend to show only a small number of errors on the UI and we do not
    // have timestamps for errors.
    const activeErrorMessages = []; // Errors reported via diagnostics are more reliable than from API method failures, so process those first.
    if (((_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _a === void 0 ? void 0 : _a.value) === communicationCalling.DiagnosticQuality.Bad || ((_b = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _b === void 0 ? void 0 : _b.value) === communicationCalling.DiagnosticQuality.Poor) {
        activeErrorMessages.push({
            type: 'callNetworkQualityLow'
        });
    }
    if (((_c = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noSpeakerDevicesEnumerated) === null || _c === void 0 ? void 0 : _c.value) === true) {
        activeErrorMessages.push({
            type: 'callNoSpeakerFound'
        });
    }
    if (((_d = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noMicrophoneDevicesEnumerated) === null || _d === void 0 ? void 0 : _d.value) === true) {
        activeErrorMessages.push({
            type: 'callNoMicrophoneFound'
        });
    }
    if (((_e = deviceManager.deviceAccess) === null || _e === void 0 ? void 0 : _e.audio) === false) {
        activeErrorMessages.push({
            type: 'callMicrophoneAccessDenied'
        });
    }
    if (((_f = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphonePermissionDenied) === null || _f === void 0 ? void 0 : _f.value) === true) {
        activeErrorMessages.push({
            type: 'callMacOsMicrophoneAccessDenied'
        });
    }
    const microphoneMuteUnexpectedlyDiagnostic = (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneMuteUnexpectedly) || (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneNotFunctioning);
    if (microphoneMuteUnexpectedlyDiagnostic) {
        if (microphoneMuteUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Bad) {
            // Inform the user that microphone stopped working and inform them to start microphone again
            activeErrorMessages.push({
                type: 'callMicrophoneMutedBySystem'
            });
        }
        else if (microphoneMuteUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Good) {
            // Inform the user that microphone recovered
            activeErrorMessages.push({
                type: 'callMicrophoneUnmutedBySystem'
            });
        }
    }
    const cameraStoppedUnexpectedlyDiagnostic = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraStoppedUnexpectedly;
    if (cameraStoppedUnexpectedlyDiagnostic) {
        if (cameraStoppedUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Bad) {
            // Inform the user that camera stopped working and inform them to start video again
            activeErrorMessages.push({
                type: 'callVideoStoppedBySystem'
            });
        }
        else if (cameraStoppedUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Good) {
            // Inform the user that camera recovered
            activeErrorMessages.push({
                type: 'callVideoRecoveredBySystem'
            });
        }
    }
    if (((_g = deviceManager.deviceAccess) === null || _g === void 0 ? void 0 : _g.video) === false) {
        activeErrorMessages.push({
            type: 'callCameraAccessDenied'
        });
    }
    else {
        if (((_h = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraFreeze) === null || _h === void 0 ? void 0 : _h.value) === true) {
            activeErrorMessages.push({
                type: 'callCameraAlreadyInUse'
            });
        }
    }
    if (((_j = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraPermissionDenied) === null || _j === void 0 ? void 0 : _j.value) === true) {
        activeErrorMessages.push({
            type: 'callMacOsCameraAccessDenied'
        });
    }
    if (((_k = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.screenshareRecordingDisabled) === null || _k === void 0 ? void 0 : _k.value) === true) {
        activeErrorMessages.push({
            type: 'callMacOsScreenShareAccessDenied'
        });
    } // Prefer to show errors with privacy implications.
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopVideo', 'stopVideoGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.mute', 'muteGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopScreenSharing', 'stopScreenShareGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.startVideo', 'startVideoGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.unmute', 'unmuteGeneric');
    if (((_l = latestErrors['CallAgent.join']) === null || _l === void 0 ? void 0 : _l.message) === 'CallAgent.join: Invalid meeting link') {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'CallAgent.join', 'failedToJoinCallInvalidMeetingLink');
    }
    else {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'CallAgent.join', 'failedToJoinCallGeneric');
    } // We only return the first few errors to avoid filling up the UI with too many `MessageBar`s.
    activeErrorMessages.splice(maxErrorCount$1);
    return {
        activeErrorMessages: activeErrorMessages
    };
});
const appendActiveErrorIfDefined = (activeErrorMessages, latestErrors, target, activeErrorType) => {
    if (latestErrors[target] === undefined) {
        return;
    }
    activeErrorMessages.push({
        type: activeErrorType,
        timestamp: latestErrors[target].timestamp
    });
};
const maxErrorCount$1 = 3;

// Copyright (c) Microsoft Corporation.
const emptySelector = () => ({});
/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
const getSelector$1 = (component) => {
    return findSelector$1(component);
};
const findSelector$1 = (component) => {
    switch (component) {
        case VideoGallery:
            return videoGallerySelector;
        case MicrophoneButton:
            return microphoneButtonSelector;
        case CameraButton:
            return cameraButtonSelector;
        case ScreenShareButton:
            return screenShareButtonSelector;
        case DevicesButton:
            return devicesButtonSelector;
        case ParticipantList:
            return participantListSelector;
        case ParticipantsButton:
            return participantsButtonSelector;
        case EndCallButton:
            return emptySelector;
        case ErrorBar:
            return errorBarSelector$1;
    }
    return undefined;
};

var __awaiter$n = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create the default implementation of {@link ChatHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * Returned object is memoized to avoid rerenders when used as props for React Components.
 *
 * @public
 */
const createDefaultChatHandlers = memoizeOne__default['default']((chatClient, chatThreadClient) => {
    let messageIterator = undefined;
    let readReceiptIterator = undefined;
    return {
        onSendMessage: (content, options) => __awaiter$n(void 0, void 0, void 0, function* () {
            const sendMessageRequest = {
                content,
                senderDisplayName: chatClient.getState().displayName
            };
            yield chatThreadClient.sendMessage(sendMessageRequest, options);
        }),
        onUpdateMessage: (messageId, content, metadata, options) => __awaiter$n(void 0, void 0, void 0, function* () {
            const updatedMetadata = metadata ? Object.assign({}, metadata) : {};
            updatedMetadata['fileSharingMetadata'] = JSON.stringify((options === null || options === void 0 ? void 0 : options.attachedFilesMetadata) || []);
            yield chatThreadClient.updateMessage(messageId, {
                content,
                metadata: updatedMetadata
            });
        }),
        onDeleteMessage: (messageId) => __awaiter$n(void 0, void 0, void 0, function* () {
            yield chatThreadClient.deleteMessage(messageId);
        }),
        // This handler is designed for chatThread to consume
        onMessageSeen: (chatMessageId) => __awaiter$n(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendReadReceipt({
                chatMessageId
            });
        }),
        onTyping: () => __awaiter$n(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendTypingNotification();
        }),
        onRemoveParticipant: (userId) => __awaiter$n(void 0, void 0, void 0, function* () {
            yield chatThreadClient.removeParticipant(fromFlatCommunicationIdentifier(userId));
        }),
        updateThreadTopicName: (topicName) => __awaiter$n(void 0, void 0, void 0, function* () {
            yield chatThreadClient.updateTopic(topicName);
        }),
        onLoadPreviousChatMessages: (messagesToLoad) => __awaiter$n(void 0, void 0, void 0, function* () {
            var _a, _b, _c;
            if (messageIterator === undefined) {
                // Lazy definition so that errors in the method call are reported correctly.
                // Also allows recovery via retries in case of transient errors.
                messageIterator = chatThreadClient.listMessages({
                    maxPageSize: 50
                });
            }
            if (readReceiptIterator === undefined) {
                readReceiptIterator = chatThreadClient.listReadReceipts();
            } // get the earliest message time
            let remainingMessagesToGet = messagesToLoad;
            let isAllChatMessagesLoaded = false;
            let earliestTime = Number.MAX_SAFE_INTEGER;
            while (remainingMessagesToGet >= 1) {
                const message = yield messageIterator.next();
                if ((_a = message === null || message === void 0 ? void 0 : message.value) === null || _a === void 0 ? void 0 : _a.id) {
                    if (parseInt(message.value.id) < earliestTime) {
                        earliestTime = parseInt(message.value.id);
                    }
                }
                if (((_b = message.value) === null || _b === void 0 ? void 0 : _b.type) && message.value.type === 'text') {
                    remainingMessagesToGet--;
                } // We have traversed all messages in this thread
                if (message.done) {
                    isAllChatMessagesLoaded = true;
                    break;
                }
            } // keep fetching read receipts until read receipt time < earlist message time
            let readReceipt = yield readReceiptIterator.next();
            while (!readReceipt.done && parseInt((_c = readReceipt === null || readReceipt === void 0 ? void 0 : readReceipt.value) === null || _c === void 0 ? void 0 : _c.chatMessageId) >= earliestTime) {
                readReceipt = yield readReceiptIterator.next();
            }
            return isAllChatMessagesLoaded;
        })
    };
});
/**
 * Create a set of default handlers for given component.
 *
 * Returned object is memoized (with reference to the arguments) to avoid
 * renders when used as props for React Components.
 *
 * @public
 */
const createDefaultChatHandlersForComponent = (chatClient, chatThreadClient, _) => {
    return createDefaultChatHandlers(chatClient, chatThreadClient);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatClientContext = React.createContext(undefined);
/**
 * A {@link React.Context} that stores a {@link StatefulChatClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatClientProvider}.
 *
 * @public
 */
const ChatClientProvider = (props) => {
    return React__default['default'].createElement(ChatClientContext.Provider, { value: props.chatClient }, props.children);
};
/**
 * Hook to obtain {@link StatefulChatClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useChatClient = () => {
    const chatClient = React.useContext(ChatClientContext);
    if (!chatClient) {
        throw 'Please wrap components with ChatClientProvider and initialize a chat client before calling the hook!';
    }
    return chatClient;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatThreadClientContext = React.createContext(undefined);
/**
 * A {@link React.Context} that stores a {@link @azure/communication-chat#ChatThreadClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatThreadClientProvider}.
 *
 * @public
 */
const ChatThreadClientProvider = (props) => {
    return React__default['default'].createElement(ChatThreadClientContext.Provider, { value: props.chatThreadClient }, props.children);
};
/**
 * Hook to obtain {@link @azure/communication-chat#ChatThreadClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useChatThreadClient = () => {
    const chatThreadClient = React.useContext(ChatThreadClientContext);
    if (!chatThreadClient) {
        throw 'Please wrap components with ChatThreadClientProvider and initialize a chat thread client before calling the hook.';
    }
    return chatThreadClient;
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a handler for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useHandlers$2 = (component) => {
    const chatClient = React.useContext(ChatClientContext);
    const chatThreadClient = React.useContext(ChatThreadClientContext);
    if (!chatThreadClient || !chatClient) {
        return undefined;
    }
    return createDefaultChatHandlersForComponent(chatClient, chatThreadClient);
};

/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector$2 = (selector, selectorProps) => {
    var _a;
    const chatClient = React.useContext(ChatClientContext);
    const threadId = (_a = React.useContext(ChatThreadClientContext)) === null || _a === void 0 ? void 0 : _a.threadId; // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const threadConfigProps = React.useMemo(() => ({
        threadId
    }), [threadId]);
    const [props, setProps] = React.useState(chatClient && selector ? selector(chatClient.getState(), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps) : undefined);
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        if (!chatClient || !selector) {
            return;
        }
        const onStateChange = (state) => {
            const newProps = selector(state, selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        chatClient.onStateChange(onStateChange);
        return () => {
            chatClient.offStateChange(onStateChange);
        };
    }, [chatClient, selector, selectorProps, threadConfigProps]);
    return selector ? props : undefined;
};

/**
 * @private
 */
const getUserId = (state) => toFlatCommunicationIdentifier(state.userId);
/**
 * @private
 */
const getDisplayName$1 = (state) => state.displayName;
/**
 * @private
 */
const getChatMessages = (state, props) => { var _a; return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages) || {}; };
/**
 * @private
 */
const getParticipants = (state, props) => { var _a; return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.participants) || {}; };
/**
 * @private
 */
const getReadReceipts = (state, props) => {
    var _a;
    return (_a = state.threads[props === null || props === void 0 ? void 0 : props.threadId]) === null || _a === void 0 ? void 0 : _a.readReceipts;
};
/**
 * @private
 */
const getIsLargeGroup = (state, props) => {
    var _a;
    const participants = (_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.participants;
    return !!participants && Object.values(participants).length > 20;
};
/**
 * @private
 */
const getLatestReadTime = (state, props) => { var _a; return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.latestReadTime) || new Date(0); };
/**
 * @private
 */
const getTypingIndicators = (state, props) => {
    var _a;
    return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.typingIndicators) || [];
};
/**
 * @private
 */
const getLatestErrors = (state) => state.latestErrors;

/**
 * Selector for {@link SendBox} component.
 *
 * @public
 */
const sendBoxSelector = reselect.createSelector([getUserId, getDisplayName$1], (userId, displayName) => ({
    displayName: displayName,
    userId: userId
}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const MINIMUM_TYPING_INTERVAL_IN_MILLISECONDS = 8000;
/**
 * @private
 */
const PARTICIPANTS_THRESHOLD = 20;
/**
 * @private
 */
const MINUTE_IN_MS = 1000 * 60;
/**
 * @private
 *
 * TODO: Import enum from @azure/communication-chat when ChatMessageType shows up in new release version
 * (or define our type to decouple)
 */
const ACSKnownMessageType = {
    text: 'text',
    html: 'html',
    richtextHtml: 'richtext/html',
    topicUpdated: 'topicUpdated',
    participantAdded: 'participantAdded',
    participantRemoved: 'participantRemoved'
};

/**
 * @private
 */
const compareMessages = (firstMessage, secondMessage) => {
    if (firstMessage.createdOn === undefined) {
        return 1;
    }
    if (secondMessage.createdOn === undefined) {
        return -1;
    }
    const firstDate = new Date(firstMessage.createdOn).getTime();
    const secondDate = new Date(secondMessage.createdOn).getTime(); // Workaround to get a stable order of message before we can get sequenceId from chat service.
    // MessageIds are generated by time order the message persist, a good candidate other than time
    const idDelta = firstMessage.messageId && secondMessage.messageId ? Number.parseInt(firstMessage.messageId) - Number.parseInt(secondMessage.messageId) : 0;
    return firstDate - secondDate === 0 ? idDelta : firstDate - secondDate;
};

/**
 * @private
 */
const updateMessagesWithAttached = (chatMessagesWithStatus) => {
    chatMessagesWithStatus.sort(compareMessages);
    chatMessagesWithStatus.forEach((message, index, messages) => {
        var _a, _b;
        if (message.messageType !== 'chat') {
            return;
        }
        /**
         * Attached === true means it is within a group of messages in the current order
         * Attached === top/bottom means it is on the top/bottom boundary
         * Attached === false means it is just a single message
         * A group of messages: continuous messages that belong to the same sender and not intercepted by other senders.
         */
        let attached = false;
        const previousMessage = index > 0 ? messages[index - 1] : undefined;
        const nextMessage = index === messages.length - 1 ? undefined : messages[index + 1];
        const previousSenderId = (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.messageType) === 'chat' ? previousMessage.senderId : undefined;
        const nextSenderId = (nextMessage === null || nextMessage === void 0 ? void 0 : nextMessage.messageType) === 'chat' ? nextMessage.senderId : undefined;
        const timediff = new Date((_a = message === null || message === void 0 ? void 0 : message.createdOn) !== null && _a !== void 0 ? _a : '').getTime() - new Date((_b = previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.createdOn) !== null && _b !== void 0 ? _b : '').getTime();
        const diffMins = Math.round(timediff / MINUTE_IN_MS); // minutes
        if (previousSenderId !== message.senderId) {
            attached = message.senderId === nextSenderId ? 'top' : false;
        }
        else if (diffMins && diffMins >= 5) {
            // if there are more than or equal to 5 mins time gap between messages do not attach and show time stamp
            attached = false;
        }
        else {
            attached = message.senderId === nextSenderId ? true : 'bottom';
        }
        message.attached = attached;
    });
};

// Copyright (c) Microsoft Corporation.
const memoizedAllConvertChatMessage = memoizeFnAll((_key, chatMessage, userId, isSeen, isLargeGroup) => {
    const messageType = chatMessage.type.toLowerCase();
    if (messageType === ACSKnownMessageType.text || messageType === ACSKnownMessageType.richtextHtml || messageType === ACSKnownMessageType.html) {
        return convertToUiChatMessage(chatMessage, userId, isSeen, isLargeGroup);
    }
    else {
        return convertToUiSystemMessage(chatMessage);
    }
});
const convertToUiChatMessage = (message, userId, isSeen, isLargeGroup) => {
    var _a;
    const messageSenderId = message.sender !== undefined ? toFlatCommunicationIdentifier(message.sender) : userId;
    return {
        messageType: 'chat',
        createdOn: message.createdOn,
        content: (_a = message.content) === null || _a === void 0 ? void 0 : _a.message,
        contentType: sanitizedMessageContentType(message.type),
        status: !isLargeGroup && message.status === 'delivered' && isSeen ? 'seen' : message.status,
        senderDisplayName: message.senderDisplayName,
        senderId: messageSenderId,
        messageId: message.id,
        clientMessageId: message.clientMessageId,
        editedOn: message.editedOn,
        deletedOn: message.deletedOn,
        mine: messageSenderId === userId,
        metadata: message.metadata
    };
};
const convertToUiSystemMessage = (message) => {
    var _a, _b, _c, _d, _e;
    const systemMessageType = message.type;
    if (systemMessageType === 'participantAdded' || systemMessageType === 'participantRemoved') {
        return {
            messageType: 'system',
            systemMessageType,
            createdOn: message.createdOn,
            participants: (_c = (_b = (_a = message.content) === null || _a === void 0 ? void 0 : _a.participants // TODO: In our moderator logic, we use undefined name as our displayName for moderator, which should be filtered out
            ) === null || _b === void 0 ? void 0 : _b.filter(participant => participant.displayName && participant.displayName !== '').map((participant) => ({
                userId: toFlatCommunicationIdentifier(participant.id),
                displayName: participant.displayName
            }))) !== null && _c !== void 0 ? _c : [],
            messageId: message.id,
            iconName: systemMessageType === 'participantAdded' ? 'PeopleAdd' : 'PeopleBlock'
        };
    }
    else {
        // Only topic updated type left, according to ACSKnown type
        return {
            messageType: 'system',
            systemMessageType: 'topicUpdated',
            createdOn: message.createdOn,
            topic: (_e = (_d = message.content) === null || _d === void 0 ? void 0 : _d.topic) !== null && _e !== void 0 ? _e : '',
            messageId: message.id,
            iconName: 'Edit'
        };
    }
};
/** Returns `true` if the message has participants and at least one participant has a display name. */
const hasValidParticipant = (chatMessage) => { var _a; return !!((_a = chatMessage.content) === null || _a === void 0 ? void 0 : _a.participants) && chatMessage.content.participants.some(p => !!p.displayName); };
/**
 * Selector for {@link MessageThread} component.
 *
 * @public
 */
const messageThreadSelector = reselect.createSelector([getUserId, getChatMessages, getLatestReadTime, getIsLargeGroup, getReadReceipts, getParticipants], (userId, chatMessages, latestReadTime, isLargeGroup, readReceipts, participants) => {
    // We can't get displayName in teams meeting interop for now, disable rr feature when it is teams interop
    const isTeamsInterop = Object.values(participants).find(p => 'microsoftTeamsUserId' in p.id) !== undefined; // get number of participants
    // filter out the non valid participants (no display name)
    // Read Receipt details will be disabled when participant count is 0
    const participantCount = isTeamsInterop ? undefined : Object.values(participants).filter(p => p.displayName && p.displayName !== '').length; // creating key value pairs of senderID: last read message information
    const readReceiptsBySenderId = {}; // readReceiptsBySenderId[senderID] gets updated everytime a new message is read by this sender
    // in this way we can make sure that we are only saving the latest read message id and read on time for each sender
    readReceipts.filter(r => r.sender && toFlatCommunicationIdentifier(r.sender) !== userId).forEach(r => {
        var _a, _b;
        readReceiptsBySenderId[toFlatCommunicationIdentifier(r.sender)] = {
            lastReadMessage: r.chatMessageId,
            displayName: (_b = (_a = participants[toFlatCommunicationIdentifier(r.sender)]) === null || _a === void 0 ? void 0 : _a.displayName) !== null && _b !== void 0 ? _b : ''
        };
    }); // A function takes parameter above and generate return value
    const convertedMessages = memoizedAllConvertChatMessage(memoizedFn => Object.values(chatMessages).filter(message => message.type.toLowerCase() === ACSKnownMessageType.text || message.type.toLowerCase() === ACSKnownMessageType.richtextHtml || message.type.toLowerCase() === ACSKnownMessageType.html || message.type === ACSKnownMessageType.participantAdded && hasValidParticipant(message) || message.type === ACSKnownMessageType.participantRemoved && hasValidParticipant(message) || // TODO: Add support for topicUpdated system messages in MessageThread component.
        // message.type === ACSKnownMessageType.topicUpdated ||
        message.clientMessageId !== undefined).filter(messagesWithContentOrFileSharingMetadata).map(message => {
        var _a;
        return memoizedFn((_a = message.id) !== null && _a !== void 0 ? _a : message.clientMessageId, message, userId, message.createdOn <= latestReadTime, isLargeGroup);
    }));
    updateMessagesWithAttached(convertedMessages);
    return {
        userId,
        showMessageStatus: !isLargeGroup,
        messages: convertedMessages,
        participantCount,
        readReceiptsBySenderId
    };
});
const sanitizedMessageContentType = (type) => {
    const lowerCaseType = type.toLowerCase();
    return lowerCaseType === 'text' || lowerCaseType === 'html' || lowerCaseType === 'richtext/html' ? lowerCaseType : 'unknown';
};
const messagesWithContentOrFileSharingMetadata = (message) => {
    var _a, _b;
    if (message.deletedOn) {
        return false;
    }
    if ((_a = message.metadata) === null || _a === void 0 ? void 0 : _a['fileSharingMetadata']) {
        return true;
    }
    return !!(message.content && ((_b = message.content) === null || _b === void 0 ? void 0 : _b.message) !== '');
};

// Copyright (c) Microsoft Corporation.
const filterTypingIndicators = (typingIndicators, userId) => {
    const filteredTypingIndicators = [];
    const seen = new Set();
    const date8SecondsAgo = new Date(Date.now() - MINIMUM_TYPING_INTERVAL_IN_MILLISECONDS);
    for (let i = typingIndicators.length - 1; i >= 0; i--) {
        const typingIndicator = typingIndicators[i];
        if (toFlatCommunicationIdentifier(typingIndicator.sender) === userId) {
            continue;
        }
        if (typingIndicator.receivedOn < date8SecondsAgo) {
            continue;
        }
        if (seen.has(toFlatCommunicationIdentifier(typingIndicator.sender))) {
            continue;
        }
        seen.add(toFlatCommunicationIdentifier(typingIndicator.sender));
        filteredTypingIndicators.push(typingIndicator);
    }
    return filteredTypingIndicators;
};
const convertSdkTypingIndicatorsToCommunicationParticipants = (typingIndicators, participants) => {
    return typingIndicators.map(typingIndicator => {
        var _a;
        return ({
            userId: toFlatCommunicationIdentifier(typingIndicator.sender),
            displayName: (_a = participants[toFlatCommunicationIdentifier(typingIndicator.sender)]) === null || _a === void 0 ? void 0 : _a.displayName
        });
    });
};
/**
 * Selector for {@link TypingIndicator} component.
 *
 * @public
 */
const typingIndicatorSelector = reselect.createSelector([getTypingIndicators, getParticipants, getUserId], (typingIndicators, participants, userId) => {
    // if the participant size reaches the threshold then return no typing users
    if (Object.values(participants).length >= PARTICIPANTS_THRESHOLD) {
        return {
            typingUsers: []
        };
    } // filter typing indicators to remove those that are from the duplicate users or current user as well as those older than a threshold
    const filteredTypingIndicators = filterTypingIndicators(typingIndicators, userId);
    const typingUsers = convertSdkTypingIndicatorsToCommunicationParticipants(filteredTypingIndicators, participants);
    return {
        typingUsers
    };
});

// Copyright (c) Microsoft Corporation.
const convertChatParticipantsToCommunicationParticipants = (chatParticipants) => {
    return chatParticipants.map((participant) => {
        return {
            userId: toFlatCommunicationIdentifier(participant.id),
            displayName: participant.displayName,
            // ACS users can not remove Teams users.
            // Removing phone numbers or unknown types of users is undefined.
            isRemovable: communicationCommon.getIdentifierKind(participant.id).kind === 'communicationUser'
        };
    });
};
/**
 * get the index of moderator to help updating its display name if they are the local user or removing them from list of participants otherwise
 */
const moderatorIndex = (participants) => {
    return participants.map(p => p.displayName).indexOf(undefined);
};
/**
 * Selector for {@link ParticipantList} component.
 *
 * @public
 */
const chatParticipantListSelector = reselect__namespace.createSelector([getUserId, getParticipants, getDisplayName$1], (userId, chatParticipants, displayName) => {
    let participants = convertChatParticipantsToCommunicationParticipants(Object.values(chatParticipants));
    if (0 !== participants.length) {
        const moderatorIdx = moderatorIndex(participants);
        if (-1 !== moderatorIdx) {
            const userIndex = participants.map(p => p.userId).indexOf(userId);
            if (moderatorIdx === userIndex) {
                participants[moderatorIdx].displayName = displayName;
            }
            else {
                participants = participants.filter(p => p.displayName);
            }
        }
    }
    return {
        myUserId: userId,
        participants: participants
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * Select the first fiew active errors from the state for the {@link ErrorBar} component.
 *
 * In case there are many errors, only a few top errors are returned to avoid
 * filling up the UI with too many errors.
 *
 * Invariants:
 *   - {@link ErrorType} is never repeated in the returned errors.
 *   - Errors are returned in a fixed order by {@link ErrorType}.
 *
 * @public
 */
const errorBarSelector = reselect.createSelector([getLatestErrors], (latestErrors) => {
    var _a;
    // The order in which the errors are returned is significant: The `ErrorBar` shows errors on the UI in that order.
    // There are several options for the ordering:
    //   - Sorted by when the errors happened (latest first / oldest first).
    //   - Stable sort by error type.
    //
    // We chose to stable sort by error type: We intend to show only a small number of errors on the UI and we do not
    // have timestamps for errors.
    const activeErrorMessages = [];
    let specificSendMessageErrorSeen = false;
    {
        const error = latestUnableToReachChatServiceError(latestErrors);
        if (error !== undefined) {
            activeErrorMessages.push(error);
        }
    }
    {
        const error = latestAccessDeniedError(latestErrors);
        if (error !== undefined) {
            activeErrorMessages.push(error);
        }
    }
    const sendMessageError = latestErrors['ChatThreadClient.sendMessage'];
    {
        const error = latestNotInThisThreadError(latestErrors);
        if (error !== undefined) {
            if (sendMessageError !== undefined) {
                activeErrorMessages.push({
                    type: 'sendMessageNotInChatThread',
                    // Set the latest timestamp of all the errors that translated to an active error.
                    timestamp: sendMessageError.timestamp > ((_a = error.timestamp) !== null && _a !== void 0 ? _a : 0) ? sendMessageError.timestamp : error.timestamp
                });
                specificSendMessageErrorSeen = true;
            }
            else {
                activeErrorMessages.push(error);
            }
        }
    }
    if (!specificSendMessageErrorSeen && sendMessageError !== undefined) {
        activeErrorMessages.push({
            type: 'sendMessageGeneric',
            timestamp: sendMessageError.timestamp
        });
    } // We only return the first few errors to avoid filling up the UI with too many `MessageBar`s.
    activeErrorMessages.splice(maxErrorCount);
    return {
        activeErrorMessages: activeErrorMessages
    };
});
const maxErrorCount = 3;
const accessErrorTargets = ['ChatThreadClient.getProperties', 'ChatThreadClient.listMessages', 'ChatThreadClient.listParticipants', 'ChatThreadClient.sendMessage', 'ChatThreadClient.sendTypingNotification'];
const latestUnableToReachChatServiceError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'unableToReachChatService', (error) => {
        return !!error && !!error.innerError && error.innerError['code'] === 'REQUEST_SEND_ERROR';
    });
};
const latestAccessDeniedError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'accessDenied', (error) => {
        return !!error && !!error.innerError && error.innerError['statusCode'] === 401;
    });
};
const latestNotInThisThreadError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'userNotInChatThread', (error) => {
        if (!error || !error.innerError) {
            return false;
        } // Explicitly ignore 400 REST error when listParticipants() is called and a BotContact MRI is found in the participants.
        // This check should be removed when the chat SDK has handled this issue. Note: The this does not stop the error being logged to the console.
        // To the best of our ability we have confirmed this to have no impact on the participantList returned (all valid participants are still returned), nor
        // does it have an impact on the participant list updating on other participants joining/leaving or on individual participant actions like removeParticipant.
        if (isErrorDueToBotContact(error)) {
            return false;
        } // Chat service returns 403 if a user has been removed from a thread.
        // Chat service returns either 400 or 404 if the thread ID is malformed, depending on how the thread ID is malformed.
        return [400, 403, 404].some(statusCode => error.innerError['statusCode'] === statusCode);
    });
};
const botContactMRIPrefix = '28:';
const isErrorDueToBotContact = (error) => error.innerError['statusCode'] === 400 && error.innerError.message.includes(`Identifier format is not supported (${botContactMRIPrefix}`);
const latestActiveErrorSatisfying = (errors, activeErrorType, predicate) => {
    const activeErrorMessages = [];
    for (const target of accessErrorTargets) {
        const error = errors[target];
        if (predicate(error)) {
            activeErrorMessages.push({
                type: activeErrorType,
                timestamp: error.timestamp
            });
        }
    }
    if (activeErrorMessages.length === 0) {
        return undefined;
    } // We're actually sure that both timestamps will always exist, because we set them above.
    activeErrorMessages.sort((a, b) => { var _a, _b, _c, _d; return ((_b = (_a = a.timestamp) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = b.timestamp) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0); });
    return activeErrorMessages[activeErrorMessages.length - 1];
};

// Copyright (c) Microsoft Corporation.
/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const getSelector = (component) => {
    return findSelector(component);
};
const findSelector = (component) => {
    switch (component) {
        case SendBox:
            return sendBoxSelector;
        case MessageThread:
            return messageThreadSelector;
        case TypingIndicator:
            return typingIndicatorSelector;
        case ParticipantList:
            return chatParticipantListSelector;
        case ErrorBar:
            return errorBarSelector;
    }
    return undefined;
};

var __awaiter$m = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyDeviceManager proxies DeviceManager and subscribes to all events that affect device manager state. State updates
 * are set on the provided context. Also any queries for state are proxied and stored in state as well. Only one device
 * manager should exist for a given CallClient so if CallClient.getDeviceManager is called multiple times, either a
 * cached ProxyDeviceManager should be returned or the existing ProxyDeviceManager should be destructed via destructor()
 * and a new ProxyDeviceManager created.
 */
class ProxyDeviceManager {
    constructor(deviceManager, context) {
        this.setDeviceManager = () => {
            // isSpeakerSelectionAvailable, selectedMicrophone, and selectedSpeaker are properties on DeviceManager. Since they
            // are not functions we can't proxy them so we'll update whenever we think they may need updating such as at
            // construction time or when certain events happen.
            this._context.setDeviceManagerIsSpeakerSelectionAvailable(this._deviceManager.isSpeakerSelectionAvailable);
            this._context.setDeviceManagerSelectedMicrophone(this._deviceManager.selectedMicrophone);
            this._context.setDeviceManagerSelectedSpeaker(this._deviceManager.selectedSpeaker);
        };
        this.subscribe = () => {
            this._deviceManager.on('videoDevicesUpdated', this.videoDevicesUpdated);
            this._deviceManager.on('audioDevicesUpdated', this.audioDevicesUpdated);
            this._deviceManager.on('selectedMicrophoneChanged', this.selectedMicrophoneChanged);
            this._deviceManager.on('selectedSpeakerChanged', this.selectedSpeakerChanged);
        };
        /**
         * This is used to unsubscribe DeclarativeDeviceManager from the DeviceManager events.
         */
        this.unsubscribe = () => {
            this._deviceManager.off('videoDevicesUpdated', this.videoDevicesUpdated);
            this._deviceManager.off('audioDevicesUpdated', this.audioDevicesUpdated);
            this._deviceManager.off('selectedMicrophoneChanged', this.selectedMicrophoneChanged);
            this._deviceManager.off('selectedSpeakerChanged', this.selectedSpeakerChanged);
        };
        /**
         * Used to set a camera inside the proxy device manager.
         *
         * @param videoDeviceInfo VideoDeviceInfo
         */
        this.selectCamera = (videoDeviceInfo) => {
            this._context.setDeviceManagerSelectedCamera(videoDeviceInfo);
        };
        this.videoDevicesUpdated = () => __awaiter$m(this, void 0, void 0, function* () {
            this._context.setDeviceManagerCameras(dedupeById(yield this._deviceManager.getCameras()));
        });
        this.audioDevicesUpdated = () => __awaiter$m(this, void 0, void 0, function* () {
            this._context.setDeviceManagerMicrophones(dedupeById(yield this._deviceManager.getMicrophones()));
            this._context.setDeviceManagerSpeakers(dedupeById(yield this._deviceManager.getSpeakers()));
        });
        this.selectedMicrophoneChanged = () => {
            this._context.setDeviceManagerSelectedMicrophone(this._deviceManager.selectedMicrophone);
        };
        this.selectedSpeakerChanged = () => {
            this._context.setDeviceManagerSelectedSpeaker(this._deviceManager.selectedSpeaker);
        };
        this._deviceManager = deviceManager;
        this._context = context;
        this.setDeviceManager();
        this.subscribe();
    }
    get(target, prop) {
        switch (prop) {
            case 'getCameras':
                {
                    return this._context.withAsyncErrorTeedToState(() => {
                        return target.getCameras().then((cameras) => {
                            this._context.setDeviceManagerCameras(dedupeById(cameras));
                            return cameras;
                        });
                    }, 'DeviceManager.getCameras');
                }
            case 'getMicrophones':
                {
                    return this._context.withAsyncErrorTeedToState(() => {
                        return target.getMicrophones().then((microphones) => {
                            this._context.setDeviceManagerMicrophones(dedupeById(microphones));
                            return microphones;
                        });
                    }, 'DeviceManager.getMicrophones');
                }
            case 'getSpeakers':
                {
                    return this._context.withAsyncErrorTeedToState(() => {
                        return target.getSpeakers().then((speakers) => {
                            this._context.setDeviceManagerSpeakers(dedupeById(speakers));
                            return speakers;
                        });
                    }, 'DeviceManager.getSpeakers');
                }
            case 'selectMicrophone':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => {
                        return target.selectMicrophone(...args).then(() => {
                            this._context.setDeviceManagerSelectedMicrophone(target.selectedMicrophone);
                        });
                    }, 'DeviceManager.selectMicrophone');
                }
            case 'selectSpeaker':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => {
                        return target.selectSpeaker(...args).then(() => {
                            this._context.setDeviceManagerSelectedSpeaker(target.selectedSpeaker);
                        });
                    }, 'DeviceManager.selectSpeaker');
                }
            case 'askDevicePermission':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => {
                        return target.askDevicePermission(...args).then((deviceAccess) => {
                            this._context.setDeviceManagerDeviceAccess(deviceAccess);
                            this.setDeviceManager();
                            return deviceAccess;
                        });
                    }, 'DeviceManager.askDevicePermission');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
} // TODO: Remove this when SDK no longer returns duplicate audio and video devices
/** Helper function to dedupe duplicate audio and video devices obtained from SDK */
const dedupeById = (devices) => {
    const ids = new Set();
    const uniqueDevices = [];
    devices.forEach((device) => {
        if (!ids.has(device.id)) {
            uniqueDevices.push(device);
            ids.add(device.id);
        }
    });
    return uniqueDevices;
};
/**
 * Creates a declarative DeviceManager by proxying DeviceManager with ProxyDeviceManager. The declarative DeviceManager
 * will put state updates in the given context.
 *
 * @param deviceManager - DeviceManager from SDK
 * @param context - CallContext from StatefulCallClient
 */
const deviceManagerDeclaratify = (deviceManager, context) => {
    const proxyDeviceManager = new ProxyDeviceManager(deviceManager, context);
    Object.defineProperty(deviceManager, 'unsubscribe', {
        configurable: false,
        value: () => proxyDeviceManager.unsubscribe()
    });
    Object.defineProperty(deviceManager, 'selectCamera', {
        configurable: false,
        value: (videoDeviceInfo) => proxyDeviceManager.selectCamera(videoDeviceInfo)
    });
    return new Proxy(deviceManager, proxyDeviceManager);
};

/**
 * Error thrown from failed stateful API methods.
 *
 * @public
 */
class CallError extends Error {
    constructor(target, innerError, timestamp) {
        super();
        this.target = target;
        this.innerError = innerError; // Testing note: It is easier to mock Date::now() than the Date() constructor.
        this.timestamp = timestamp !== null && timestamp !== void 0 ? timestamp : new Date(Date.now());
        this.name = 'CallError';
        this.message = `${this.target}: ${this.innerError.message}`;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const callingStatefulLogger = logger.createClientLogger('communication-react:calling-stateful');
/**
 * @private
 */
var EventNames;
(function (EventNames) {
    // Info
    EventNames["LOCAL_VIEW_RENDER_SUCCEED"] = "LOCAL_VIEW_RENDER_SUCCEED";
    EventNames["START_DISPOSE_LOCAL_STREAM"] = "START_DISPOSE_LOCAL_STREAM";
    EventNames["START_DISPOSE_REMOTE_STREAM"] = "START_DISPOSE_REMOTE_STREAM";
    EventNames["START_LOCAL_STREAM_RENDERING"] = "START_LOCAL_STREAM_RENDERING";
    EventNames["DISPOSING_LOCAL_RENDERER"] = "DISPOSING_LOCAL_RENDERER";
    EventNames["DISPOSING_REMOTE_RENDERER"] = "DISPOSING_REMOTE_RENDERER";
    EventNames["CREATING_REMOTE_VIEW"] = "CREATING_REMOTE_VIEW";
    EventNames["REMOTE_VIEW_RENDER_SUCCEED"] = "REMOTE_VIEW_RENDER_SUCCEED";
    // Warning
    EventNames["CREATE_STREAM_INVALID_PARAMS"] = "CREATE_STREAM_INVALID_PARAMS";
    EventNames["DISPOSE_STREAM_INVALID_PARAMS"] = "DISPOSE_LOCAL_STREAM_INVALID_PARAMS";
    EventNames["LOCAL_STREAM_ALREADY_RENDERED"] = "LOCAL_STREAM_ALREADY_RENDERED";
    EventNames["LOCAL_STREAM_ALREADY_DISPOSED"] = "LOCAL_STREAM_ALREADY_DISPOSED";
    EventNames["LOCAL_STREAM_STOPPING"] = "LOCAL_STREAM_STOPPING";
    EventNames["LOCAL_CREATED_STREAM_STOPPING"] = "LOCAL_CREATED_STREAM_STOPPING";
    EventNames["LOCAL_STREAM_RENDERING"] = "LOCAL_STREAM_RENDERING";
    EventNames["REMOTE_STREAM_ALREADY_RENDERED"] = "REMOTE_STREAM_ALREADY_RENDERED";
    EventNames["REMOTE_STREAM_RENDERING"] = "REMOTE_STREAM_RENDERING";
    EventNames["REMOTE_STREAM_STOPPING"] = "REMOTE_STREAM_STOPPING";
    // Error
    EventNames["LOCAL_STREAM_NOT_FOUND"] = "LOCAL_STREAM_NOT_FOUND";
    EventNames["LOCAL_RENDER_INFO_NOT_FOUND"] = "LOCAL_RENDER_INFO_NOT_FOUND";
    EventNames["REMOTE_STREAM_NOT_FOUND"] = "REMOTE_STREAM_NOT_FOUND";
    EventNames["LOCAL_DISPOSE_INFO_NOT_FOUND"] = "LOCAL_DISPOSE_INFO_NOT_FOUND";
    EventNames["REMOTE_DISPOSE_INFO_NOT_FOUND"] = "REMOTE_DISPOSE_INFO_NOT_FOUND";
    EventNames["REMOTE_RENDER_INFO_NOT_FOUND"] = "REMOTE_RENDER_INFO_NOT_FOUND";
    EventNames["LOCAL_RENDERER_NOT_FOUND"] = "LOCAL_RENDERER_NOT_FOUND";
    EventNames["REMOTE_RENDERER_NOT_FOUND"] = "REMOTE_RENDERER_NOT_FOUND";
    EventNames["CREATE_REMOTE_STREAM_FAIL"] = "CREATE_REMOTE_STREAM_FAIL";
    EventNames["CREATE_LOCAL_STREAM_FAIL"] = "CREATE_LOCAL_STREAM_FAIL";
})(EventNames || (EventNames = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 * Call Id will change during the call for at least 1 time
 * This is to avoid async bug that call id has been changed during an async-await function
 * but the function still uses stale call id to access state
 */
class CallIdHistory {
    constructor() {
        this._callIdHistory = new Map();
    }
    updateCallIdHistory(newCallId, oldCallId) {
        // callId for a call can fluctuate between some set of values.
        // But if a newCallId already exists, and maps to different call, we're in trouble.
        // This can only happen if a callId is reused across two distinct calls.
        const existing = this._callIdHistory.get(newCallId);
        if (existing !== undefined && this.latestCallId(newCallId) !== oldCallId) {
            console.trace(`${newCallId} alredy exists and maps to ${existing}, which is not the same as ${oldCallId}`);
        } // The latest callId never maps to another callId.
        this._callIdHistory.delete(newCallId);
        this._callIdHistory.set(oldCallId, newCallId);
    }
    latestCallId(callId) {
        let latest = callId;
        /* eslint no-constant-condition: ["error", { "checkLoops": false }] */
        while (true) {
            const newer = this._callIdHistory.get(latest);
            if (newer === undefined) {
                break;
            }
            latest = newer;
        }
        return latest;
    }
}

var __awaiter$l = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
produce.enableMapSet(); // Needed to generate state diff for verbose logging.
produce.enablePatches(); // TODO: How can we make this configurable?
/**
 * @private
 */
const MAX_CALL_HISTORY_LENGTH = 10;
/**
 * @private
 */
class CallContext$1 {
    constructor(userId, maxListeners = 50, 
    /* @conditional-compile-remove(PSTN-calls) */
    alternateCallerId) {
        this._callIdHistory = new CallIdHistory();
        this._logger = logger.createClientLogger('communication-react:calling-context');
        this._state = {
            calls: {},
            callsEnded: {},
            incomingCalls: {},
            incomingCallsEnded: {},
            deviceManager: {
                isSpeakerSelectionAvailable: false,
                cameras: [],
                microphones: [],
                speakers: [],
                unparentedViews: []
            },
            callAgent: undefined,
            userId: userId,
            latestErrors: {}
        };
        this._emitter = new EventEmitter__default['default']();
        this._emitter.setMaxListeners(maxListeners);
        this._atomicId = 0;
    }
    getState() {
        return this._state;
    }
    modifyState(modifier) {
        const priorState = this._state;
        this._state = produce.produce(this._state, modifier, (patches) => {
            if (logger.getLogLevel() === 'verbose') {
                // Log to `info` because AzureLogger.verbose() doesn't show up in console.
                this._logger.info(`State change: ${_safeJSONStringify(patches)}`);
            }
        });
        if (this._state !== priorState) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    } // Disposing of the CallAgentDeclarative will not clear the state. If we create a new CallAgentDeclarative, we should
    // make sure the state is clean because any left over state (if previous CallAgentDeclarative was disposed) may be
    // invalid.
    clearCallRelatedState() {
        this.modifyState((draft) => {
            draft.calls = {};
            draft.incomingCalls = {};
            draft.callsEnded = {};
            draft.incomingCallsEnded = {};
        });
    }
    setCallAgent(callAgent) {
        this.modifyState((draft) => {
            draft.callAgent = callAgent;
        });
    }
    setCall(call) {
        this.modifyState((draft) => {
            const latestCallId = this._callIdHistory.latestCallId(call.id);
            const existingCall = draft.calls[latestCallId];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
                existingCall.state = call.state;
                existingCall.callEndReason = call.callEndReason;
                existingCall.direction = call.direction;
                existingCall.isMuted = call.isMuted;
                existingCall.isScreenSharingOn = call.isScreenSharingOn;
                existingCall.localVideoStreams = call.localVideoStreams;
                existingCall.remoteParticipants = call.remoteParticipants;
                existingCall.transcription.isTranscriptionActive = call.transcription.isTranscriptionActive;
                existingCall.recording.isRecordingActive = call.recording.isRecordingActive; // We don't update the startTime and endTime if we are updating an existing active call
            }
            else {
                draft.calls[latestCallId] = call;
            }
        });
    }
    removeCall(callId) {
        this.modifyState((draft) => {
            delete draft.calls[this._callIdHistory.latestCallId(callId)];
        });
    }
    setCallEnded(callId, callEndReason) {
        const latestCallId = this._callIdHistory.latestCallId(callId);
        this.modifyState((draft) => {
            const call = draft.calls[latestCallId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.calls[latestCallId]; // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.callsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.callsEnded[findOldestCallEnded(draft.callsEnded)];
                }
                draft.callsEnded[latestCallId] = call;
            }
        });
    }
    setCallState(callId, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.state = state;
            }
        });
    }
    setCallId(newCallId, oldCallId) {
        this._callIdHistory.updateCallIdHistory(newCallId, oldCallId);
        this.modifyState((draft) => {
            const call = draft.calls[oldCallId];
            if (call) {
                call.id = newCallId;
                delete draft.calls[oldCallId];
                draft.calls[newCallId] = call;
            }
        });
    }
    setCallIsScreenSharingOn(callId, isScreenSharingOn) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isScreenSharingOn = isScreenSharingOn;
            }
        });
    }
    setCallRemoteParticipants(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipants[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        });
    }
    setCallRemoteParticipantsEnded(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipantsEnded[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipantsEnded[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        });
    }
    setCallLocalVideoStream(callId, streams) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.localVideoStreams = streams;
            }
        });
    }
    setCallIsMicrophoneMuted(callId, isMicrophoneMuted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isMuted = isMicrophoneMuted;
            }
        });
    }
    setCallDominantSpeakers(callId, dominantSpeakers) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.dominantSpeakers = dominantSpeakers;
            }
        });
    }
    setCallRecordingActive(callId, isRecordingActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.recording.isRecordingActive = isRecordingActive;
            }
        });
    }
    setCallTranscriptionActive(callId, isTranscriptionActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.transcription.isTranscriptionActive = isTranscriptionActive;
            }
        });
    }
    setCallScreenShareParticipant(callId, participantKey) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.screenShareRemoteParticipant = participantKey;
            }
        });
    }
    setLocalVideoStreamRendererView(callId, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                if (call.localVideoStreams.length > 0) {
                    call.localVideoStreams[0].view = view;
                }
            }
        });
    }
    setParticipantState(callId, participantKey, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.state = state;
                }
            }
        });
    }
    setParticipantIsMuted(callId, participantKey, muted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isMuted = muted;
                }
            }
        });
    }
    setParticipantDisplayName(callId, participantKey, displayName) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.displayName = displayName;
                }
            }
        });
    }
    setParticipantIsSpeaking(callId, participantKey, isSpeaking) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isSpeaking = isSpeaking;
                }
            }
        });
    }
    setParticipantVideoStream(callId, participantKey, stream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    // Set is called by subscriber will not modify any rendered stream so if there is existing stream only
                    // modify the values that subscriber has access to.
                    const existingStream = participant.videoStreams[stream.id];
                    if (existingStream) {
                        existingStream.isAvailable = stream.isAvailable;
                        existingStream.mediaStreamType = stream.mediaStreamType;
                    }
                    else {
                        participant.videoStreams[stream.id] = stream;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamIsAvailable(callId, participantKey, streamId, isAvailable) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.isAvailable = isAvailable;
                    }
                }
            }
        });
    }
    setRemoteVideoStreams(callId, participantKey, addRemoteVideoStream, removeRemoteVideoStream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    for (const id of removeRemoteVideoStream) {
                        delete participant.videoStreams[id];
                    }
                    for (const newStream of addRemoteVideoStream) {
                        // This should only be called by the subscriber and some properties are add by other components so if the
                        // stream already exists, only update the values that subscriber knows about.
                        const stream = participant.videoStreams[newStream.id];
                        if (stream) {
                            stream.mediaStreamType = newStream.mediaStreamType;
                            stream.isAvailable = newStream.isAvailable;
                        }
                        else {
                            participant.videoStreams[newStream.id] = newStream;
                        }
                    }
                }
            }
        });
    }
    setRemoteVideoStreamRendererView(callId, participantKey, streamId, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.view = view;
                    }
                }
            }
        });
    }
    setIncomingCall(call) {
        this.modifyState((draft) => {
            const existingCall = draft.incomingCalls[call.id];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
            }
            else {
                draft.incomingCalls[call.id] = call;
            }
        });
    }
    removeIncomingCall(callId) {
        this.modifyState((draft) => {
            delete draft.incomingCalls[callId];
        });
    }
    setIncomingCallEnded(callId, callEndReason) {
        this.modifyState((draft) => {
            const call = draft.incomingCalls[callId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.incomingCalls[callId]; // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.incomingCallsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.incomingCallsEnded[findOldestCallEnded(draft.incomingCallsEnded)];
                }
                draft.incomingCallsEnded[callId] = call;
            }
        });
    }
    setDeviceManagerIsSpeakerSelectionAvailable(isSpeakerSelectionAvailable) {
        this.modifyState((draft) => {
            draft.deviceManager.isSpeakerSelectionAvailable = isSpeakerSelectionAvailable;
        });
    }
    setDeviceManagerSelectedMicrophone(selectedMicrophone) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedMicrophone = selectedMicrophone;
        });
    }
    setDeviceManagerSelectedSpeaker(selectedSpeaker) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedSpeaker = selectedSpeaker;
        });
    }
    setDeviceManagerSelectedCamera(selectedCamera) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedCamera = selectedCamera;
        });
    }
    setDeviceManagerCameras(cameras) {
        this.modifyState((draft) => {
            /**
             * SDK initializes cameras with one dummy camera with value { id: 'camera:id', name: '', deviceType: 'USBCamera' } immediately after
             * camera permissions are granted. So selectedCamera will have this value before the actual cameras are obtained. Therefore we should reset
             * selectedCamera to the first camera when there are cameras AND when current selectedCamera does not exist in the new array of cameras *
             */
            if (cameras.length > 0 && !cameras.some(camera => { var _a; return camera.id === ((_a = draft.deviceManager.selectedCamera) === null || _a === void 0 ? void 0 : _a.id); })) {
                draft.deviceManager.selectedCamera = cameras[0];
            }
            draft.deviceManager.cameras = cameras;
        });
    }
    setDeviceManagerMicrophones(microphones) {
        this.modifyState((draft) => {
            draft.deviceManager.microphones = microphones;
        });
    }
    setDeviceManagerSpeakers(speakers) {
        this.modifyState((draft) => {
            draft.deviceManager.speakers = speakers;
        });
    }
    setDeviceManagerDeviceAccess(deviceAccess) {
        this.modifyState((draft) => {
            draft.deviceManager.deviceAccess = deviceAccess;
        });
    }
    setDeviceManagerUnparentedView(localVideoStream, view) {
        this.modifyState((draft) => {
            draft.deviceManager.unparentedViews.push({
                source: localVideoStream.source,
                mediaStreamType: localVideoStream.mediaStreamType,
                view: view
            });
        });
    }
    deleteDeviceManagerUnparentedView(localVideoStream) {
        this.modifyState((draft) => {
            const foundIndex = draft.deviceManager.unparentedViews.findIndex(stream => stream.source.id === localVideoStream.source.id && stream.mediaStreamType === localVideoStream.mediaStreamType);
            if (foundIndex !== -1) {
                draft.deviceManager.unparentedViews.splice(foundIndex, 1);
            }
        });
    }
    getAndIncrementAtomicId() {
        const id = this._atomicId;
        this._atomicId++;
        return id;
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param action Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(action, target) {
        return (...args) => __awaiter$l(this, void 0, void 0, function* () {
            try {
                return yield action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param action Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(action, target) {
        return (...args) => {
            try {
                callingStatefulLogger.info(`Calling stateful client target function called: ${target}`);
                return action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        };
    }
    setLatestError(target, error) {
        this.modifyState((draft) => {
            draft.latestErrors[target] = error;
        });
    }
}
const toCallError = (target, error) => {
    if (error instanceof Error) {
        return new CallError(target, error);
    }
    return new CallError(target, new Error(error));
};
const findOldestCallEnded = (calls) => {
    var _a, _b, _c, _d;
    const callEntries = Object.entries(calls);
    let [oldestCallId, oldestCall] = callEntries[0];
    if (oldestCall.endTime === undefined) {
        return oldestCallId;
    }
    for (const [callId, call] of callEntries.slice(1)) {
        if (call.endTime === undefined) {
            return callId;
        }
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) < ((_d = (_c = oldestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            [oldestCallId, oldestCall] = [callId, call];
        }
    }
    return oldestCallId;
};

var __awaiter$k = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProxyCall {
    constructor(context) {
        this._context = context;
    }
    unsubscribe() {
        /** No subscriptions yet. But there will be one for transfer feature soon. */
    }
    get(target, prop) {
        switch (prop) {
            case 'mute':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            return yield target.mute(...args);
                        });
                    }, 'Call.mute');
                }
            case 'unmute':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            return yield target.unmute(...args);
                        });
                    }, 'Call.unmute');
                }
            case 'startVideo':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            return yield target.startVideo(...args);
                        });
                    }, 'Call.startVideo');
                }
            case 'stopVideo':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            return yield target.stopVideo(...args);
                        });
                    }, 'Call.stopVideo');
                }
            case 'startScreenSharing':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            return yield target.startScreenSharing(...args);
                        });
                    }, 'Call.startScreenSharing');
                }
            case 'stopScreenSharing':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            return yield target.stopScreenSharing(...args);
                        });
                    }, 'Call.stopScreenSharing');
                }
            case 'hold':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            return yield target.hold(...args);
                        });
                    }, 'Call.hold');
                }
            case 'resume':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            return yield target.resume(...args);
                        });
                    }, 'Call.resume');
                }
            case 'addParticipant':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$k(this, void 0, void 0, function* () {
                            return yield target.addParticipant(...args);
                        });
                    }, 'Call.addParticipant');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a declarative Call by proxying Call with ProxyCall.
 * This should only be used with CallAgentDeclarative as CallAgentDeclarative will add that
 * call to the context properly (need to have the Call in context to update it - CallAgentDeclarative will add Call to
 * context)
 *
 * @param call - Call from SDK
 * @param context - CallContext from StatefulCallClient
 */
const callDeclaratify = (call, context) => {
    const proxyCall = new ProxyCall(context);
    Object.defineProperty(call, 'unsubscribe', {
        configurable: false,
        value: () => proxyCall.unsubscribe()
    });
    return new Proxy(call, proxyCall);
};

/**
 * @private
 */
function convertSdkLocalStreamToDeclarativeLocalStream(stream) {
    return {
        source: stream.source,
        mediaStreamType: stream.mediaStreamType,
        view: undefined
    };
}
/**
 * @private
 */
function convertSdkRemoteStreamToDeclarativeRemoteStream(stream) {
    return {
        id: stream.id,
        mediaStreamType: stream.mediaStreamType,
        isAvailable: stream.isAvailable,
        view: undefined
    };
}
/**
 * @private
 */
function convertSdkParticipantToDeclarativeParticipant(participant) {
    const declarativeVideoStreams = {};
    for (const videoStream of participant.videoStreams) {
        declarativeVideoStreams[videoStream.id] = convertSdkRemoteStreamToDeclarativeRemoteStream(videoStream);
    }
    return {
        identifier: participant.identifier,
        displayName: participant.displayName,
        state: participant.state,
        callEndReason: participant.callEndReason,
        videoStreams: declarativeVideoStreams,
        isMuted: participant.isMuted,
        isSpeaking: participant.isSpeaking
    };
}
/**
 * @private
 *
 * Note at the time of writing only one LocalVideoStream is supported by the SDK.
 */
function convertSdkCallToDeclarativeCall(call) {
    const declarativeRemoteParticipants = {};
    call.remoteParticipants.forEach((participant) => {
        declarativeRemoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] = convertSdkParticipantToDeclarativeParticipant(participant);
    });
    return {
        id: call.id,
        callerInfo: call.callerInfo,
        state: call.state,
        callEndReason: call.callEndReason,
        diagnostics: {
            network: {
                latest: {}
            },
            media: {
                latest: {}
            }
        },
        direction: call.direction,
        isMuted: call.isMuted,
        isScreenSharingOn: call.isScreenSharingOn,
        localVideoStreams: call.localVideoStreams.map(convertSdkLocalStreamToDeclarativeLocalStream),
        remoteParticipants: declarativeRemoteParticipants,
        remoteParticipantsEnded: {},
        recording: {
            isRecordingActive: false
        },
        transcription: {
            isTranscriptionActive: false
        },
        screenShareRemoteParticipant: undefined,
        startTime: new Date(),
        endTime: undefined
    };
}
/**
 * @private
 */
function convertSdkIncomingCallToDeclarativeIncomingCall(call) {
    return {
        id: call.id,
        callerInfo: call.callerInfo,
        startTime: new Date(),
        endTime: undefined
    };
}
/**
 * @private
 */
function convertFromSDKToDeclarativeVideoStreamRendererView(view) {
    return {
        scalingMode: view.scalingMode,
        isMirrored: view.isMirrored,
        target: view.target
    };
}

/**
 * @private
 */
class RemoteVideoStreamSubscriber {
    constructor(callIdRef, participantKey, remoteVideoStream, context) {
        this.subscribe = () => {
            this._remoteVideoStream.on('isAvailableChanged', this.isAvailableChanged);
            this.checkAndUpdateScreenShareState();
        };
        this.unsubscribe = () => {
            this._remoteVideoStream.off('isAvailableChanged', this.isAvailableChanged);
        };
        this.includesActiveScreenShareStream = (streams) => {
            for (const stream of Object.values(streams)) {
                if (stream.mediaStreamType === 'ScreenSharing' && stream.isAvailable) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Update the state with the active screen share stream. If there is an existing stream will overwrite it if this one
         * is active (newer stream takes priority). If there is an existing stream and this one is set to unavailable, and the
         * existing stream is different participant, then don't set the active screen share stream to undefined, else set it
         * to undefined.
         */
        this.checkAndUpdateScreenShareState = () => {
            var _a, _b, _c;
            if (this._remoteVideoStream.mediaStreamType !== 'ScreenSharing') {
                return;
            }
            if (this._remoteVideoStream.isAvailable) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, this._participantKey);
                return;
            }
            const existingScreenShare = (_a = this._context.getState().calls[this._callIdRef.callId]) === null || _a === void 0 ? void 0 : _a.screenShareRemoteParticipant; // If somehow we end up with an event where a RemoteParticipant's ScreenShare stream is set to
            // unavailable but there exists already another different participant actively sharing, and they are still
            // sharing then this event shouldn't set the screenShareRemoteParticipant to undefined.
            if (!existingScreenShare || existingScreenShare === this._participantKey) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
            const streams = (_c = (_b = this._context.getState().calls[this._callIdRef.callId]) === null || _b === void 0 ? void 0 : _b.remoteParticipants[existingScreenShare]) === null || _c === void 0 ? void 0 : _c.videoStreams;
            if (!streams) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            } // If the existing ScreenShare that is not owned by the current RemoteParticipant is still active, don't
            // overwrite it with undefined. So only overwrite if it is not active.
            if (!this.includesActiveScreenShareStream(streams)) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
        };
        this.isAvailableChanged = () => {
            this._context.setRemoteVideoStreamIsAvailable(this._callIdRef.callId, this._participantKey, this._remoteVideoStream.id, this._remoteVideoStream.isAvailable);
            this.checkAndUpdateScreenShareState();
        };
        this._callIdRef = callIdRef;
        this._participantKey = participantKey;
        this._remoteVideoStream = remoteVideoStream;
        this._context = context;
        this.subscribe();
    }
}

var __awaiter$j = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createViewRemoteVideo(context, internalContext, callId, participantId, stream, options) {
    return __awaiter$j(this, void 0, void 0, function* () {
        // Render RemoteVideoStream that is part of a Call
        const streamId = stream.id;
        let participantKey;
        if (typeof participantId === 'string') {
            participantKey = participantId;
        }
        else {
            participantKey = toFlatCommunicationIdentifier(participantId);
        }
        const streamLogInfo = {
            callId,
            participantKey,
            streamId
        };
        _logEvent(callingStatefulLogger, {
            name: EventNames.CREATING_REMOTE_VIEW,
            level: 'info',
            message: 'Start creating view for remote video.',
            data: streamLogInfo
        });
        const renderInfo = internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId);
        if (!renderInfo) {
            _logEvent(callingStatefulLogger, {
                name: EventNames.REMOTE_STREAM_NOT_FOUND,
                level: 'error',
                message: 'RemoteVideoStream not found in state.',
                data: streamLogInfo
            });
            console.warn('RemoteVideoStream not found in state');
            return;
        }
        if (renderInfo.status === 'Rendered') {
            _logEvent(callingStatefulLogger, {
                name: EventNames.REMOTE_STREAM_ALREADY_RENDERED,
                level: 'warning',
                message: 'RemoteVideoStream is already rendered.',
                data: streamLogInfo
            });
            console.warn('RemoteVideoStream is already rendered');
            return;
        }
        if (renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            _logEvent(callingStatefulLogger, {
                name: EventNames.REMOTE_STREAM_RENDERING,
                level: 'warning',
                message: 'RemoteVideoStream is rendering.',
                data: streamLogInfo
            });
            return;
        }
        if (renderInfo.status === 'Stopping') {
            console.warn('RemoteVideoStream is in the middle of stopping');
            return;
        }
        const renderer = new communicationCalling.VideoStreamRenderer(renderInfo.stream);
        internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'Rendering', undefined);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATE_REMOTE_STREAM_FAIL,
                level: 'error',
                message: 'Failed to create remote view',
                data: streamLogInfo
            });
            internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'NotRendered', undefined);
            throw e;
        }
        const refreshedRenderInfo = internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId);
        if (!refreshedRenderInfo) {
            // RenderInfo was removed. This should not happen unless stream was removed from the call so dispose the renderer
            // and clean up state.
            _logEvent(callingStatefulLogger, {
                name: EventNames.REMOTE_RENDER_INFO_NOT_FOUND,
                level: 'error',
                message: '`Cannot find remote render info after create the view.',
                data: streamLogInfo
            });
            renderer.dispose();
            context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            // Stop render was called on this stream after we had started rendering. We will dispose this view and do not
            // put the view into the state.
            renderer.dispose();
            internalContext.setRemoteRenderInfo(callId, participantKey, streamId, refreshedRenderInfo.stream, 'NotRendered', undefined);
            context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);
            _logEvent(callingStatefulLogger, {
                name: EventNames.REMOTE_VIEW_RENDER_SUCCEED,
                level: 'info',
                message: 'Successfully render the remote view.',
                data: streamLogInfo
            });
            return;
        } // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        internalContext.setRemoteRenderInfo(callId, participantKey, streamId, refreshedRenderInfo.stream, 'Rendered', renderer);
        context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, convertFromSDKToDeclarativeVideoStreamRendererView(view));
        return {
            renderer,
            view
        };
    });
}
function createViewLocalVideo(context, internalContext, callId, options) {
    return __awaiter$j(this, void 0, void 0, function* () {
        _logEvent(callingStatefulLogger, {
            name: EventNames.START_LOCAL_STREAM_RENDERING,
            level: 'info',
            message: 'Start creating view for local video.'
        }); // Render LocalVideoStream that is part of a Call
        const renderInfo = internalContext.getLocalRenderInfo(callId);
        if (!renderInfo) {
            _logEvent(callingStatefulLogger, {
                name: EventNames.LOCAL_STREAM_NOT_FOUND,
                level: 'error',
                message: 'LocalVideoStream not found in state.'
            });
            console.warn('LocalVideoStream not found in state');
            return;
        }
        if (renderInfo.status === 'Rendered') {
            _logEvent(callingStatefulLogger, {
                name: EventNames.LOCAL_STREAM_ALREADY_RENDERED,
                level: 'warning',
                message: 'LocalVideoStream is already rendered.'
            });
            console.warn('LocalVideoStream is already rendered');
            return;
        }
        if (renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            _logEvent(callingStatefulLogger, {
                name: EventNames.LOCAL_STREAM_RENDERING,
                level: 'warning',
                message: 'LocalVideoStream is rendering.'
            });
            return;
        } // "Stopping" only happens if the stream was in "rendering" but `disposeView` was called.
        // Now that `createView` has been re-called, we can flip the state back to "rendering".
        if (renderInfo.status === 'Stopping') {
            _logEvent(callingStatefulLogger, {
                name: EventNames.LOCAL_STREAM_STOPPING,
                level: 'warning',
                message: 'LocalVideoStream was marked as stopping by dispose view. Resetting state to "Rendering".'
            });
            internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'Rendering', renderInfo.renderer);
            return;
        }
        const renderer = new communicationCalling.VideoStreamRenderer(renderInfo.stream);
        internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'Rendering', renderer);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATE_LOCAL_STREAM_FAIL,
                level: 'error',
                message: 'Failed to create view.',
                data: {
                    error: e
                }
            });
            internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'NotRendered', undefined);
            throw e;
        } // Since render could take some time, we need to check if the stream is still valid and if we received a signal to
        // stop rendering.
        const refreshedRenderInfo = internalContext.getLocalRenderInfo(callId);
        if (!refreshedRenderInfo) {
            // RenderInfo was removed. This should not happen unless stream was removed from the call so dispose the renderer
            // and clean up the state.
            _logEvent(callingStatefulLogger, {
                name: EventNames.LOCAL_RENDER_INFO_NOT_FOUND,
                level: 'error',
                message: 'Cannot find local render info after create the view. ',
                data: {
                    callId
                }
            });
            renderer.dispose();
            context.setLocalVideoStreamRendererView(callId, undefined);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            // Stop render was called on this stream after we had started rendering. We will dispose this view and do not
            // put the view into the state.
            _logEvent(callingStatefulLogger, {
                name: EventNames.LOCAL_CREATED_STREAM_STOPPING,
                level: 'warning',
                message: 'Render info status is stopping, dispose renderer. ',
                data: {
                    callId
                }
            });
            renderer.dispose();
            internalContext.setLocalRenderInfo(callId, refreshedRenderInfo.stream, 'NotRendered', undefined);
            context.setLocalVideoStreamRendererView(callId, undefined);
            return;
        } // Else The stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        internalContext.setLocalRenderInfo(callId, refreshedRenderInfo.stream, 'Rendered', renderer);
        context.setLocalVideoStreamRendererView(callId, convertFromSDKToDeclarativeVideoStreamRendererView(view));
        _logEvent(callingStatefulLogger, {
            name: EventNames.LOCAL_VIEW_RENDER_SUCCEED,
            level: 'info',
            message: `Successfully render the local view.`,
            data: {
                callId
            }
        });
        return {
            renderer,
            view
        };
    });
}
function createViewUnparentedVideo(context, internalContext, stream, options) {
    return __awaiter$j(this, void 0, void 0, function* () {
        const renderInfo = internalContext.getUnparentedRenderInfo(stream);
        if (renderInfo && renderInfo.status === 'Rendered') {
            console.warn('Unparented LocalVideoStream is already rendered');
            return;
        }
        if (renderInfo && renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            return;
        }
        if (renderInfo && renderInfo.status === 'Stopping') {
            console.warn('Unparented LocalVideoStream is in the middle of stopping');
            return;
        }
        const localVideoStream = new communicationCalling.LocalVideoStream(stream.source);
        const renderer = new communicationCalling.VideoStreamRenderer(localVideoStream);
        internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendering', undefined);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            // Special case for unparented views. Since they are not tied to anything and created by us based on the calls to
            // this function we'll delete it to clean up the data since keeping it around doesn't help us and if developer wants
            // to create a new view they can check that the view is not rendered and call this function again.
            internalContext.deleteUnparentedRenderInfo(stream);
            throw e;
        } // Since render could take some time, we need to check if the stream is still valid and if we received a signal to
        // stop rendering.
        const refreshedRenderInfo = internalContext.getUnparentedRenderInfo(stream);
        if (!refreshedRenderInfo) {
            // Unparented stream's RenderInfo was deleted. Currently this shouldn't happen but if it does we'll just dispose the
            // renderer and clean up state. If developer wanted the stream they could call this function again and that should
            // generate new working state via this function.
            renderer.dispose();
            context.deleteDeviceManagerUnparentedView(stream);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            // Stop render was called on this stream after we had started rendering. We will dispose this view and do not
            // put the view into the state. Special case for unparented views, delete them from state when stopped to free up
            // the memory since we were the ones generating this and not tied to any Call state.
            internalContext.deleteUnparentedRenderInfo(stream);
            context.deleteDeviceManagerUnparentedView(stream);
            return;
        } // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendered', renderer);
        context.setDeviceManagerUnparentedView(stream, convertFromSDKToDeclarativeVideoStreamRendererView(view));
        return {
            renderer,
            view
        };
    });
}
function disposeViewRemoteVideo(context, internalContext, callId, participantId, stream) {
    const streamId = stream.id;
    let participantKey;
    if (typeof participantId === 'string') {
        participantKey = participantId;
    }
    else {
        participantKey = toFlatCommunicationIdentifier(participantId);
    }
    const streamLogInfo = {
        callId,
        participantKey,
        streamId
    };
    _logEvent(callingStatefulLogger, {
        name: EventNames.START_DISPOSE_REMOTE_STREAM,
        level: 'info',
        message: 'Start disposing remote stream.',
        data: streamLogInfo
    });
    context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);
    const renderInfo = internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId);
    if (!renderInfo) {
        _logEvent(callingStatefulLogger, {
            name: EventNames.REMOTE_DISPOSE_INFO_NOT_FOUND,
            level: 'error',
            message: 'Cannot find render info when disposing remote stream.',
            data: streamLogInfo
        });
        return;
    } // Sets the status and also renderer. I think we need to always set renderer to undefined since in all status when
    // cleaned up should have renderer as undefined. If the status is 'Rendered' and renderer is not defined it should
    // be cleaned up below so we can set it to undefined here.
    if (renderInfo.status === 'Rendering') {
        _logEvent(callingStatefulLogger, {
            name: EventNames.REMOTE_STREAM_STOPPING,
            level: 'info',
            message: 'Remote stream is still rendering. Changing status to stopping.',
            data: streamLogInfo
        });
        internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'Stopping', undefined);
    }
    else {
        internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'NotRendered', undefined);
    }
    if (renderInfo.renderer) {
        _logEvent(callingStatefulLogger, {
            name: EventNames.DISPOSING_REMOTE_RENDERER,
            level: 'info',
            message: 'Disposing remote view renderer.',
            data: streamLogInfo
        });
        renderInfo.renderer.dispose();
    }
    else {
        _logEvent(callingStatefulLogger, {
            name: EventNames.REMOTE_RENDERER_NOT_FOUND,
            level: 'error',
            message: 'Cannot find remote view renderer.',
            data: streamLogInfo
        });
    }
}
function disposeViewLocalVideo(context, internalContext, callId) {
    const streamLogInfo = {
        callId
    };
    _logEvent(callingStatefulLogger, {
        name: EventNames.START_DISPOSE_LOCAL_STREAM,
        level: 'info',
        message: 'Start disposing local stream.',
        data: streamLogInfo
    });
    context.setLocalVideoStreamRendererView(callId, undefined);
    const renderInfo = internalContext.getLocalRenderInfo(callId);
    if (!renderInfo) {
        _logEvent(callingStatefulLogger, {
            name: EventNames.LOCAL_DISPOSE_INFO_NOT_FOUND,
            level: 'error',
            message: 'Cannot find render info when disposing local stream.',
            data: streamLogInfo
        });
        return;
    } // Nothing to dispose of or clean up -- we can safely exit early here.
    if (renderInfo.status === 'NotRendered') {
        _logEvent(callingStatefulLogger, {
            name: EventNames.LOCAL_STREAM_ALREADY_DISPOSED,
            level: 'info',
            message: 'LocalVideoStream is already disposed.'
        });
        return;
    } // Status is already marked as "stopping" so we can exit early here. This is because stopping only occurs
    // when the stream is being created in createView but hasn't been completed being created yet. The createView
    // method will see the "stopping" status and perform the cleanup
    if (renderInfo.status === 'Stopping') {
        _logEvent(callingStatefulLogger, {
            name: EventNames.LOCAL_STREAM_STOPPING,
            level: 'info',
            message: 'Local stream is already stopping.',
            data: streamLogInfo
        });
        return;
    } // If the stream is in the middle of being rendered (i.e. has state "Rendering"), we need the status as
    // "stopping" without performing any cleanup. This will tell the `createView` method that it should stop
    // rendering and clean up the state once the view has finished being created.
    if (renderInfo.status === 'Rendering') {
        _logEvent(callingStatefulLogger, {
            name: EventNames.REMOTE_STREAM_STOPPING,
            level: 'info',
            message: 'Remote stream is still rendering. Changing status to stopping.',
            data: streamLogInfo
        });
        internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'Stopping', renderInfo.renderer);
        return;
    } // Else the state must be in the "Rendered" state, so we can dispose the renderer and clean up the state.
    internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'NotRendered', undefined);
    if (renderInfo.renderer) {
        _logEvent(callingStatefulLogger, {
            name: EventNames.DISPOSING_LOCAL_RENDERER,
            level: 'info',
            message: 'Disposing local view renderer.',
            data: streamLogInfo
        });
        renderInfo.renderer.dispose();
    }
    else {
        _logEvent(callingStatefulLogger, {
            name: EventNames.LOCAL_RENDERER_NOT_FOUND,
            level: 'error',
            message: 'Cannot find renderer when disposing local stream.',
            data: streamLogInfo
        });
    }
}
function disposeViewUnparentedVideo(context, internalContext, stream) {
    _logEvent(callingStatefulLogger, {
        name: EventNames.START_DISPOSE_LOCAL_STREAM,
        level: 'info',
        message: 'Start disposing unparented local stream.'
    });
    context.deleteDeviceManagerUnparentedView(stream);
    const renderInfo = internalContext.getUnparentedRenderInfo(stream);
    if (!renderInfo) {
        _logEvent(callingStatefulLogger, {
            name: EventNames.LOCAL_DISPOSE_INFO_NOT_FOUND,
            level: 'error',
            message: 'Cannot find render info when disposing unparented local stream.'
        });
        return;
    }
    if (renderInfo.status === 'Rendering') {
        _logEvent(callingStatefulLogger, {
            name: EventNames.LOCAL_STREAM_STOPPING,
            level: 'info',
            message: 'Unparented local stream is still rendering. Changing status to stopping.'
        });
        internalContext.setUnparentedRenderInfo(stream, renderInfo.stream, 'Stopping', undefined);
    }
    else {
        internalContext.deleteUnparentedRenderInfo(stream);
    }
    if (renderInfo.renderer) {
        _logEvent(callingStatefulLogger, {
            name: EventNames.DISPOSING_LOCAL_RENDERER,
            level: 'info',
            message: 'Disposing unparented local view renderer.'
        });
        renderInfo.renderer.dispose();
    }
    else {
        _logEvent(callingStatefulLogger, {
            name: EventNames.LOCAL_RENDERER_NOT_FOUND,
            level: 'error',
            message: 'Cannot find renderer when disposing unparented local stream.'
        });
    }
}
/**
 * @private
 */
function createView(context, internalContext, callId, participantId, stream, options) {
    if ('id' in stream && callId && participantId) {
        // Render RemoteVideoStream that is part of a Call
        return createViewRemoteVideo(context, internalContext, callId, participantId, stream, options);
    }
    else if (!('id' in stream) && callId) {
        // Render LocalVideoStream that is part of a Call
        return createViewLocalVideo(context, internalContext, callId, options);
    }
    else if (!('id' in stream) && !callId) {
        // Render LocalVideoStream that is not part of a Call
        return createViewUnparentedVideo(context, internalContext, stream, options);
    }
    else {
        _logEvent(callingStatefulLogger, {
            name: EventNames.CREATE_STREAM_INVALID_PARAMS,
            level: 'warning',
            message: 'Create View invalid combination of parameters.'
        });
        return Promise.resolve(undefined);
    }
}
/**
 * @private
 */
function disposeView(context, internalContext, callId, participantId, stream) {
    if ('id' in stream && callId && participantId) {
        // Stop rendering RemoteVideoStream that is part of a Call
        disposeViewRemoteVideo(context, internalContext, callId, participantId, stream);
    }
    else if (!('id' in stream) && callId) {
        // Stop rendering LocalVideoStream that is part of a Call
        disposeViewLocalVideo(context, internalContext, callId);
    }
    else if (!('id' in stream) && !callId) {
        // Stop rendering LocalVideoStream that is not part of a Call
        disposeViewUnparentedVideo(context, internalContext, stream);
    }
    else {
        _logEvent(callingStatefulLogger, {
            name: EventNames.DISPOSE_STREAM_INVALID_PARAMS,
            level: 'warning',
            message: 'Dispose View invalid combination of parameters.'
        });
        return;
    }
}
/**
 * @private
 * Only stops videos that are tied to a Call.
 */
function disposeAllViewsFromCall(context, internalContext, callId) {
    const callStreams = internalContext.getRemoteRenderInfoForCall(callId);
    if (callStreams) {
        for (const [participantKey, participantStreams] of callStreams.entries()) {
            for (const [_, remoteStreamAndRenderer] of participantStreams.entries()) {
                // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to
                // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.
                disposeView(context, internalContext, callId, participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(remoteStreamAndRenderer.stream));
            }
        }
    }
    const localStreamAndRenderer = internalContext.getLocalRenderInfo(callId);
    if (localStreamAndRenderer && localStreamAndRenderer.renderer) {
        // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to
        // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.
        disposeView(context, internalContext, callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(localStreamAndRenderer.stream));
    }
}
/**
 * @private
 */
function disposeAllViews(context, internalContext) {
    const callIds = internalContext.getCallIds();
    for (const callId of callIds) {
        disposeAllViewsFromCall(context, internalContext, callId);
    }
}

/**
 * Keeps track of the listeners assigned to a particular participant because when we get an event from SDK, it doesn't
 * tell us which participant it is for. If we keep track of this then we know which participant in the state that needs
 * an update and also which property of that participant. Also we can use this when unregistering to a participant.
 */
class ParticipantSubscriber$1 {
    constructor(callIdRef, participant, context, internalContext) {
        this.subscribe = () => {
            this._participant.on('stateChanged', this.stateChanged);
            this._participant.on('isMutedChanged', this.isMutedChanged);
            this._participant.on('displayNameChanged', this.displayNameChanged);
            this._participant.on('isSpeakingChanged', this.isSpeakingChanged);
            this._participant.on('videoStreamsUpdated', this.videoStreamsUpdated);
            if (this._participant.videoStreams.length > 0) {
                for (const stream of this._participant.videoStreams) {
                    this._internalContext.setRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id, stream, 'NotRendered', undefined);
                    this.addRemoteVideoStreamSubscriber(stream);
                }
                this._context.setRemoteVideoStreams(this._callIdRef.callId, this._participantKey, this._participant.videoStreams.map(convertSdkRemoteStreamToDeclarativeRemoteStream), []);
            }
        };
        this.unsubscribe = () => {
            this._participant.off('stateChanged', this.stateChanged);
            this._participant.off('isMutedChanged', this.isMutedChanged);
            this._participant.off('displayNameChanged', this.displayNameChanged);
            this._participant.off('isSpeakingChanged', this.isSpeakingChanged);
            this._participant.off('videoStreamsUpdated', this.videoStreamsUpdated); // If unsubscribing it means the participant left the call. If they have any rendering streams we should stop them
            // as it doesn't make sense to render for an ended participant.
            if (this._participant.videoStreams.length > 0) {
                for (const stream of this._participant.videoStreams) {
                    disposeView(this._context, this._internalContext, this._callIdRef.callId, this._participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(stream));
                    this._internalContext.deleteRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id);
                }
            }
        };
        this.addRemoteVideoStreamSubscriber = (remoteVideoStream) => {
            var _a;
            (_a = this._remoteVideoStreamSubscribers.get(remoteVideoStream.id)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this._remoteVideoStreamSubscribers.set(remoteVideoStream.id, new RemoteVideoStreamSubscriber(this._callIdRef, this._participantKey, remoteVideoStream, this._context));
        };
        this.stateChanged = () => {
            this._context.setParticipantState(this._callIdRef.callId, this._participantKey, this._participant.state);
        };
        this.isMutedChanged = () => {
            this._context.setParticipantIsMuted(this._callIdRef.callId, this._participantKey, this._participant.isMuted);
        };
        this.displayNameChanged = () => {
            this._context.setParticipantDisplayName(this._callIdRef.callId, this._participantKey, this._participant.displayName || '');
        };
        this.isSpeakingChanged = () => {
            this._context.setParticipantIsSpeaking(this._callIdRef.callId, this._participantKey, this._participant.isSpeaking);
        };
        this.videoStreamsUpdated = (event) => {
            var _a;
            for (const stream of event.removed) {
                (_a = this._remoteVideoStreamSubscribers.get(stream.id)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                disposeView(this._context, this._internalContext, this._callIdRef.callId, this._participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(stream));
                this._internalContext.deleteRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id);
            }
            for (const stream of event.added) {
                this._internalContext.setRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id, stream, 'NotRendered', undefined);
                this.addRemoteVideoStreamSubscriber(stream);
            }
            this._context.setRemoteVideoStreams(this._callIdRef.callId, this._participantKey, event.added.map(convertSdkRemoteStreamToDeclarativeRemoteStream), event.removed.map((stream) => stream.id));
        };
        this._callIdRef = callIdRef;
        this._participant = participant;
        this._context = context;
        this._internalContext = internalContext;
        this._participantKey = toFlatCommunicationIdentifier(this._participant.identifier);
        this._remoteVideoStreamSubscribers = new Map();
        this.subscribe();
    }
}

/**
 * @private
 */
class RecordingSubscriber {
    constructor(callIdRef, context, recording) {
        this.subscribe = () => {
            this._recording.on('isRecordingActiveChanged', this.isAvailableChanged);
        };
        this.unsubscribe = () => {
            this._recording.off('isRecordingActiveChanged', this.isAvailableChanged);
        };
        this.isAvailableChanged = () => {
            this._context.setCallRecordingActive(this._callIdRef.callId, this._recording.isRecordingActive);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._recording = recording; // If recording as already started when we joined the call, make sure it is reflected in state as there may not
        // be an event for it.
        if (this._recording.isRecordingActive) {
            this._context.setCallRecordingActive(this._callIdRef.callId, this._recording.isRecordingActive);
        }
        this.subscribe();
    }
}

/**
 * @private
 */
class TranscriptionSubscriber {
    constructor(callIdRef, context, transcription) {
        this.subscribe = () => {
            this._transcription.on('isTranscriptionActiveChanged', this.isTranscriptionActiveChanged);
        };
        this.unsubscribe = () => {
            this._transcription.off('isTranscriptionActiveChanged', this.isTranscriptionActiveChanged);
        };
        this.isTranscriptionActiveChanged = () => {
            this._context.setCallTranscriptionActive(this._callIdRef.callId, this._transcription.isTranscriptionActive);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._transcription = transcription; // If transcription as already started when we joined the call, make sure it is reflected in state as there may not
        // be an event for it.
        if (this._transcription.isTranscriptionActive) {
            this._context.setCallTranscriptionActive(this._callIdRef.callId, this._transcription.isTranscriptionActive);
        }
        this.subscribe();
    }
}

/**
 * @private
 */
class UserFacingDiagnosticsSubscriber {
    constructor(callIdRef, context, diagnostics) {
        this.unsubscribe = () => {
            this._diagnostics.network.off('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
            this._diagnostics.media.off('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._diagnostics = diagnostics;
        this.setInitialDiagnostics();
        this.subscribe();
    }
    setInitialDiagnostics() {
        const network = this._diagnostics.network.getLatest();
        const media = this._diagnostics.media.getLatest();
        if (Object.entries(network).length === 0 && Object.entries(media).length === 0) {
            return;
        }
        this._context.modifyState(state => {
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            call.diagnostics = {
                network: {
                    latest: network
                },
                media: {
                    latest: media
                }
            };
        });
    }
    subscribe() {
        this._diagnostics.network.on('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
        this._diagnostics.media.on('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
    }
    networkDiagnosticsChanged(args) {
        this._context.modifyState(state => {
            var _a;
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            const network = (_a = call.diagnostics) === null || _a === void 0 ? void 0 : _a.network.latest;
            if (network) {
                network[args.diagnostic] = latestFromEvent(args);
            }
        });
    }
    mediaDiagnosticsChanged(args) {
        this._context.modifyState(state => {
            var _a;
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            const media = (_a = call.diagnostics) === null || _a === void 0 ? void 0 : _a.media.latest;
            if (media) {
                media[args.diagnostic] = latestFromEvent(args);
            }
        });
    }
}
const latestFromEvent = (args) => ({
    value: args.value,
    valueType: args.valueType
});

// Copyright (c) Microsoft Corporation.
/**
 * Keeps track of the listeners assigned to a particular call because when we get an event from SDK, it doesn't tell us
 * which call it is for. If we keep track of this then we know which call in the state that needs an update and also
 * which property of that call. Also we can use this when unregistering to a call.
 */
class CallSubscriber {
    constructor(call, context, internalContext) {
        this.subscribe = () => {
            this._call.on('stateChanged', this.stateChanged);
            this._call.on('idChanged', this.idChanged);
            this._call.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.on('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.on('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.on('isMutedChanged', this.isMuteChanged);
            this._call.feature(communicationCalling.Features.DominantSpeakers).on('dominantSpeakersChanged', this.dominantSpeakersChanged); // At time of writing only one LocalVideoStream is supported by SDK.
            if (this._call.localVideoStreams.length > 0) {
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, this._call.localVideoStreams[0], 'NotRendered', undefined);
            }
            if (this._call.remoteParticipants.length > 0) {
                this._call.remoteParticipants.forEach((participant) => {
                    this.addParticipantListener(participant);
                });
                this._context.setCallRemoteParticipants(this._callIdRef.callId, this._call.remoteParticipants.map(convertSdkParticipantToDeclarativeParticipant), []);
            }
        };
        this.unsubscribe = () => {
            this._call.off('stateChanged', this.stateChanged);
            this._call.off('idChanged', this.idChanged);
            this._call.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.off('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.off('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.off('isMutedChanged', this.isMuteChanged);
            this._participantSubscribers.forEach((participantSubscriber) => {
                participantSubscriber.unsubscribe();
            });
            this._participantSubscribers.clear(); // If we are unsubscribing that means we no longer want to display any video for this call (callEnded or callAgent
            // disposed) and we should not be updating it any more. So if video is rendering we stop rendering.
            if (this._call.localVideoStreams && this._call.localVideoStreams[0]) {
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(this._call.localVideoStreams[0]));
            }
            this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId);
            this._diagnosticsSubscriber.unsubscribe();
            this._recordingSubscriber.unsubscribe();
            this._transcriptionSubscriber.unsubscribe();
        };
        this.stateChanged = () => {
            this._context.setCallState(this._callIdRef.callId, this._call.state);
        };
        this.idChanged = () => {
            this._internalContext.setCallId(this._call.id, this._callIdRef.callId);
            this._context.setCallId(this._call.id, this._callIdRef.callId);
            this._callIdRef.callId = this._call.id;
        };
        this.isScreenSharingOnChanged = () => {
            this._context.setCallIsScreenSharingOn(this._callIdRef.callId, this._call.isScreenSharingOn);
        };
        this.isMuteChanged = () => {
            this._context.setCallIsMicrophoneMuted(this._callIdRef.callId, this._call.isMuted);
        };
        this.remoteParticipantsUpdated = (event) => {
            event.added.forEach((participant) => {
                this.addParticipantListener(participant);
            });
            event.removed.forEach((participant) => {
                this.removeParticipantListener(participant);
            }); // Remove any added participants from remoteParticipantsEnded if they are there and add any removed participants to
            // remoteParticipantsEnded.
            this._context.setCallRemoteParticipantsEnded(this._callIdRef.callId, event.removed.map(convertSdkParticipantToDeclarativeParticipant), event.added.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            })); // Add added participants to remoteParticipants and remove removed participants from remoteParticipants.
            this._context.setCallRemoteParticipants(this._callIdRef.callId, event.added.map(convertSdkParticipantToDeclarativeParticipant), event.removed.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            }));
        };
        this.localVideoStreamsUpdated = (event) => {
            // At time of writing only one LocalVideoStream is supported by SDK.
            if (event.added.length > 0) {
                const localVideoStreams = [convertSdkLocalStreamToDeclarativeLocalStream(this._call.localVideoStreams[0])]; // IMPORTANT: The internalContext should be set before context. This is done to ensure that the internal context
                // has the required data when component re-renders due to external state changes.
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, this._call.localVideoStreams[0], 'NotRendered', undefined);
                this._context.setCallLocalVideoStream(this._callIdRef.callId, [...localVideoStreams]);
            }
            if (event.removed.length > 0) {
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(event.removed[0]));
                this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId);
                this._context.setCallLocalVideoStream(this._callIdRef.callId, []);
            }
        };
        this.dominantSpeakersChanged = () => {
            const dominantSpeakers = this._call.feature(communicationCalling.Features.DominantSpeakers).dominantSpeakers;
            this._context.setCallDominantSpeakers(this._callIdRef.callId, dominantSpeakers);
        };
        this._call = call;
        this._callIdRef = {
            callId: call.id
        };
        this._context = context;
        this._internalContext = internalContext;
        this._diagnosticsSubscriber = new UserFacingDiagnosticsSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.UserFacingDiagnostics));
        this._participantSubscribers = new Map();
        this._recordingSubscriber = new RecordingSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Recording));
        this._transcriptionSubscriber = new TranscriptionSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Transcription));
        this.subscribe();
    }
    addParticipantListener(participant) {
        var _a;
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        (_a = this._participantSubscribers.get(participantKey)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this._participantSubscribers.set(participantKey, new ParticipantSubscriber$1(this._callIdRef, participant, this._context, this._internalContext));
    }
    removeParticipantListener(participant) {
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        const participantSubscriber = this._participantSubscribers.get(participantKey);
        if (participantSubscriber) {
            participantSubscriber.unsubscribe();
            this._participantSubscribers.delete(participantKey);
        }
    }
}

var __awaiter$i = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
class ProxyIncomingCall {
    constructor(context) {
        this._context = context;
    }
    get(target, prop) {
        switch (prop) {
            case 'accept':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$i(this, void 0, void 0, function* () {
                            return yield target.accept(...args);
                        });
                    }, 'IncomingCall.accept');
                }
            case 'reject':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$i(this, void 0, void 0, function* () {
                            return yield target.reject(...args);
                        });
                    }, 'IncomingCall.reject');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a declarative Incoming Call by proxying IncomingCall using ProxyIncomingCall.
 * @param incomingCall - IncomingCall from SDK
 * @returns proxied IncomingCall
 */
const incomingCallDeclaratify = (incomingCall, context) => {
    const proxyIncomingCall = new ProxyIncomingCall(context);
    return new Proxy(incomingCall, proxyIncomingCall);
};

/**
 * Keeps track of the listeners assigned to a particular incoming call because when we get an event from SDK, it doesn't
 * tell us which incoming call it is for. If we keep track of this then we know which incoming call in the state that
 * needs an update and also which property of that incoming call. Also we can use this when unregistering to a incoming
 * call.
 */
class IncomingCallSubscriber {
    constructor(incomingCall, // setIncomingCallEnded callback is used so parent can clean up IncomingCallSubscriber.
    setIncomingCallEnded) {
        this.subscribe = () => {
            this._incomingCall.on('callEnded', this.callEnded);
        };
        this.unsubscribe = () => {
            this._incomingCall.off('callEnded', this.callEnded);
        };
        this.callEnded = (event) => {
            this._setIncomingCallEnded(this._incomingCall.id, event.callEndReason);
        };
        this._incomingCall = incomingCall;
        this._setIncomingCallEnded = setIncomingCallEnded;
        this.subscribe();
    }
}

var __awaiter$h = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyCallAgent proxies CallAgent and saves any returned state in the given context. It will subscribe to all state
 * updates in the CallAgent and in the contained Calls and RemoteParticipants. When dispose is called it will
 * unsubscribe from all state updates.
 */
class ProxyCallAgent {
    constructor(callAgent, context, internalContext) {
        this.subscribe = () => {
            this._callAgent.on('callsUpdated', this.callsUpdated);
            this._callAgent.on('incomingCall', this.incomingCall); // There could be scenario that when ProxyCallAgent is created that the given CallAgent already has Calls. In this
            // case we need to make sure to subscribe to those already existing Calls.
            for (const call of this._callAgent.calls) {
                this.addCall(call);
            }
        };
        this.unsubscribe = () => {
            this._callAgent.off('callsUpdated', this.callsUpdated);
            this._callAgent.off('incomingCall', this.incomingCall); // Unsubscribe is called when CallAgent is disposed. This should mean no more updating of existing call but we don't
            // remove any existing state.
            for (const [_, callSubscriber] of this._callSubscribers.entries()) {
                callSubscriber.unsubscribe();
            }
            this._callSubscribers.clear();
            for (const [_, incomingCallSubscriber] of this._incomingCallSubscribers.entries()) {
                incomingCallSubscriber.unsubscribe();
            }
            this._incomingCallSubscribers.clear();
            this._declarativeIncomingCalls.clear();
            for (const [_, declarativeCall] of this._declarativeCalls.entries()) {
                declarativeCall.unsubscribe();
            }
            this._declarativeCalls.clear();
        };
        this.callsUpdated = (event) => {
            const addedStatefulCall = [];
            for (const call of event.added) {
                const statefulCall = this.addCall(call);
                addedStatefulCall.push(statefulCall);
            }
            const removedStatefulCall = [];
            for (const call of event.removed) {
                disposeAllViewsFromCall(this._context, this._internalContext, call.id);
                const callSubscriber = this._callSubscribers.get(call);
                if (callSubscriber) {
                    callSubscriber.unsubscribe();
                    this._callSubscribers.delete(call);
                }
                this._context.setCallEnded(call.id, call.callEndReason);
                const declarativeCall = this._declarativeCalls.get(call);
                if (declarativeCall) {
                    declarativeCall.unsubscribe();
                    removedStatefulCall.push(declarativeCall);
                    this._declarativeCalls.delete(call);
                }
                else {
                    removedStatefulCall.push(callDeclaratify(call, this._context));
                }
            }
            for (const externalCallsUpdatedListener of this._externalCallsUpdatedListeners) {
                externalCallsUpdatedListener({
                    added: addedStatefulCall,
                    removed: removedStatefulCall
                });
            }
        };
        this.setIncomingCallEnded = (incomingCallId, callEndReason) => {
            const incomingCallSubscriber = this._incomingCallSubscribers.get(incomingCallId);
            if (incomingCallSubscriber) {
                incomingCallSubscriber.unsubscribe();
                this._incomingCallSubscribers.delete(incomingCallId);
            }
            this._declarativeIncomingCalls.delete(incomingCallId);
            this._context.setIncomingCallEnded(incomingCallId, callEndReason);
        };
        this.incomingCall = ({ incomingCall }) => {
            // Make sure to not subscribe to the incoming call if we are already subscribed to it.
            if (!this._incomingCallSubscribers.has(incomingCall.id)) {
                this._incomingCallSubscribers.set(incomingCall.id, new IncomingCallSubscriber(incomingCall, this.setIncomingCallEnded));
            }
            this._declarativeIncomingCalls.set(incomingCall.id, incomingCallDeclaratify(incomingCall, this._context));
            this._context.setIncomingCall(convertSdkIncomingCallToDeclarativeIncomingCall(incomingCall));
        };
        this.addCall = (call) => {
            var _a;
            (_a = this._callSubscribers.get(call)) === null || _a === void 0 ? void 0 : _a.unsubscribe(); // For API extentions we need to have the call in the state when we are subscribing as we may want to update the
            // state during the subscription process in the subscriber so we add the call to state before subscribing.
            this._context.setCall(convertSdkCallToDeclarativeCall(call));
            this._callSubscribers.set(call, new CallSubscriber(call, this._context, this._internalContext));
            return this.getOrCreateDeclarativeCall(call);
        };
        this.getOrCreateDeclarativeCall = (call) => {
            const declarativeCall = this._declarativeCalls.get(call);
            if (declarativeCall) {
                return declarativeCall;
            }
            const newDeclarativeCall = callDeclaratify(call, this._context);
            this._declarativeCalls.set(call, newDeclarativeCall);
            return newDeclarativeCall;
        };
        this._callAgent = callAgent;
        this._context = context;
        this._internalContext = internalContext;
        this._callSubscribers = new Map();
        this._incomingCallSubscribers = new Map();
        this._declarativeIncomingCalls = new Map();
        this._declarativeCalls = new Map();
        this._externalCallsUpdatedListeners = new Set();
        this.subscribe();
    }
    get(target, prop) {
        switch (prop) {
            case 'startCall':
                {
                    return this._context.withErrorTeedToState((...args) => {
                        const call = target.startCall(...args);
                        this.addCall(call);
                        return this.getOrCreateDeclarativeCall(call);
                    }, 'CallAgent.startCall');
                }
            case 'join':
                {
                    return this._context.withErrorTeedToState((...args) => {
                        const call = target.join(...args);
                        this.addCall(call);
                        return this.getOrCreateDeclarativeCall(call);
                    }, 'CallAgent.join');
                }
            case 'calls':
                {
                    return Array.from(this._declarativeCalls.values());
                }
            case 'on':
                {
                    return (...args) => {
                        const isCallsUpdated = args[0] === 'callsUpdated';
                        if (isCallsUpdated) {
                            const listener = args[1];
                            this._externalCallsUpdatedListeners.add(listener);
                        }
                        else {
                            target.on(...args);
                        }
                    };
                }
            case 'off':
                {
                    return (...args) => {
                        const isCallsUpdated = args[0] === 'callsUpdated';
                        if (isCallsUpdated) {
                            const listener = args[1];
                            this._externalCallsUpdatedListeners.delete(listener);
                        }
                        else {
                            target.off(...args);
                        }
                    };
                }
            case 'dispose':
                {
                    // Wrapping CallAgent.dispose in a callback type (): Promise<void> to accomodate the change of CallAgent.dispose
                    // in calling beta version 1.8.0-beta.1 from callback type (): Promise<void> to (): void
                    const callAgentDisposeAsyncCallbackWrapper = () => __awaiter$h(this, void 0, void 0, function* () {
                        yield target.dispose();
                        return Promise.resolve();
                    });
                    return () => {
                        return callAgentDisposeAsyncCallbackWrapper().then(() => {
                            this.unsubscribe();
                        });
                    };
                }
            /**
             * This attribute is a special case and doesn't exist on the CallAgent interface.
             * We need this to be able to return a declarative incoming call object using the call agent.
             * In a standard headless SDK usage, the right way to get an incoming call is to use the `incomingCall` event.
             * However, using the declarative layer, the ideal usage would be to:
             * 1. subscribe to the `onStateChange` event
             * 2. Get the incoming call from the new state and it's ID
             * 3. Use `callAgent.incomingCalls` and filter an incoming call ID to get a declarative incoming call object
             */
            case 'incomingCalls':
                {
                    return Array.from(this._declarativeIncomingCalls.values());
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a declarative CallAgent by proxying CallAgent with ProxyCallAgent which will track state updates by updating
 * the given context.
 *
 * @param callAgent - CallAgent from SDK
 * @param context - CallContext from StatefulCallClient
 * @param internalContext- InternalCallContext from StatefulCallClient
 */
const callAgentDeclaratify = (callAgent, context, internalContext) => {
    // Make sure there are no existing call data if creating a new CallAgentDeclarative (if creating a new
    // CallAgentDeclarative after disposing of the hold one will mean context have old call state). TODO: should we stop
    // rendering when the previous callAgent is disposed?
    disposeAllViews(context, internalContext);
    context.clearCallRelatedState();
    internalContext.clearCallRelatedState();
    return new Proxy(callAgent, new ProxyCallAgent(callAgent, context, internalContext));
};

/**
 * Contains internal data used between different Declarative components to share data.
 */
class InternalCallContext {
    constructor() {
        // <CallId, <ParticipantKey, <StreamId, RemoteRenderInfo>>
        this._remoteRenderInfos = new Map(); // <CallId, LocalRenderInfo>.
        this._localRenderInfos = new Map(); // Used for keeping track of rendered LocalVideoStreams that are not part of a Call.
        // The key is the stream ID. We assume each stream ID to only have one owning render info
        this._unparentedRenderInfos = new Map();
        this._callIdHistory = new CallIdHistory();
    }
    setCallId(newCallId, oldCallId) {
        this._callIdHistory.updateCallIdHistory(newCallId, oldCallId);
        const remoteRenderInfos = this._remoteRenderInfos.get(oldCallId);
        if (remoteRenderInfos) {
            this._remoteRenderInfos.delete(oldCallId);
            this._remoteRenderInfos.set(newCallId, remoteRenderInfos);
        }
        const localRenderInfos = this._localRenderInfos.get(oldCallId);
        if (localRenderInfos) {
            this._localRenderInfos.delete(oldCallId);
            this._localRenderInfos.set(newCallId, localRenderInfos);
        }
    }
    getCallIds() {
        return this._remoteRenderInfos.keys();
    }
    getRemoteRenderInfoForCall(callId) {
        return this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
    }
    getRemoteRenderInfoForParticipant(callId, participantKey, streamId) {
        const callRenderInfos = this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!callRenderInfos) {
            return undefined;
        }
        const participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            return undefined;
        }
        return participantRenderInfos.get(streamId);
    }
    setRemoteRenderInfo(callId, participantKey, streamId, stream, status, renderer) {
        let callRenderInfos = this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!callRenderInfos) {
            callRenderInfos = new Map();
            this._remoteRenderInfos.set(this._callIdHistory.latestCallId(callId), callRenderInfos);
        }
        let participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            participantRenderInfos = new Map();
            callRenderInfos.set(participantKey, participantRenderInfos);
        }
        participantRenderInfos.set(streamId, {
            stream,
            status,
            renderer
        });
    }
    deleteRemoteRenderInfo(callId, participantKey, streamId) {
        const callRenderInfos = this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!callRenderInfos) {
            return;
        }
        const participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            return;
        }
        participantRenderInfos.delete(streamId);
    }
    setLocalRenderInfo(callId, stream, status, renderer) {
        this._localRenderInfos.set(this._callIdHistory.latestCallId(callId), {
            stream,
            status,
            renderer
        });
    }
    getLocalRenderInfo(callId) {
        return this._localRenderInfos.get(this._callIdHistory.latestCallId(callId));
    }
    deleteLocalRenderInfo(callId) {
        this._localRenderInfos.delete(this._callIdHistory.latestCallId(callId));
    }
    getUnparentedRenderInfo(localVideoStream) {
        return this._unparentedRenderInfos.get(localVideoStream.source.id);
    }
    setUnparentedRenderInfo(statefulStream, stream, status, renderer) {
        this._unparentedRenderInfos.set(statefulStream.source.id, {
            stream,
            status,
            renderer
        });
    }
    deleteUnparentedRenderInfo(localVideoStream) {
        this._unparentedRenderInfos.delete(localVideoStream.source.id);
    } // UnparentedRenderInfos are not cleared as they are not part of the Call state.
    clearCallRelatedState() {
        this._remoteRenderInfos.clear();
        this._localRenderInfos.clear();
    }
}

var __awaiter$g = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyCallClient proxies CallClient {@link @azure/communication-calling#CallClient} and subscribes to all events that
 * affect state. ProxyCallClient keeps its own copy of the call state and when state is updated, ProxyCallClient emits
 * the event 'stateChanged'.
 */
class ProxyCallClient {
    constructor(context, internalContext) {
        this._context = context;
        this._internalContext = internalContext;
    }
    get(target, prop) {
        switch (prop) {
            case 'createCallAgent':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$g(this, void 0, void 0, function* () {
                        // createCallAgent will throw an exception if the previous callAgent was not disposed. If the previous
                        // callAgent was disposed then it would have unsubscribed to events so we can just create a new declarative
                        // callAgent if the createCallAgent succeeds.
                        const callAgent = yield target.createCallAgent(...args);
                        this._callAgent = callAgentDeclaratify(callAgent, this._context, this._internalContext);
                        this._context.setCallAgent({
                            displayName: this._callAgent.displayName
                        });
                        return this._callAgent;
                    }), 'CallClient.createCallAgent');
                }
            case 'getDeviceManager':
                {
                    return this._context.withAsyncErrorTeedToState(() => __awaiter$g(this, void 0, void 0, function* () {
                        // As of writing, the SDK always returns the same instance of DeviceManager so we keep a reference of
                        // DeviceManager and if it does not change we return the cached DeclarativeDeviceManager. If it does not we'll
                        // throw an error that indicate we need to fix this issue as our implementation has diverged from the SDK.
                        const deviceManager = yield target.getDeviceManager();
                        if (this._sdkDeviceManager) {
                            if (this._sdkDeviceManager === deviceManager) {
                                return this._deviceManager;
                            }
                            else {
                                throw new Error('Multiple DeviceManager not supported. This means a incompatible version of communication-calling is ' + 'used OR calling declarative was not properly updated to communication-calling version.');
                            }
                        }
                        else {
                            this._sdkDeviceManager = deviceManager;
                        }
                        this._deviceManager = deviceManagerDeclaratify(deviceManager, this._context);
                        return this._deviceManager;
                    }), 'CallClient.getDeviceManager');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a StatefulCallClient {@link StatefulCallClient} by proxying CallClient
 * {@link @azure/communication-calling#CallClient} with ProxyCallClient {@link ProxyCallClient} which then allows access
 * to state in a declarative way.
 *
 * It is important to use the {@link @azure/communication-calling#DeviceManager} and
 * {@link @azure/communication-calling#CallAgent} and {@link @azure/communication-calling#Call} (and etc.) that are
 * obtained from the StatefulCallClient in order for their state changes to be proxied properly.
 *
 * @param args - {@link StatefulCallClientArgs}
 * @param options - {@link StatefulCallClientOptions}
 *
 * @public
 */
const createStatefulCallClient = (args, options) => {
    callingStatefulLogger.info(`Creating calling stateful client using library version: ${_getApplicationId()}`);
    return createStatefulCallClientWithDeps(new communicationCalling.CallClient(withTelemetryTag(options === null || options === void 0 ? void 0 : options.callClientOptions)), new CallContext$1(communicationCommon.getIdentifierKind(args.userId), options === null || options === void 0 ? void 0 : options.maxStateChangeListeners), new InternalCallContext());
};
/**
 * Package-internal version of createStatefulCallClient that allows dependency injection.
 *
 * This function should not be exported from the package.
 */
const createStatefulCallClientWithDeps = (callClient, context, internalContext) => {
    Object.defineProperty(callClient, 'getState', {
        configurable: false,
        value: () => context.getState()
    });
    Object.defineProperty(callClient, 'onStateChange', {
        configurable: false,
        value: (handler) => context.onStateChange(handler)
    });
    Object.defineProperty(callClient, 'offStateChange', {
        configurable: false,
        value: (handler) => context.offStateChange(handler)
    });
    Object.defineProperty(callClient, 'createView', {
        configurable: false,
        value: (callId, participantId, stream, options) => {
            const participantIdKind = participantId ? communicationCommon.getIdentifierKind(participantId) : undefined;
            return createView(context, internalContext, callId, participantIdKind, stream, options);
        }
    });
    Object.defineProperty(callClient, 'disposeView', {
        configurable: false,
        value: (callId, participantId, stream) => {
            const participantIdKind = participantId ? communicationCommon.getIdentifierKind(participantId) : undefined;
            disposeView(context, internalContext, callId, participantIdKind, stream);
        }
    });
    return new Proxy(callClient, new ProxyCallClient(context, internalContext));
};
const withTelemetryTag = (options) => {
    var _a, _b;
    const tags = (_b = (_a = options === null || options === void 0 ? void 0 : options.diagnostics) === null || _a === void 0 ? void 0 : _a.tags) !== null && _b !== void 0 ? _b : [];
    tags.push(_getApplicationId());
    return Object.assign(Object.assign({}, options), { diagnostics: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.diagnostics), { tags }) });
};

/**
 * Error thrown from failed {@link StatefulChatClient} methods.
 *
 * @public
 */
class ChatError extends Error {
    constructor(target, innerError, timestamp) {
        super();
        this.target = target;
        this.innerError = innerError; // Testing note: It is easier to mock Date::now() than the Date() constructor.
        this.timestamp = timestamp !== null && timestamp !== void 0 ? timestamp : new Date(Date.now());
        this.name = 'ChatError';
        this.message = `${this.target}: ${this.innerError.message}`;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const Constants = {
    TYPING_INDICATOR_MAINTAIN_TIME: 8 * 1000,
    DUMMY_DATE: new Date(0)
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const chatStatefulLogger = logger.createClientLogger('communication-react:chat-stateful');

var __awaiter$f = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
produce.enableMapSet(); // Needed to generate state diff for verbose logging.
produce.enablePatches();
/**
 * @private
 */
class ChatContext$1 {
    constructor(maxListeners) {
        this._state = {
            userId: {
                id: ''
            },
            displayName: '',
            threads: {},
            latestErrors: {}
        };
        this._batchMode = false;
        this.typingIndicatorInterval = undefined;
        this._logger = logger.createClientLogger('communication-react:chat-context');
        this._emitter = new EventEmitter__default['default']();
        if (maxListeners) {
            this._emitter.setMaxListeners(maxListeners);
        }
    }
    getState() {
        return this._state;
    }
    modifyState(modifier) {
        const priorState = this._state;
        this._state = produce__default['default'](this._state, modifier, (patches) => {
            if (logger.getLogLevel() === 'verbose') {
                // Log to `info` because AzureLogger.verbose() doesn't show up in console.
                this._logger.info(`State change: ${_safeJSONStringify(patches)}`);
            }
        });
        if (!this._batchMode && this._state !== priorState) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    setThread(threadId, threadState) {
        this.modifyState((draft) => {
            draft.threads[threadId] = threadState;
        });
    }
    createThread(threadId, properties) {
        this.modifyState((draft) => {
            draft.threads[threadId] = {
                chatMessages: {},
                threadId: threadId,
                properties: properties,
                participants: {},
                readReceipts: [],
                typingIndicators: [],
                latestReadTime: new Date(0)
            };
        });
    }
    updateChatConfig(userId, displayName) {
        this.modifyState((draft) => {
            draft.displayName = displayName;
            draft.userId = userId;
        });
    }
    createThreadIfNotExist(threadId, properties) {
        const exists = Object.prototype.hasOwnProperty.call(this.getState().threads, threadId);
        if (!exists) {
            this.createThread(threadId, properties);
            return true;
        }
        return false;
    }
    updateThread(threadId, properties) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                thread.properties = properties;
            }
        });
    }
    updateThreadTopic(threadId, topic) {
        this.modifyState((draft) => {
            if (topic === undefined) {
                return;
            }
            const thread = draft.threads[threadId];
            if (thread && !thread.properties) {
                thread.properties = {
                    topic: topic
                };
            }
            else if (thread && thread.properties) {
                thread.properties.topic = topic;
            }
        });
    }
    deleteThread(threadId) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                delete draft.threads[threadId];
            }
        });
    }
    setChatMessages(threadId, messages) {
        this.modifyState((draft) => {
            const threadState = draft.threads[threadId];
            if (threadState) {
                threadState.chatMessages = messages;
            } // remove typing indicator when receive messages
            const thread = draft.threads[threadId];
            if (thread) {
                for (const message of Object.values(messages)) {
                    this.filterTypingIndicatorForUser(thread, message.sender);
                }
            }
        });
    }
    updateChatMessageContent(threadId, messagesId, content) {
        this.modifyState((draft) => {
            var _a;
            const chatMessage = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[messagesId];
            if (chatMessage) {
                if (!chatMessage.content) {
                    chatMessage.content = {};
                }
                chatMessage.content.message = content;
            }
        });
    }
    deleteLocalMessage(threadId, localId) {
        let localMessageDeleted = false;
        this.modifyState((draft) => {
            var _a;
            const chatMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
            const message = chatMessages ? chatMessages[localId] : undefined;
            if (chatMessages && message && message.clientMessageId) {
                delete chatMessages[message.clientMessageId];
                localMessageDeleted = true;
            }
        });
        return localMessageDeleted;
    }
    deleteMessage(threadId, id) {
        this.modifyState((draft) => {
            var _a;
            const chatMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
            if (chatMessages) {
                delete chatMessages[id];
            }
        });
    }
    setParticipant(threadId, participant) {
        this.modifyState((draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                participants[toFlatCommunicationIdentifier(participant.id)] = participant;
            }
        });
    }
    setParticipants(threadId, participants) {
        this.modifyState((draft) => {
            var _a;
            const participantsMap = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participantsMap) {
                for (const participant of participants) {
                    participantsMap[toFlatCommunicationIdentifier(participant.id)] = participant;
                }
            }
        });
    }
    deleteParticipants(threadId, participantIds) {
        this.modifyState((draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                participantIds.forEach(id => {
                    delete participants[toFlatCommunicationIdentifier(id)];
                });
            }
        });
    }
    deleteParticipant(threadId, participantId) {
        this.modifyState((draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                delete participants[toFlatCommunicationIdentifier(participantId)];
            }
        });
    }
    addReadReceipt(threadId, readReceipt) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            const readReceipts = thread === null || thread === void 0 ? void 0 : thread.readReceipts;
            if (thread && readReceipts) {
                // TODO(prprabhu): Replace `this.getState()` with `draft`?
                if (readReceipt.sender !== this.getState().userId && thread.latestReadTime < readReceipt.readOn) {
                    thread.latestReadTime = readReceipt.readOn;
                }
                readReceipts.push(readReceipt);
            }
        });
    }
    startTypingIndicatorCleanUp() {
        if (this.typingIndicatorInterval) {
            return;
        }
        this.typingIndicatorInterval = window.setInterval(() => {
            let isTypingActive = false;
            this.modifyState((draft) => {
                for (const thread of Object.values(draft.threads)) {
                    const filteredTypingIndicators = thread.typingIndicators.filter(typingIndicator => {
                        const timeGap = Date.now() - typingIndicator.receivedOn.getTime();
                        return timeGap < Constants.TYPING_INDICATOR_MAINTAIN_TIME;
                    });
                    if (thread.typingIndicators.length !== filteredTypingIndicators.length) {
                        thread.typingIndicators = filteredTypingIndicators;
                    }
                    if (thread.typingIndicators.length > 0) {
                        isTypingActive = true;
                    }
                }
            });
            if (!isTypingActive && this.typingIndicatorInterval) {
                window.clearInterval(this.typingIndicatorInterval);
                this.typingIndicatorInterval = undefined;
            }
        }, 1000);
    }
    addTypingIndicator(threadId, typingIndicator) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                const typingIndicators = thread.typingIndicators;
                typingIndicators.push(typingIndicator);
            }
        }); // Make sure we only maintain a period of typing indicator for perf purposes
        this.startTypingIndicatorCleanUp();
    }
    setChatMessage(threadId, message) {
        const { id: messageId, clientMessageId } = message;
        if (messageId || clientMessageId) {
            this.modifyState((draft) => {
                var _a;
                const threadMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
                const isLocalIdInMap = threadMessages && clientMessageId && threadMessages[clientMessageId];
                const messageKey = !messageId || isLocalIdInMap ? clientMessageId : messageId;
                if (threadMessages && messageKey) {
                    threadMessages[messageKey] = message;
                } // remove typing indicator when receive a message from a user
                const thread = draft.threads[threadId];
                if (thread) {
                    this.filterTypingIndicatorForUser(thread, message.sender);
                }
            });
        }
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param f Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws ChatError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(f, target) {
        return (...args) => __awaiter$f(this, void 0, void 0, function* () {
            try {
                return yield f(...args);
            }
            catch (error) {
                const chatError = toChatError(target, error);
                this.setLatestError(target, chatError);
                throw chatError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param f Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws ChatError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(f, target) {
        return (...args) => {
            try {
                chatStatefulLogger.info(`Chat stateful client target function called: ${target}`);
                return f(...args);
            }
            catch (error) {
                const chatError = toChatError(target, error);
                this.setLatestError(target, chatError);
                throw chatError;
            }
        };
    }
    setLatestError(target, error) {
        this.modifyState((draft) => {
            draft.latestErrors[target] = error;
        });
    } // This is a mutating function, only use it inside of a produce() function
    filterTypingIndicatorForUser(thread, userId) {
        if (!userId) {
            return;
        }
        const typingIndicators = thread.typingIndicators;
        const userIdAsKey = toFlatCommunicationIdentifier(userId);
        const filteredTypingIndicators = typingIndicators.filter(typingIndicator => toFlatCommunicationIdentifier(typingIndicator.sender) !== userIdAsKey);
        if (filteredTypingIndicators.length !== typingIndicators.length) {
            thread.typingIndicators = filteredTypingIndicators;
        }
    }
    /**
     * Batch updates to minimize `stateChanged` events across related operations.
     *
     * - A maximum of one `stateChanged` event is emitted, at the end of the operations.
     * - No `stateChanged` event is emitted if the state did not change through the operations.
     * - In case of an exception, state is reset to the prior value and no `stateChanged` event is emitted.
     *
     * All operations finished in this batch should be synchronous.
     * This function is not reentrant -- do not call batch() from within another batch().
     */
    batch(operations) {
        if (this._batchMode) {
            throw new Error('batch() called from within another batch()');
        }
        this._batchMode = true;
        const priorState = this._state;
        try {
            operations();
            if (this._state !== priorState) {
                this._emitter.emit('stateChanged', this._state);
            }
        }
        catch (e) {
            this._state = priorState;
            if (logger.getLogLevel() === 'verbose') {
                this._logger.warning(`State rollback to: ${_safeJSONStringify(priorState)}`);
            }
            throw e;
        }
        finally {
            this._batchMode = false;
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    }
}
const toChatError = (target, error) => {
    if (error instanceof Error) {
        return new ChatError(target, error);
    }
    return new ChatError(target, new Error(`${error}`));
};

/**
 * @private
 */
const convertChatMessage = (message, status = 'delivered', clientMessageId) => {
    return Object.assign(Object.assign({}, message), { clientMessageId: clientMessageId, status });
};

var __awaiter$e = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues$1 = (window && window.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
// Maximum time to look back message list when we receive a system event
const maxSyncTimeInMs = 10 * 1000;
/**
 * @private
 */
class EventSubscriber {
    constructor(chatClient, chatContext) {
        this.convertEventToChatMessage = (event) => {
            return convertChatMessage({
                id: event.id,
                version: event.version,
                content: {
                    message: event.message
                },
                type: this.convertEventType(event.type),
                sender: event.sender,
                senderDisplayName: event.senderDisplayName,
                sequenceId: '',
                // Note: there is a bug in chatMessageReceived event that it is missing sequenceId
                createdOn: new Date(event.createdOn),
                editedOn: 'editedOn' in event ? event.editedOn : undefined,
                metadata: event.metadata
            });
        }; // convert event type to chatMessage type, only possible type is 'html' and 'text' in chat event
        this.convertEventType = (type) => {
            const lowerCaseType = type.toLowerCase();
            if (lowerCaseType === 'richtext/html' || lowerCaseType === 'html') {
                return 'html';
            }
            else {
                return 'text';
            }
        };
        this.onChatMessageReceived = (event) => {
            var _a;
            // Today we are avoiding how to render these messages. In the future we can
            // remove this condition and handle this message appropriately.
            const messageEventType = event.type.toLowerCase();
            if (messageEventType !== 'text' && messageEventType !== 'richtext/html' && messageEventType !== 'html') {
                return;
            }
            const newMessage = this.convertEventToChatMessage(event); // Because of bug in chatMessageReceived event, if we already have that particular message in context, we want to
            // make sure to not overwrite the sequenceId when calling setChatMessage.
            const existingMessage = (_a = this.chatContext.getState().threads[event.threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[event.id];
            if (existingMessage) {
                newMessage.sequenceId = existingMessage.sequenceId;
            }
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.setChatMessage(event.threadId, newMessage);
            });
        };
        this.onChatMessageDeleted = (event) => {
            this.chatContext.deleteMessage(event.threadId, event.id);
        };
        this.onChatMessageEdited = (event) => {
            const editedMessage = this.convertEventToChatMessage(event);
            this.chatContext.setChatMessage(event.threadId, convertChatMessage(editedMessage));
        };
        this.onParticipantsAdded = (event) => {
            const participantsToAdd = event.participantsAdded.map(participant => (Object.assign(Object.assign({}, participant), { shareHistoryTime: participant.shareHistoryTime ? new Date(participant.shareHistoryTime) : undefined })));
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.setParticipants(event.threadId, participantsToAdd);
            });
            this.fetchLastParticipantMessage(event.threadId, 'participantAdded');
        }; // This is a hot fix that no participant message is received for onChatMessageReceived event, which should be handled by JS SDK
        this.fetchLastParticipantMessage = (threadId, actionType) => __awaiter$e(this, void 0, void 0, function* () {
            var e_1, _a;
            try {
                for (var _b = __asyncValues$1(this.chatClient.getChatThreadClient(threadId).listMessages({
                    startTime: new Date(Date.now() - maxSyncTimeInMs)
                })), _c; _c = yield _b.next(), !_c.done;) {
                    const message = _c.value;
                    if (message.type === actionType) {
                        this.chatContext.setChatMessage(threadId, Object.assign(Object.assign({}, message), { status: 'delivered' }));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        this.onParticipantsRemoved = (event) => {
            const participantIds = event.participantsRemoved.map(participant => {
                return participant.id;
            });
            this.chatContext.deleteParticipants(event.threadId, participantIds);
            this.fetchLastParticipantMessage(event.threadId, 'participantRemoved');
        };
        this.onReadReceiptReceived = (event) => {
            const readReceipt = Object.assign(Object.assign({}, event), { sender: event.sender, readOn: new Date(event.readOn) });
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.addReadReceipt(event.threadId, readReceipt);
            });
        };
        this.onTypingIndicatorReceived = (typingIndicator) => {
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(typingIndicator.threadId);
                this.chatContext.addTypingIndicator(typingIndicator.threadId, typingIndicator);
            });
        };
        this.onChatThreadCreated = (event) => {
            const properties = {
                topic: event.properties.topic
            };
            if (!this.chatContext.createThreadIfNotExist(event.threadId, properties)) {
                this.chatContext.updateThread(event.threadId, properties);
            }
        };
        this.onChatThreadDeleted = (event) => {
            this.chatContext.deleteThread(event.threadId);
        };
        this.onChatThreadPropertiesUpdated = (event) => {
            this.chatContext.updateThread(event.threadId, {
                topic: event.properties.topic
            });
        };
        this.subscribe = () => {
            this.chatClient.on('chatMessageReceived', this.onChatMessageReceived);
            this.chatClient.on('chatMessageDeleted', this.onChatMessageDeleted);
            this.chatClient.on('chatMessageEdited', this.onChatMessageEdited);
            this.chatClient.on('participantsAdded', this.onParticipantsAdded);
            this.chatClient.on('participantsRemoved', this.onParticipantsRemoved);
            this.chatClient.on('readReceiptReceived', this.onReadReceiptReceived);
            this.chatClient.on('typingIndicatorReceived', this.onTypingIndicatorReceived);
            this.chatClient.on('chatThreadCreated', this.onChatThreadCreated);
            this.chatClient.on('chatThreadDeleted', this.onChatThreadDeleted);
            this.chatClient.on('chatThreadPropertiesUpdated', this.onChatThreadPropertiesUpdated);
        };
        this.unsubscribe = () => {
            this.chatClient.off('chatMessageReceived', this.onChatMessageReceived);
            this.chatClient.off('chatMessageDeleted', this.onChatMessageDeleted);
            this.chatClient.off('chatMessageEdited', this.onChatMessageEdited);
            this.chatClient.off('participantsAdded', this.onParticipantsAdded);
            this.chatClient.off('participantsRemoved', this.onParticipantsRemoved);
            this.chatClient.off('readReceiptReceived', this.onReadReceiptReceived);
            this.chatClient.off('typingIndicatorReceived', this.onTypingIndicatorReceived);
            this.chatClient.off('chatThreadCreated', this.onChatThreadCreated);
            this.chatClient.off('chatThreadDeleted', this.onChatThreadDeleted);
            this.chatClient.off('chatThreadPropertiesUpdated', this.onChatThreadPropertiesUpdated);
        };
        this.chatClient = chatClient;
        this.chatContext = chatContext;
        this.subscribe();
    }
}

var __awaiter$d = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create a decorated iterator
 * returned iterators.
 *
 * @param iteratorCreator the function to create the original iterator
 * @param context chatContext
 * @param decorateFn the function for the decorating behavior
 */
const createDecoratedIterator = (iteratorCreator, context, decorateFn) => {
    return (...args) => {
        const threadsIterator = iteratorCreator(...args);
        return {
            next() {
                return __awaiter$d(this, void 0, void 0, function* () {
                    const result = yield threadsIterator.next();
                    if (!result.done && result.value) {
                        decorateFn(result.value, context);
                    }
                    return result;
                });
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                const pages = threadsIterator.byPage(settings);
                return {
                    next() {
                        return __awaiter$d(this, void 0, void 0, function* () {
                            const result = yield pages.next();
                            const page = result.value;
                            if (!result.done && result.value) {
                                context.batch(() => {
                                    for (const item of page) {
                                        decorateFn(item, context);
                                    }
                                });
                            }
                            return result;
                        });
                    },
                    [Symbol.asyncIterator]() {
                        return this;
                    }
                };
            }
        };
    };
};
/**
 *
 * @param iteratorCreator Function that creates the base iteartor
 * @param context The ChatContext that stores all internal state.
 * @param target See {@link ChatContext.asyncTeeErrorToState}.
 * @returns A function to create an iterator that handles errors when iterting over the iterator from `iteratorCreator`.
 */
const createErrorHandlingIterator = (iteratorCreator, context, target) => {
    return (...args) => {
        const innerIter = iteratorCreator(...args);
        return {
            next: context.withAsyncErrorTeedToState(innerIter.next.bind(innerIter), target),
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                const pages = innerIter.byPage(settings);
                return {
                    next: context.withAsyncErrorTeedToState(pages.next.bind(pages), target),
                    [Symbol.asyncIterator]() {
                        return this;
                    }
                };
            }
        };
    };
};

/**
 * @private
 */
const createDecoratedListMessages = (chatThreadClient, context) => {
    const setMessage = (message, context) => {
        context.setChatMessage(chatThreadClient.threadId, convertChatMessage(message));
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listMessages.bind(chatThreadClient), 'ChatThreadClient.listMessages'), context, 'ChatThreadClient.listMessages'), context, setMessage);
};

/**
 * @private
 */
const createDecoratedListReadReceipts = (chatThreadClient, context) => {
    const setReadReceipt = (readReceipt, context) => {
        context.addReadReceipt(chatThreadClient.threadId, Object.assign({}, readReceipt));
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listReadReceipts.bind(chatThreadClient), 'ChatThreadClient.listReadReceipts'), context, 'ChatThreadClient.listReadReceipts'), context, setReadReceipt);
};

/**
 * @private
 */
const createDecoratedListParticipants = (chatThreadClient, context) => {
    const setParticipant = (participant, context) => {
        context.setParticipant(chatThreadClient.threadId, participant);
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listParticipants.bind(chatThreadClient), 'ChatThreadClient.listParticipants'), context, 'ChatThreadClient.listParticipants'), context, setParticipant);
};

var __awaiter$c = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProxyChatThreadClient {
    constructor(context) {
        this._context = context;
    }
    get(chatThreadClient, prop) {
        switch (prop) {
            case 'listMessages':
                {
                    return createDecoratedListMessages(chatThreadClient, this._context);
                }
            case 'getMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$c(this, void 0, void 0, function* () {
                        const message = yield chatThreadClient.getMessage(...args);
                        this._context.setChatMessage(chatThreadClient.threadId, convertChatMessage(message));
                        return message;
                    }), 'ChatThreadClient.getMessage');
                }
            case 'sendMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$c(this, void 0, void 0, function* () {
                        // Retry logic?
                        const [request, options] = args;
                        const { content } = request;
                        const clientMessageId = nanoid.nanoid(); // Generate a local short uuid for message
                        const newMessage = {
                            content: {
                                message: content
                            },
                            clientMessageId,
                            id: '',
                            type: 'text',
                            sequenceId: '',
                            version: '',
                            createdOn: new Date(),
                            status: 'sending',
                            senderDisplayName: this._context.getState().displayName,
                            sender: this._context.getState().userId,
                            metadata: options === null || options === void 0 ? void 0 : options.metadata
                        };
                        this._context.setChatMessage(chatThreadClient.threadId, newMessage);
                        let result = undefined;
                        try {
                            result = yield chatThreadClient.sendMessage(...args);
                        }
                        catch (e) {
                            this._context.setChatMessage(chatThreadClient.threadId, Object.assign(Object.assign({}, newMessage), { status: 'failed' }));
                            throw e;
                        }
                        if (result === null || result === void 0 ? void 0 : result.id) {
                            this._context.batch(() => {
                                if (!result) {
                                    return;
                                }
                                this._context.setChatMessage(chatThreadClient.threadId, Object.assign(Object.assign({}, newMessage), { clientMessageId: undefined, status: 'delivered', id: result.id }));
                                this._context.deleteLocalMessage(chatThreadClient.threadId, clientMessageId);
                            });
                        }
                        return result;
                    }), 'ChatThreadClient.sendMessage');
                }
            case 'addParticipants':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$c(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.addParticipants(...args);
                        const [addRequest] = args;
                        const participantsToAdd = addRequest.participants;
                        this._context.setParticipants(chatThreadClient.threadId, participantsToAdd);
                        return result;
                    }), 'ChatThreadClient.addParticipants');
                }
            case 'deleteMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$c(this, void 0, void 0, function* () {
                        // DeleteMessage is able to either delete local one(for failed message) or synced message
                        const [messageId] = args;
                        if (this._context.deleteLocalMessage(chatThreadClient.threadId, messageId)) {
                            return {};
                        }
                        const result = yield chatThreadClient.deleteMessage(...args);
                        this._context.deleteMessage(chatThreadClient.threadId, messageId);
                        return result;
                    }), 'ChatThreadClient.deleteMessage');
                }
            case 'listParticipants':
                {
                    return createDecoratedListParticipants(chatThreadClient, this._context);
                }
            case 'listReadReceipts':
                {
                    return createDecoratedListReadReceipts(chatThreadClient, this._context);
                }
            case 'removeParticipant':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$c(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.removeParticipant(...args);
                        const [removeIdentifier] = args;
                        this._context.deleteParticipant(chatThreadClient.threadId, communicationCommon.getIdentifierKind(removeIdentifier));
                        return result;
                    }), 'ChatThreadClient.removeParticipant');
                }
            case 'updateMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$c(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.updateMessage(...args);
                        const [messageId, updateOption] = args;
                        this._context.updateChatMessageContent(chatThreadClient.threadId, messageId, updateOption === null || updateOption === void 0 ? void 0 : updateOption.content);
                        return result;
                    }), 'ChatThreadClient.updateMessage');
                }
            case 'updateTopic':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$c(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.updateTopic(...args);
                        const [topic] = args;
                        this._context.updateThreadTopic(chatThreadClient.threadId, topic);
                        return result;
                    }), 'ChatThreadClient.updateTopic');
                }
            case 'getProperties':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$c(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.getProperties(...args);
                        this._context.updateThread(chatThreadClient.threadId, result);
                        return result;
                    }), 'ChatThreadClient.getProperties');
                }
            default:
                return Reflect.get(chatThreadClient, prop);
        }
    }
}
/**
 * @private
 */
const chatThreadClientDeclaratify = (chatThreadClient, context) => {
    context.createThreadIfNotExist(chatThreadClient.threadId);
    return new Proxy(chatThreadClient, new ProxyChatThreadClient(context));
};

/**
 * @private
 */
const createDecoratedListThreads = (chatClient, context) => {
    const setThreadProperties = (chatThreadItem, context) => {
        const properties = {
            topic: chatThreadItem.topic
        };
        if (!context.createThreadIfNotExist(chatThreadItem.id, properties)) {
            context.updateThread(chatThreadItem.id, properties);
        }
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatClient.listChatThreads.bind(chatClient), 'ChatClient.listChatThreads'), context, 'ChatClient.listChatThreads'), context, setThreadProperties);
};

var __awaiter$b = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const proxyChatClient = {
    get: function (chatClient, prop, receiver) {
        // skip receiver.context call to avoid recursive bugs
        if (prop === 'context') {
            return Reflect.get(chatClient, prop);
        }
        const context = receiver.context;
        switch (prop) {
            case 'createChatThread':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$b(this, void 0, void 0, function* () {
                            const result = yield chatClient.createChatThread(...args);
                            const thread = result.chatThread;
                            if (thread) {
                                const [request] = args;
                                context.createThread(thread.id, {
                                    topic: request.topic
                                });
                            }
                            return result;
                        });
                    }, 'ChatClient.createChatThread');
                }
            case 'deleteChatThread':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$b(this, void 0, void 0, function* () {
                            const result = yield chatClient.deleteChatThread(...args);
                            context.deleteThread(args[0]);
                            return result;
                        });
                    }, 'ChatClient.deleteChatThread');
                }
            case 'listChatThreads':
                {
                    return createDecoratedListThreads(chatClient, context);
                }
            case 'getChatThreadClient':
                {
                    return function (...args) {
                        const chatThreadClient = chatClient.getChatThreadClient(...args); // TODO(prprabhu): Ensure that thread properties are fetched into the ChatContext at this point.
                        // A new thread might be created here, but the properties will never be fetched.
                        return chatThreadClientDeclaratify(chatThreadClient, context);
                    };
                }
            case 'startRealtimeNotifications':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$b(this, void 0, void 0, function* () {
                            const ret = yield chatClient.startRealtimeNotifications(...args);
                            if (!receiver.eventSubscriber) {
                                receiver.eventSubscriber = new EventSubscriber(chatClient, context);
                            }
                            return ret;
                        });
                    }, 'ChatClient.startRealtimeNotifications');
                }
            case 'stopRealtimeNotifications':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$b(this, void 0, void 0, function* () {
                            const ret = yield chatClient.stopRealtimeNotifications(...args);
                            if (receiver.eventSubscriber) {
                                receiver.eventSubscriber.unsubscribe();
                                receiver.eventSubscriber = undefined;
                            }
                            return ret;
                        });
                    }, 'ChatClient.stopRealtimeNotifications');
                }
            default:
                return Reflect.get(chatClient, prop);
        }
    }
};
/**
 * Creates a stateful ChatClient {@link StatefulChatClient} by proxying ChatClient
 * {@link @azure/communication-chat#ChatClient} with ProxyChatClient {@link ProxyChatClient} which then allows access
 * to state in a declarative way.
 *
 * @public
 */
const createStatefulChatClient = (args, options) => {
    chatStatefulLogger.info(`Creating chat stateful client using library version: ${_getApplicationId()}`);
    const tweakedOptions = Object.assign(Object.assign({}, options), { chatClientOptions: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.chatClientOptions), { userAgentOptions: {
                userAgentPrefix: _getApplicationId()
            } }) });
    return _createStatefulChatClientWithDeps(new communicationChat.ChatClient(args.endpoint, args.credential, tweakedOptions.chatClientOptions), args, tweakedOptions);
};
/**
 * Internal implementation of {@link createStatefulChatClient} for dependency injection.
 *
 * Used by tests. Should not be exported out of this package.
 * @internal
 */
const _createStatefulChatClientWithDeps = (chatClient, args, options) => {
    const context = new ChatContext$1(options === null || options === void 0 ? void 0 : options.maxStateChangeListeners);
    let eventSubscriber;
    context.updateChatConfig(communicationCommon.getIdentifierKind(args.userId), args.displayName);
    const proxy = new Proxy(chatClient, proxyChatClient);
    Object.defineProperty(proxy, 'context', {
        configurable: false,
        get: () => context
    });
    Object.defineProperty(proxy, 'eventSubscriber', {
        configurable: false,
        get: () => eventSubscriber,
        set: (val) => {
            eventSubscriber = val;
        }
    });
    Object.defineProperty(proxy, 'getState', {
        configurable: false,
        value: () => context === null || context === void 0 ? void 0 : context.getState()
    });
    Object.defineProperty(proxy, 'onStateChange', {
        configurable: false,
        value: (handler) => context === null || context === void 0 ? void 0 : context.onStateChange(handler)
    });
    Object.defineProperty(proxy, 'offStateChange', {
        configurable: false,
        value: (handler) => context === null || context === void 0 ? void 0 : context.offStateChange(handler)
    });
    return proxy;
};

var __awaiter$a = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (window && window.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
/**
 * Context of Chat, which is a centralized context for all state updates
 * @private
 */
class ChatContext {
    constructor(clientState, threadId) {
        this.emitter = new EventEmitter__default['default']();
        const thread = clientState.threads[threadId];
        this.threadId = threadId;
        if (!thread) {
            throw 'Cannot find threadId, please initialize thread before use!';
        }
        this.state = {
            userId: clientState.userId,
            displayName: clientState.displayName,
            thread,
            latestErrors: clientState.latestErrors
        };
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setError(error) {
        this.setState(Object.assign(Object.assign({}, this.state), { error }));
    }
    updateClientState(clientState) {
        const thread = clientState.threads[this.threadId];
        if (!thread) {
            throw 'Cannot find threadId, please make sure thread state is still in Stateful ChatClient.';
        }
        let updatedState = {
            userId: clientState.userId,
            displayName: clientState.displayName,
            thread,
            latestErrors: clientState.latestErrors
        };
        this.setState(updatedState);
    }
}
/**
 * @private
 */
class AzureCommunicationChatAdapter {
    constructor(chatClient, chatThreadClient) {
        this.emitter = new EventEmitter__default['default']();
        this.bindAllPublicMethods();
        this.chatClient = chatClient;
        this.chatThreadClient = chatThreadClient;
        this.context = new ChatContext(chatClient.getState(), chatThreadClient.threadId);
        const onStateChange = (clientState) => {
            // unsubscribe when the instance gets disposed
            if (!this) {
                chatClient.offStateChange(onStateChange);
                return;
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createDefaultChatHandlers(chatClient, chatThreadClient);
        this.chatClient.onStateChange(onStateChange);
        this.subscribeAllEvents();
    }
    bindAllPublicMethods() {
        this.onStateChange = this.onStateChange.bind(this);
        this.offStateChange = this.offStateChange.bind(this);
        this.getState = this.getState.bind(this);
        this.dispose = this.dispose.bind(this);
        this.fetchInitialData = this.fetchInitialData.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.sendReadReceipt = this.sendReadReceipt.bind(this);
        this.sendTypingIndicator = this.sendTypingIndicator.bind(this);
        this.updateMessage = this.updateMessage.bind(this);
        this.deleteMessage = this.deleteMessage.bind(this);
        this.removeParticipant = this.removeParticipant.bind(this);
        this.setTopic = this.setTopic.bind(this);
        this.loadPreviousChatMessages = this.loadPreviousChatMessages.bind(this);
        this.on = this.on.bind(this);
        this.off = this.off.bind(this);
    }
    dispose() {
        this.unsubscribeAllEvents();
    }
    fetchInitialData() {
        return __awaiter$a(this, void 0, void 0, function* () {
            // If get properties fails we dont want to try to get the participants after.
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$a(this, void 0, void 0, function* () {
                var e_1, _a;
                yield this.chatThreadClient.getProperties(); // Fetch all participants who joined before the local user.
                try {
                    for (var _b = __asyncValues(this.chatThreadClient.listParticipants().byPage({
                        // Fetch 100 participants per page by default.
                        maxPageSize: 100 // eslint-disable-next-line curly
                    })), _c; _c = yield _b.next(), !_c.done;) {
                        const _page = _c.value;
                        ;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }));
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    sendMessage(content, options = {}) {
        return __awaiter$a(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$a(this, void 0, void 0, function* () {
                yield this.handlers.onSendMessage(content, options);
            }));
        });
    }
    sendReadReceipt(chatMessageId) {
        return __awaiter$a(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$a(this, void 0, void 0, function* () {
                yield this.handlers.onMessageSeen(chatMessageId);
            }));
        });
    }
    sendTypingIndicator() {
        return __awaiter$a(this, void 0, void 0, function* () {
            yield this.handlers.onTyping();
        });
    }
    removeParticipant(userId) {
        return __awaiter$a(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$a(this, void 0, void 0, function* () {
                yield this.handlers.onRemoveParticipant(userId);
            }));
        });
    }
    setTopic(topicName) {
        return __awaiter$a(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$a(this, void 0, void 0, function* () {
                yield this.handlers.updateThreadTopicName(topicName);
            }));
        });
    }
    loadPreviousChatMessages(messagesToLoad) {
        return __awaiter$a(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$a(this, void 0, void 0, function* () {
                return yield this.handlers.onLoadPreviousChatMessages(messagesToLoad);
            }));
        });
    }
    updateMessage(messageId, content, metadata, options) {
        return __awaiter$a(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$a(this, void 0, void 0, function* () {
                return yield this.handlers.onUpdateMessage(messageId, content);
            }));
        });
    }
    deleteMessage(messageId) {
        return __awaiter$a(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$a(this, void 0, void 0, function* () {
                return yield this.handlers.onDeleteMessage(messageId);
            }));
        });
    }
    messageReceivedListener(event) {
        const message = convertEventToChatMessage(event);
        this.emitter.emit('messageReceived', {
            message
        });
        const currentUserId = toFlatCommunicationIdentifier(this.chatClient.getState().userId);
        if ((message === null || message === void 0 ? void 0 : message.sender) && toFlatCommunicationIdentifier(message.sender) === currentUserId) {
            this.emitter.emit('messageSent', {
                message
            });
        }
    }
    messageReadListener({ chatMessageId, recipient }) {
        const message = this.getState().thread.chatMessages[chatMessageId];
        if (message) {
            this.emitter.emit('messageRead', {
                message,
                readBy: recipient
            });
        }
    }
    participantsAddedListener({ addedBy, participantsAdded }) {
        this.emitter.emit('participantsAdded', {
            addedBy,
            participantsAdded
        });
    }
    participantsRemovedListener({ removedBy, participantsRemoved }) {
        this.emitter.emit('participantsRemoved', {
            removedBy,
            participantsRemoved
        });
    }
    chatThreadPropertiesUpdatedListener(event) {
        this.emitter.emit('topicChanged', {
            topic: event.properties.topic
        });
    }
    subscribeAllEvents() {
        this.chatClient.on('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));
        this.chatClient.on('participantsAdded', this.participantsAddedListener.bind(this));
        this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));
        this.chatClient.on('chatMessageReceived', this.messageReceivedListener.bind(this));
        this.chatClient.on('readReceiptReceived', this.messageReadListener.bind(this));
        this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));
    }
    unsubscribeAllEvents() {
        this.chatClient.off('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));
        this.chatClient.off('participantsAdded', this.participantsAddedListener.bind(this));
        this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));
        this.chatClient.off('chatMessageReceived', this.messageReceivedListener.bind(this));
        this.chatClient.off('readReceiptReceived', this.messageReadListener.bind(this));
        this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));
    }
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter$a(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isChatError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
}
const convertEventToChatMessage = (event) => {
    return {
        id: event.id,
        version: event.version,
        content: {
            message: event.message
        },
        type: convertEventType(event.type),
        sender: event.sender,
        senderDisplayName: event.senderDisplayName,
        sequenceId: '',
        createdOn: new Date(event.createdOn)
    };
}; // only text/html message type will be received from event
const convertEventType = (type) => {
    const lowerCaseType = type.toLowerCase();
    if (lowerCaseType === 'richtext/html' || lowerCaseType === 'html') {
        return 'html';
    }
    else {
        return 'text';
    }
};
/**
 * Create a {@link ChatAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link ChatAdapter} provided by this library.
 *
 * @public
 */
const createAzureCommunicationChatAdapter = ({ endpoint: endpointUrl, userId, displayName, credential, threadId }) => __awaiter$a(void 0, void 0, void 0, function* () {
    const chatClient = createStatefulChatClient({
        userId,
        displayName,
        endpoint: endpointUrl,
        credential: credential
    });
    const chatThreadClient = yield chatClient.getChatThreadClient(threadId);
    yield chatClient.startRealtimeNotifications();
    const adapter = yield createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);
    return adapter;
});
/**
 * A custom React hook to simplify the creation of {@link ChatAdapter}.
 *
 * Similar to {@link createAzureCommunicationChatAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
const useAzureCommunicationChatAdapter = (args, afterCreate, beforeDispose) => {
    const { credential, displayName, endpoint, threadId, userId } = args; // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = React.useState(undefined); // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = React.useRef(undefined);
    const afterCreateRef = React.useRef(undefined);
    const beforeDisposeRef = React.useRef(undefined); // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    React.useEffect(() => {
        if (!credential || !displayName || !endpoint || !threadId || !userId) {
            return;
        }
        (() => __awaiter$a(void 0, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = yield createAzureCommunicationChatAdapter({
                credential,
                displayName,
                endpoint,
                threadId,
                userId
            });
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            setAdapter(newAdapter);
        }))();
    }, // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, endpoint, threadId, userId]); // Dispose any existing adapter when the component unmounts.
    React.useEffect(() => {
        return () => {
            (() => __awaiter$a(void 0, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
};
/**
 * Create a {@link ChatAdapter} using the provided {@link StatefulChatClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient}.
 * Consider using {@link createAzureCommunicationChatAdapter} for a simpler API.
 *
 * @public
 */
const createAzureCommunicationChatAdapterFromClient = (chatClient, chatThreadClient) => __awaiter$a(void 0, void 0, void 0, function* () {
    return new AzureCommunicationChatAdapter(chatClient, chatThreadClient);
});
const isChatError = (e) => {
    return e['target'] !== undefined && e['innerError'] !== undefined;
};

var call$d={cameraLabel:"Camera",cameraPermissionDenied:"Your browser is blocking access to your camera",cameraTurnedOff:"Your camera is turned off",chatButtonLabel:"Chat",close:"Close",complianceBannerNowOnlyRecording:"You are now only recording this meeting.",complianceBannerNowOnlyTranscription:"You are now only transcribing this meeting.",complianceBannerRecordingAndTranscriptionSaved:"Recording and transcription are being saved.",complianceBannerRecordingAndTranscriptionStarted:"Recording and transcription have started.",complianceBannerRecordingAndTranscriptionStopped:"Recording and transcription have stopped.",complianceBannerRecordingSaving:"Recording is being saved.",complianceBannerRecordingStarted:"Recording has started.",complianceBannerRecordingStopped:"Recording has stopped.",complianceBannerTranscriptionStarted:"Transcription has started.",complianceBannerTranscriptionConsent:"By joining, you are giving consent for this meeting to be transcribed.",complianceBannerTranscriptionSaving:"Transcription is being saved.",complianceBannerTranscriptionStopped:"Transcription has stopped.",configurationPageTitle:"Start a call",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",defaultPlaceHolder:"Select an option",dismissSidePaneButtonLabel:"Close",failedToJoinCallDueToNoNetworkMoreDetails:"Call was disconnected due to a network issue. Check your connection and join again.",failedToJoinCallDueToNoNetworkTitle:"Call disconnected",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"You were not granted entry in the call. If this was a mistake, re-join the call.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Dismissed from lobby",learnMore:"Learn more",leftCallMoreDetails:"If this was a mistake, re-join the call.",leftCallTitle:"You left the call",lobbyScreenConnectingToCallTitle:"Joining call",lobbyScreenWaitingToBeAdmittedTitle:"Waiting to be admitted",microphonePermissionDenied:"Your browser is blocking access to your microphone",microphoneToggleInLobbyNotAllowed:"Cannot mute or unmute while in lobby.",mutedMessage:"You're muted",networkReconnectMoreDetails:"Looks like something went wrong. We're trying to get back into the call.",networkReconnectTitle:"Hold on",deniedPermissionToRoomDetails:"You do not have permission to join this room.",deniedPermissionToRoomTitle:"Permission denied to room",peopleButtonLabel:"People",peoplePaneTitle:"People",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",privacyPolicy:"Privacy policy",rejoinCallButtonLabel:"Re-join call",removedFromCallMoreDetails:"Another participant removed you from the call.",removedFromCallTitle:"You were removed",removeMenuLabel:"Remove",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",roomNotFoundDetails:"Room ID provided is not valid.",roomNotFoundTitle:"Room not found",soundLabel:"Sound",startCallButtonLabel:"Start call",openDialpadButtonLabel:"Dial phone number",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",moreButtonCallingLabel:"More",resumeCallButtonLabel:"Resume",resumingCallButtonLabel:"Resuming...",resumeCallButtonAriaLabel:"Resume call",resumingCallButtonAriaLabel:"Resume call",holdScreenLabel:"You're on hold",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number",outboundCallingNoticeString:"Calling..."};var chat$d={chatListHeader:"In this chat",uploadFile:"Upload File"};var callWithChat$d={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"New Message",chatButtonTooltipClosedWithMessageCount:"Show chat ({unreadMessagesCount} unread)",chatButtonTooltipClose:"Hide chat",chatButtonTooltipOpen:"Show chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",dismissSidePaneButtonLabel:"Close",moreDrawerAudioDeviceMenuTitle:"Audio Device",moreDrawerButtonLabel:"More options",moreDrawerButtonTooltip:"More options",moreDrawerMicrophoneMenuTitle:"Microphone",moreDrawerSpeakerMenuTitle:"Speaker",peopleButtonLabel:"People",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",peoplePaneTitle:"People",pictureInPictureTileAriaLabel:"Video Feeds. Click to return to call screen.",removeMenuLabel:"Remove",openDialpadButtonLabel:"Dial phone number",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number"};var en_US = {call:call$d,chat:chat$d,callWithChat:callWithChat$d};

var call$c={cameraLabel:"Camera",cameraPermissionDenied:"Your browser is blocking access to your camera",cameraTurnedOff:"Your camera is turned off",chatButtonLabel:"Chat",close:"Close",complianceBannerNowOnlyRecording:"You are now only recording this meeting.",complianceBannerNowOnlyTranscription:"You are now only transcribing this meeting.",complianceBannerRecordingAndTranscriptionSaved:"Recording and transcription are being saved.",complianceBannerRecordingAndTranscriptionStarted:"Recording and transcription have started.",complianceBannerRecordingAndTranscriptionStopped:"Recording and transcription have stopped.",complianceBannerRecordingSaving:"Recording is being saved.",complianceBannerRecordingStarted:"Recording has started.",complianceBannerRecordingStopped:"Recording has stopped.",complianceBannerTranscriptionStarted:"Transcription has started.",complianceBannerTranscriptionConsent:"By joining, you are giving consent for this meeting to be transcribed.",complianceBannerTranscriptionSaving:"Transcription is being saved.",complianceBannerTranscriptionStopped:"Transcription has stopped.",configurationPageTitle:"Start a call",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",defaultPlaceHolder:"Select an option",dismissSidePaneButtonLabel:"Close",failedToJoinCallDueToNoNetworkMoreDetails:"Call was disconnected due to a network issue. Check your connection and join again.",failedToJoinCallDueToNoNetworkTitle:"Call disconnected",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"You were not granted entry in the call. If this was a mistake, re-join the call.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Dismissed from lobby",learnMore:"Learn more",leftCallMoreDetails:"If this was a mistake, re-join the call.",leftCallTitle:"You left the call",lobbyScreenConnectingToCallTitle:"Joining call",lobbyScreenWaitingToBeAdmittedTitle:"Waiting to be admitted",microphonePermissionDenied:"Your browser is blocking access to your microphone",microphoneToggleInLobbyNotAllowed:"Cannot mute or unmute while in lobby.",mutedMessage:"You're muted",networkReconnectMoreDetails:"Looks like something went wrong. We're trying to get back into the call.",networkReconnectTitle:"Hold on",deniedPermissionToRoomDetails:"You do not have permission to join this room.",deniedPermissionToRoomTitle:"Permission denied to room",peopleButtonLabel:"People",peoplePaneTitle:"People",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",privacyPolicy:"Privacy policy",rejoinCallButtonLabel:"Re-join call",removedFromCallMoreDetails:"Another participant removed you from the call.",removedFromCallTitle:"You were removed",removeMenuLabel:"Remove",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",roomNotFoundDetails:"Room ID provided is not valid.",roomNotFoundTitle:"Room not found",soundLabel:"Sound",startCallButtonLabel:"Start call",openDialpadButtonLabel:"Dial phone number",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",moreButtonCallingLabel:"More",resumeCallButtonLabel:"Resume",resumingCallButtonLabel:"Resuming...",resumeCallButtonAriaLabel:"Resume call",resumingCallButtonAriaLabel:"Resume call",holdScreenLabel:"You're on hold",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number",outboundCallingNoticeString:"Calling..."};var chat$c={chatListHeader:"In this chat",uploadFile:"Upload File"};var callWithChat$c={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"New Message",chatButtonTooltipClosedWithMessageCount:"Show chat ({unreadMessagesCount} unread)",chatButtonTooltipClose:"Hide chat",chatButtonTooltipOpen:"Show chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",dismissSidePaneButtonLabel:"Close",moreDrawerAudioDeviceMenuTitle:"Audio Device",moreDrawerButtonLabel:"More options",moreDrawerButtonTooltip:"More options",moreDrawerMicrophoneMenuTitle:"Microphone",moreDrawerSpeakerMenuTitle:"Speaker",peopleButtonLabel:"People",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",peoplePaneTitle:"People",pictureInPictureTileAriaLabel:"Video Feeds. Click to return to call screen.",removeMenuLabel:"Remove",openDialpadButtonLabel:"Dial phone number",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number"};var en_GB = {call:call$c,chat:chat$c,callWithChat:callWithChat$c};

var call$b={cameraLabel:"Kamera",cameraPermissionDenied:"Ihr Browser blockiert den Zugriff auf Ihre Kamera.",cameraTurnedOff:"Ihre Kamera ist deaktiviert.",chatButtonLabel:"Chat",close:"Schlieen",complianceBannerNowOnlyRecording:"Sie zeichnen nun nur diese Besprechung auf.",complianceBannerNowOnlyTranscription:"Sie transkribieren diese Besprechung jetzt nur noch.",complianceBannerRecordingAndTranscriptionSaved:"Aufzeichnung und Transkription werden gespeichert.",complianceBannerRecordingAndTranscriptionStarted:"Die Aufzeichnung und Transkription haben begonnen.",complianceBannerRecordingAndTranscriptionStopped:"Die Aufzeichnung und Transkription wurden beendet.",complianceBannerRecordingSaving:"Aufzeichnung wird gespeichert.",complianceBannerRecordingStarted:"Die Aufzeichnung wurde gestartet.",complianceBannerRecordingStopped:"Aufzeichnung wurde beendet.",complianceBannerTranscriptionStarted:"Die Transkription hat begonnen.",complianceBannerTranscriptionConsent:"Durch Ihre Teilnahme stimmen Sie zu, dass diese Besprechung transkribiert wird.",complianceBannerTranscriptionSaving:"Die Transkription wird gespeichert.",complianceBannerTranscriptionStopped:"Die Transkription wurde beendet.",configurationPageTitle:"Einen Anruf beginnen",copyInviteLinkButtonLabel:"Einladungslink kopieren",copyInviteLinkActionedAriaLabel:"Gruppeneinladungslink kopiert",defaultPlaceHolder:"Option auswhlen",dismissSidePaneButtonLabel:"Schlieen",failedToJoinCallDueToNoNetworkMoreDetails:"Der Anruf wurde aufgrund eines Netzwerkproblems getrennt. berprfen Sie Ihre Verbindung, und treten Sie erneut bei.",failedToJoinCallDueToNoNetworkTitle:"Anruf unterbrochen",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Ihnen wurde keine Teilnahme am Anruf gewhrt. Wenn dies ein Fehler war, treten Sie dem Anruf erneut bei.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Aus Wartebereich entlassen",learnMore:"Weitere Informationen",leftCallMoreDetails:"Wenn dies ein Fehler war, nehmen Sie erneut am Anruf teil.",leftCallTitle:"Sie haben den Anruf verlassen",lobbyScreenConnectingToCallTitle:"Teilnehmen am Anruf",lobbyScreenWaitingToBeAdmittedTitle:"Warten auf die Zulassung",microphonePermissionDenied:"Ihr Browser blockiert den Zugriff auf Ihr Mikrofon.",microphoneToggleInLobbyNotAllowed:"Stummschalten oder Aufheben der Stummschaltung im Wartebereich nicht zulssig.",mutedMessage:"Sie sind stummgeschaltet.",networkReconnectMoreDetails:"Offensichtlich ist etwas schief gegangen. Wir versuchen, Sie wieder mit dem Anruf zu verbinden.",networkReconnectTitle:"Einen Augenblick bitte",deniedPermissionToRoomDetails:"Sie sind nicht berechtigt, diesem Raum beizutreten.",deniedPermissionToRoomTitle:"Berechtigung fr Raum verweigert",peopleButtonLabel:"Kontakte",peoplePaneTitle:"Kontakte",peopleButtonTooltipOpen:"Teilnehmende anzeigen",peopleButtonTooltipClose:"Teilnehmende ausblenden",peoplePaneSubTitle:"In diesem Anruf",privacyPolicy:"Datenschutzrichtlinie",rejoinCallButtonLabel:"Am Anruf erneut teilnehmen",removedFromCallMoreDetails:"Ein anderer Teilnehmer hat Sie aus dem Anruf entfernt.",removedFromCallTitle:"Sie wurden entfernt",removeMenuLabel:"Entfernen",returnToCallButtonAriaDescription:"Zurck zum Anruf",returnToCallButtonAriaLabel:"Zurck",roomNotFoundDetails:"Die angegebene Raum-ID ist ungltig.",roomNotFoundTitle:"Raum nicht gefunden",soundLabel:"Sound",startCallButtonLabel:"Anruf beginnen",openDialpadButtonLabel:"Telefonnummer whlen",peoplePaneAddPeopleButtonLabel:"Personen hinzufgen",dialpadStartCallButtonLabel:"Anrufen",dialpadModalTitle:"Telefonnummer whlen",dialpadModalAriaLabel:"Whltastatur",dialpadCloseModalButtonAriaLabel:"Whltastatur schlieen",moreButtonCallingLabel:"Mehr",resumeCallButtonLabel:"Fortsetzen",resumingCallButtonLabel:"Wird fortgesetzt",resumeCallButtonAriaLabel:"Anruf fortsetzen",resumingCallButtonAriaLabel:"Anruf fortsetzen",holdScreenLabel:"Sie sind in der Warteschleife.",openDtmfDialpadLabel:"Whltastatur anzeigen",dtmfDialpadPlaceholderText:"Nummer eingeben",outboundCallingNoticeString:"Anrufen..."};var chat$b={chatListHeader:"In diesem Chat",uploadFile:"Datei hochladen"};var callWithChat$b={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Neue Nachricht",chatButtonTooltipClosedWithMessageCount:"Chat anzeigen ({unreadMessagesCount} ungelesen)",chatButtonTooltipClose:"Chat ausblenden",chatButtonTooltipOpen:"Chat anzeigen",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Einladungslink kopieren",copyInviteLinkActionedAriaLabel:"Gruppeneinladungslink kopiert",dismissSidePaneButtonLabel:"Schlieen",moreDrawerAudioDeviceMenuTitle:"Audiogert",moreDrawerButtonLabel:"Weitere Optionen",moreDrawerButtonTooltip:"Weitere Optionen",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Lautsprecher",peopleButtonLabel:"Personen",peopleButtonTooltipOpen:"Teilnehmende anzeigen",peopleButtonTooltipClose:"Teilnehmende ausblenden",peoplePaneSubTitle:"In diesem Anruf",peoplePaneTitle:"Personen",pictureInPictureTileAriaLabel:"Videofeeds. Klicken Sie hier, um zum Anrufbildschirm zurckzukehren.",removeMenuLabel:"Entfernen",openDialpadButtonLabel:"Telefonnummer whlen",returnToCallButtonAriaDescription:"Zurck zum Anruf",returnToCallButtonAriaLabel:"Zurck",peoplePaneAddPeopleButtonLabel:"Personen hinzufgen",dialpadStartCallButtonLabel:"Anrufen",dialpadModalTitle:"Telefonnummer whlen",dialpadModalAriaLabel:"Whltastatur",dialpadCloseModalButtonAriaLabel:"Whltastatur schlieen",openDtmfDialpadLabel:"Whltastatur anzeigen",dtmfDialpadPlaceholderText:"Nummer eingeben"};var de_DE = {call:call$b,chat:chat$b,callWithChat:callWithChat$b};

var call$a={cameraLabel:"Cmara",cameraPermissionDenied:"El explorador est bloqueando el acceso a la cmara",cameraTurnedOff:"La cmara est apagada",chatButtonLabel:"Chat",close:"Cerrar",complianceBannerNowOnlyRecording:"Solo est grabando esta reunin.",complianceBannerNowOnlyTranscription:"Solo est transcribiendo esta reunin.",complianceBannerRecordingAndTranscriptionSaved:"Se estn guardando la grabacin y la transcripcin.",complianceBannerRecordingAndTranscriptionStarted:"Se han iniciado la grabacin y la transcripcin.",complianceBannerRecordingAndTranscriptionStopped:"Se han detenido la grabacin y la transcripcin.",complianceBannerRecordingSaving:"La grabacin se est guardando.",complianceBannerRecordingStarted:"Se ha iniciado la grabacin.",complianceBannerRecordingStopped:"La grabacin se ha detenido.",complianceBannerTranscriptionStarted:"La transcripcin se ha iniciado.",complianceBannerTranscriptionConsent:"Al unirse, da su consentimiento para que se transcriba esta reunin.",complianceBannerTranscriptionSaving:"Se est guardando la transcripcin.",complianceBannerTranscriptionStopped:"La transcripcin se ha detenido.",configurationPageTitle:"Iniciar una llamada",copyInviteLinkButtonLabel:"Copiar vnculo de invitacin",copyInviteLinkActionedAriaLabel:"Vnculo de invitacin copiado",defaultPlaceHolder:"Seleccionar una opcin",dismissSidePaneButtonLabel:"Cerrar",failedToJoinCallDueToNoNetworkMoreDetails:"Se desconect la llamada debido a un problema de red. Compruebe la conexin y nase de nuevo.",failedToJoinCallDueToNoNetworkTitle:"Llamada desconectada",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"No se te concedi la entrada a la llamada. Si se trata de un error, vuelve a unirte.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Rechazado de la sala de espera",learnMore:"Ms informacin",leftCallMoreDetails:"Si se trata de un error, vuelve a unirte a la llamada.",leftCallTitle:"Has abandonado la llamada",lobbyScreenConnectingToCallTitle:"Unindose a la llamada",lobbyScreenWaitingToBeAdmittedTitle:"Esperando a ser admitido",microphonePermissionDenied:"El explorador est bloqueando el acceso al micrfono",microphoneToggleInLobbyNotAllowed:"No se puede silenciar ni reactivar el audio mientras se est en la sala de espera.",mutedMessage:"Ests silenciado",networkReconnectMoreDetails:"Parece que hubo un problema. Estamos intentando reconectar la llamada.",networkReconnectTitle:"Espere",deniedPermissionToRoomDetails:"No tiene permiso para unirse a esta sala.",deniedPermissionToRoomTitle:"Permiso denegado a la sala",peopleButtonLabel:"Contactos",peoplePaneTitle:"Contactos",peopleButtonTooltipOpen:"Mostrar participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"En esta llamada",privacyPolicy:"Directiva de privacidad",rejoinCallButtonLabel:"Volver a unirse a la llamada",removedFromCallMoreDetails:"Otro participante te ha eliminado de la llamada.",removedFromCallTitle:"Fuiste eliminado",removeMenuLabel:"Quitar",returnToCallButtonAriaDescription:"Volver a llamada",returnToCallButtonAriaLabel:"Volver",roomNotFoundDetails:"El id. de sala proporcionado no es vlido.",roomNotFoundTitle:"No se ha encontrado la sala",soundLabel:"Sonido",startCallButtonLabel:"Iniciar llamada",openDialpadButtonLabel:"Marcar nmero de telfono",peoplePaneAddPeopleButtonLabel:"Agregar contactos",dialpadStartCallButtonLabel:"Llamar",dialpadModalTitle:"Marcar nmero de telfono",dialpadModalAriaLabel:"Teclado de marcado",dialpadCloseModalButtonAriaLabel:"Cerrar teclado de marcado",moreButtonCallingLabel:"Ms",resumeCallButtonLabel:"Reanudar",resumingCallButtonLabel:"Reanudando",resumeCallButtonAriaLabel:"Reanudar llamada",resumingCallButtonAriaLabel:"Reanudar llamada",holdScreenLabel:"Est en espera",openDtmfDialpadLabel:"Mostrar teclado de marcado",dtmfDialpadPlaceholderText:"Introducir nmero",outboundCallingNoticeString:"Llamando..."};var chat$a={chatListHeader:"En este chat",uploadFile:"Subir archivo"};var callWithChat$a={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nuevo mensaje",chatButtonTooltipClosedWithMessageCount:"Mostrar chat ({unreadMessagesCount} no ledos)",chatButtonTooltipClose:"Ocultar chat",chatButtonTooltipOpen:"Mostrar chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copiar vnculo de invitacin",copyInviteLinkActionedAriaLabel:"Vnculo de invitacin copiado",dismissSidePaneButtonLabel:"Cerrar",moreDrawerAudioDeviceMenuTitle:"Dispositivo de audio",moreDrawerButtonLabel:"Ms opciones",moreDrawerButtonTooltip:"Ms opciones",moreDrawerMicrophoneMenuTitle:"Micrfono",moreDrawerSpeakerMenuTitle:"Altavoz",peopleButtonLabel:"Contactos",peopleButtonTooltipOpen:"Mostrar participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"En esta llamada",peoplePaneTitle:"Contactos",pictureInPictureTileAriaLabel:"Fuentes de vdeo. Hacer clic para volver a la pantalla de la llamada.",removeMenuLabel:"Quitar",openDialpadButtonLabel:"Marcar nmero de telfono",returnToCallButtonAriaDescription:"Volver a llamada",returnToCallButtonAriaLabel:"Volver",peoplePaneAddPeopleButtonLabel:"Agregar contactos",dialpadStartCallButtonLabel:"Llamar",dialpadModalTitle:"Marcar nmero de telfono",dialpadModalAriaLabel:"Teclado de marcado",dialpadCloseModalButtonAriaLabel:"Cerrar teclado de marcado",openDtmfDialpadLabel:"Mostrar teclado de marcado",dtmfDialpadPlaceholderText:"Introducir nmero"};var es_ES = {call:call$a,chat:chat$a,callWithChat:callWithChat$a};

var call$9={cameraLabel:"Appareil photo",cameraPermissionDenied:"Votre navigateur bloque laccs  votre camra",cameraTurnedOff:"Votre camra est dsactive",chatButtonLabel:"Conversation",close:"Fermer",complianceBannerNowOnlyRecording:"Vous nenregistrez dsormais que cette runion.",complianceBannerNowOnlyTranscription:" prsent, vous ne transcrivez que cette runion.",complianceBannerRecordingAndTranscriptionSaved:"Sauvegarde en cours de lenregistrement et de la transcription.",complianceBannerRecordingAndTranscriptionStarted:"Dmarrage de lenregistrement et de la transcription.",complianceBannerRecordingAndTranscriptionStopped:"Lenregistrement et la transcription ont pris fin.",complianceBannerRecordingSaving:"Sauvegarde en cours de l'enregistrement.",complianceBannerRecordingStarted:"Lenregistrement a dmarr.",complianceBannerRecordingStopped:"Lenregistrement a pris fin.",complianceBannerTranscriptionStarted:"Dmarrage de la transcription.",complianceBannerTranscriptionConsent:"En participant, vous autorisez la transcription de cette runion.",complianceBannerTranscriptionSaving:"Sauvegarde en cours de la transcription.",complianceBannerTranscriptionStopped:"La transcription a pris fin.",configurationPageTitle:"Lancer un appel",copyInviteLinkButtonLabel:"Copier le lien d'invitation",copyInviteLinkActionedAriaLabel:"Le lien dinvitation a t copi.",defaultPlaceHolder:"Slectionnez une option",dismissSidePaneButtonLabel:"Fermer",failedToJoinCallDueToNoNetworkMoreDetails:"Lappel a t dconnect en raison dun problme rseau. Vrifiez votre connexion et rejoignez-la  nouveau.",failedToJoinCallDueToNoNetworkTitle:"Appel dconnect",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Vous navez pas reu dentre dans lappel. Sil sagissait dune erreur, rejoignez  nouveau lappel.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Rejet de la salle dattente",learnMore:"En savoir plus",leftCallMoreDetails:"Sil sagissait dune erreur, rejoignez  nouveau lappel.",leftCallTitle:"Vous avez quitt lappel.",lobbyScreenConnectingToCallTitle:"Connexion  l'appel",lobbyScreenWaitingToBeAdmittedTitle:"En attente dadmission",microphonePermissionDenied:"Votre navigateur bloque laccs  votre micro",microphoneToggleInLobbyNotAllowed:"Impossible de dsactiver ou dactiver le son dans la salle dattente.",mutedMessage:"Le son de votre micro est dsactiv.",networkReconnectMoreDetails:"On dirait qu'une erreur est survenue. Nous tentons de vous reconnecter  lappel.",networkReconnectTitle:"Patience",deniedPermissionToRoomDetails:"Vous ntes pas autoris  rejoindre cette salle.",deniedPermissionToRoomTitle:"Autorisation refuse pour la salle",peopleButtonLabel:"Personnes",peoplePaneTitle:"Personnes",peopleButtonTooltipOpen:"Afficher les participants",peopleButtonTooltipClose:"Masquer les participants",peoplePaneSubTitle:"Dans cet appel",privacyPolicy:"Politique de confidentialit",rejoinCallButtonLabel:"Rejoindre lappel  nouveau.",removedFromCallMoreDetails:"Un autre participant vous a supprim de lappel.",removedFromCallTitle:"Vous avez t supprim.",removeMenuLabel:"Supprimer",returnToCallButtonAriaDescription:"Revenir  lappel",returnToCallButtonAriaLabel:"Prcdent",roomNotFoundDetails:"LID de salle fourni nest pas valide.",roomNotFoundTitle:"Salle introuvable",soundLabel:"Son",startCallButtonLabel:"Lancer l'appel",openDialpadButtonLabel:"Composer le numro de tlphone",peoplePaneAddPeopleButtonLabel:"Ajouter des personnes",dialpadStartCallButtonLabel:"Appeler",dialpadModalTitle:"Composer le numro de tlphone",dialpadModalAriaLabel:"Pav numrique",dialpadCloseModalButtonAriaLabel:"Fermer le pav numrique",moreButtonCallingLabel:"Plus",resumeCallButtonLabel:"Reprendre",resumingCallButtonLabel:"Reprise...",resumeCallButtonAriaLabel:"Reprendre lappel",resumingCallButtonAriaLabel:"Reprendre lappel",holdScreenLabel:"Vous avez t mis(e) en attente.",openDtmfDialpadLabel:"Afficher le pav numrique",dtmfDialpadPlaceholderText:"Saisir un numro",outboundCallingNoticeString:"Appel en cours..."};var chat$9={chatListHeader:"Dans cette conversation",uploadFile:"Charger un fichier"};var callWithChat$9={chatButtonLabel:"Clavardage",chatButtonNewMessageNotificationLabel:"Nouveau message",chatButtonTooltipClosedWithMessageCount:"Afficher la conversation ({unreadMessagesCount} non lu)",chatButtonTooltipClose:"Masquer la conversation",chatButtonTooltipOpen:"Afficher la conversation",chatPaneTitle:"Clavardage",copyInviteLinkButtonLabel:"Copier le lien d'invitation",copyInviteLinkActionedAriaLabel:"Le lien dinvitation a t copi.",dismissSidePaneButtonLabel:"Fermer",moreDrawerAudioDeviceMenuTitle:"Priphrique audio",moreDrawerButtonLabel:"Autres options",moreDrawerButtonTooltip:"Autres options",moreDrawerMicrophoneMenuTitle:"Microphone",moreDrawerSpeakerMenuTitle:"Haut-parleur",peopleButtonLabel:"Personnes",peopleButtonTooltipOpen:"Afficher les participants",peopleButtonTooltipClose:"Masquer les participants",peoplePaneSubTitle:"Pendant cet appel",peoplePaneTitle:"Personnes",pictureInPictureTileAriaLabel:"Flux vido. Cliquez pour revenir  lcran dappel.",removeMenuLabel:"Supprimer",openDialpadButtonLabel:"Composer le numro de tlphone",returnToCallButtonAriaDescription:"Revenir  lappel",returnToCallButtonAriaLabel:"Prcdent",peoplePaneAddPeopleButtonLabel:"Ajouter des personnes",dialpadStartCallButtonLabel:"Appeler",dialpadModalTitle:"Composer le numro de tlphone",dialpadModalAriaLabel:"Pav numrique",dialpadCloseModalButtonAriaLabel:"Fermer le pav numrique",openDtmfDialpadLabel:"Afficher le pav numrique",dtmfDialpadPlaceholderText:"Saisir un numro"};var fr_FR = {call:call$9,chat:chat$9,callWithChat:callWithChat$9};

var call$8={cameraLabel:"Fotocamera",cameraPermissionDenied:"Il browser blocca l'accesso alla fotocamera",cameraTurnedOff:"La videocamera  disabilitata",chatButtonLabel:"Chat",close:"Chiudi",complianceBannerNowOnlyRecording:" in corso la registrazione solo di questa riunione.",complianceBannerNowOnlyTranscription:" in corso la trascrizione solo di questa riunione.",complianceBannerRecordingAndTranscriptionSaved:" in corso il salvataggio della registrazione e della trascrizione.",complianceBannerRecordingAndTranscriptionStarted:"Registrazione e trascrizione avviate.",complianceBannerRecordingAndTranscriptionStopped:"Registrazione e trascrizione interrotte.",complianceBannerRecordingSaving:"Salvataggio della registrazione in corso.",complianceBannerRecordingStarted:"Registrazione avviata.",complianceBannerRecordingStopped:"Registrazione arrestata.",complianceBannerTranscriptionStarted:"Trascrizione avviata.",complianceBannerTranscriptionConsent:"Partecipando, fornisci il consenso per la trascrizione di questa riunione.",complianceBannerTranscriptionSaving:" in corso il salvataggio della trascrizione.",complianceBannerTranscriptionStopped:"Trascrizione interrotta.",configurationPageTitle:"Avvia una chiamata",copyInviteLinkButtonLabel:"Copia il collegamento dellinvito",copyInviteLinkActionedAriaLabel:"Collegamento di invito copiato",defaultPlaceHolder:"Seleziona un'opzione",dismissSidePaneButtonLabel:"Chiudi",failedToJoinCallDueToNoNetworkMoreDetails:"La chiamata  stata disconnessa a causa di un problema di rete. Controlla la connessione e partecipa di nuovo.",failedToJoinCallDueToNoNetworkTitle:"Chiamata interrotta",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Non ti  stato concesso laccesso alla chiamata. Se si  trattato di un errore, partecipa di nuovo alla chiamata.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Ignorato dalla sala di attesa",learnMore:"Ulteriori informazioni",leftCallMoreDetails:"Se si  trattato di un errore, partecipa di nuovo alla chiamata.",leftCallTitle:"Hai abbandonato la chiamata",lobbyScreenConnectingToCallTitle:"Partecipazione alla chiamata",lobbyScreenWaitingToBeAdmittedTitle:"In attesa di essere ammessi",microphonePermissionDenied:"Il browser blocca l'accesso al microfono",microphoneToggleInLobbyNotAllowed:"Impossibile attivare o disattivare l'audio nella sala di attesa.",mutedMessage:"L'audio  disattivato.",networkReconnectMoreDetails:"Sembra si sia verificato un errore. Stiamo cercando di ristabilire la connessione alla chiamata.",networkReconnectTitle:"Attendi",deniedPermissionToRoomDetails:"Non si dispone dell'autorizzazione per partecipare a questa stanza.",deniedPermissionToRoomTitle:"Autorizzazione negata alla stanza",peopleButtonLabel:"Persone",peoplePaneTitle:"Persone",peopleButtonTooltipOpen:"Mostra partecipanti",peopleButtonTooltipClose:"Nascondi partecipanti",peoplePaneSubTitle:"In questa chiamata",privacyPolicy:"Informativa sulla privacy",rejoinCallButtonLabel:"Partecipa alla chiamata",removedFromCallMoreDetails:"Un altro partecipante ti ha rimosso dalla chiamata.",removedFromCallTitle:"Sei stato rimosso",removeMenuLabel:"Rimuovi",returnToCallButtonAriaDescription:"Torna alla chiamata",returnToCallButtonAriaLabel:"Indietro",roomNotFoundDetails:"L'ID sala specificato non  valido.",roomNotFoundTitle:"La stanza non  stata trovata",soundLabel:"Suono",startCallButtonLabel:"Avvia chiamata",openDialpadButtonLabel:"Componi il numero di telefono",peoplePaneAddPeopleButtonLabel:"Aggiungi persone",dialpadStartCallButtonLabel:"Chiamata",dialpadModalTitle:"Componi il numero di telefono",dialpadModalAriaLabel:"Tastiera",dialpadCloseModalButtonAriaLabel:"Chiudi tastiera",moreButtonCallingLabel:"Altro",resumeCallButtonLabel:"Riprendi",resumingCallButtonLabel:"Ripresa in corso...",resumeCallButtonAriaLabel:"Riprendi chiamata",resumingCallButtonAriaLabel:"Riprendi chiamata",holdScreenLabel:"In attesa.",openDtmfDialpadLabel:"Mostra tastiera",dtmfDialpadPlaceholderText:"Immetti il numero",outboundCallingNoticeString:"Chiamata in corso..."};var chat$8={chatListHeader:"In questa chat",uploadFile:"Carica file"};var callWithChat$8={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nuovo messaggio",chatButtonTooltipClosedWithMessageCount:"Mostra chat ({unreadMessagesCount} non letto)",chatButtonTooltipClose:"Nascondi chat",chatButtonTooltipOpen:"Mostra chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copia il collegamento dellinvito",copyInviteLinkActionedAriaLabel:"Collegamento di invito copiato",dismissSidePaneButtonLabel:"Chiudi",moreDrawerAudioDeviceMenuTitle:"Dispositivo audio",moreDrawerButtonLabel:"Altre opzioni",moreDrawerButtonTooltip:"Altre opzioni",moreDrawerMicrophoneMenuTitle:"Microfono",moreDrawerSpeakerMenuTitle:"Altoparlante",peopleButtonLabel:"Persone",peopleButtonTooltipOpen:"Mostra partecipanti",peopleButtonTooltipClose:"Nascondi partecipanti",peoplePaneSubTitle:"In questa chiamata",peoplePaneTitle:"Persone",pictureInPictureTileAriaLabel:"Feed video. Fare clic per tornare alla schermata della chiamata.",removeMenuLabel:"Rimuovi",openDialpadButtonLabel:"Componi il numero di telefono",returnToCallButtonAriaDescription:"Torna alla chiamata",returnToCallButtonAriaLabel:"Indietro",peoplePaneAddPeopleButtonLabel:"Aggiungi persone",dialpadStartCallButtonLabel:"Chiamata",dialpadModalTitle:"Componi il numero di telefono",dialpadModalAriaLabel:"Tastiera",dialpadCloseModalButtonAriaLabel:"Chiudi tastiera",openDtmfDialpadLabel:"Mostra tastiera",dtmfDialpadPlaceholderText:"Immetti il numero"};var it_IT = {call:call$8,chat:chat$8,callWithChat:callWithChat$8};

var call$7={cameraLabel:"",cameraPermissionDenied:"",cameraTurnedOff:"",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"",complianceBannerNowOnlyTranscription:"",complianceBannerRecordingAndTranscriptionSaved:"",complianceBannerRecordingAndTranscriptionStarted:"",complianceBannerRecordingAndTranscriptionStopped:"",complianceBannerRecordingSaving:"",complianceBannerRecordingStarted:"",complianceBannerRecordingStopped:"",complianceBannerTranscriptionStarted:"",complianceBannerTranscriptionConsent:"",complianceBannerTranscriptionSaving:"",complianceBannerTranscriptionStopped:"",configurationPageTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",defaultPlaceHolder:"",dismissSidePaneButtonLabel:"",failedToJoinCallDueToNoNetworkMoreDetails:"",failedToJoinCallDueToNoNetworkTitle:"",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"",learnMore:"",leftCallMoreDetails:"",leftCallTitle:"",lobbyScreenConnectingToCallTitle:"",lobbyScreenWaitingToBeAdmittedTitle:"",microphonePermissionDenied:"",microphoneToggleInLobbyNotAllowed:"",mutedMessage:"",networkReconnectMoreDetails:"",networkReconnectTitle:"",deniedPermissionToRoomDetails:"",deniedPermissionToRoomTitle:"",peopleButtonLabel:"",peoplePaneTitle:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:"",privacyPolicy:" ",rejoinCallButtonLabel:"",removedFromCallMoreDetails:"",removedFromCallTitle:"",removeMenuLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",roomNotFoundDetails:" ID ",roomNotFoundTitle:"",soundLabel:"",startCallButtonLabel:"",openDialpadButtonLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"...",resumeCallButtonAriaLabel:"",resumingCallButtonAriaLabel:"",holdScreenLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:"",outboundCallingNoticeString:""};var chat$7={chatListHeader:"",uploadFile:""};var callWithChat$7={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:"",chatButtonTooltipClosedWithMessageCount:" ({unreadMessagesCount} )",chatButtonTooltipClose:"",chatButtonTooltipOpen:"",chatPaneTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:" ",moreDrawerButtonLabel:"",moreDrawerButtonTooltip:"",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",peopleButtonLabel:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:"",peoplePaneTitle:"",pictureInPictureTileAriaLabel:"  ",removeMenuLabel:"",openDialpadButtonLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:""};var ja_JP = {call:call$7,chat:chat$7,callWithChat:callWithChat$7};

var call$6={cameraLabel:"",cameraPermissionDenied:"     .",cameraTurnedOff:"  ",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"   / .",complianceBannerNowOnlyTranscription:"    .",complianceBannerRecordingAndTranscriptionSaved:"/   .",complianceBannerRecordingAndTranscriptionStarted:"/  .",complianceBannerRecordingAndTranscriptionStopped:"/  .",complianceBannerRecordingSaving:"/  .",complianceBannerRecordingStarted:"/ .",complianceBannerRecordingStopped:"/ .",complianceBannerTranscriptionStarted:" .",complianceBannerTranscriptionConsent:"      .",complianceBannerTranscriptionSaving:"  .",complianceBannerTranscriptionStopped:" .",configurationPageTitle:" ",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"  ",defaultPlaceHolder:" ",dismissSidePaneButtonLabel:"",failedToJoinCallDueToNoNetworkMoreDetails:"     .    .",failedToJoinCallDueToNoNetworkTitle:"  ",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"     .    .",failedToJoinTeamsMeetingReasonAccessDeniedTitle:" .",learnMore:" ",leftCallMoreDetails:"   .",leftCallTitle:" .",lobbyScreenConnectingToCallTitle:" ",lobbyScreenWaitingToBeAdmittedTitle:"  ",microphonePermissionDenied:"     .",microphoneToggleInLobbyNotAllowed:"       .",mutedMessage:" .",networkReconnectMoreDetails:"   .    .",networkReconnectTitle:"",deniedPermissionToRoomDetails:"      .",deniedPermissionToRoomTitle:"    ",peopleButtonLabel:"",peoplePaneTitle:"",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:" ",privacyPolicy:"   ",rejoinCallButtonLabel:"  ",removedFromCallMoreDetails:"    .",removedFromCallTitle:" .",removeMenuLabel:"",returnToCallButtonAriaDescription:" ",returnToCallButtonAriaLabel:"",roomNotFoundDetails:"  ID .",roomNotFoundTitle:"   ",soundLabel:"",startCallButtonLabel:" ",openDialpadButtonLabel:"   ",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"   ",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:" ",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"  ...",resumeCallButtonAriaLabel:"  ",resumingCallButtonAriaLabel:" ",holdScreenLabel:" .",openDtmfDialpadLabel:" ",dtmfDialpadPlaceholderText:" ",outboundCallingNoticeString:"  ..."};var chat$6={chatListHeader:" ",uploadFile:" "};var callWithChat$6={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:" ",chatButtonTooltipClosedWithMessageCount:" ({unreadMessagesCount}  )",chatButtonTooltipClose:" ",chatButtonTooltipOpen:" ",chatPaneTitle:"",copyInviteLinkButtonLabel:"  ",copyInviteLinkActionedAriaLabel:"  ",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:" ",moreDrawerButtonLabel:" ",moreDrawerButtonTooltip:" ",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",peopleButtonLabel:"",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:" ",peoplePaneTitle:"",pictureInPictureTileAriaLabel:" .    .",removeMenuLabel:"",openDialpadButtonLabel:"   ",returnToCallButtonAriaDescription:" ",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"   ",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:" ",openDtmfDialpadLabel:" ",dtmfDialpadPlaceholderText:" "};var ko_KR = {call:call$6,chat:chat$6,callWithChat:callWithChat$6};

var call$5={cameraLabel:"Camera",cameraPermissionDenied:"Uw browser blokkeert de toegang tot uw camera",cameraTurnedOff:"Camera is uitgeschakeld",chatButtonLabel:"Chatten",close:"Sluiten",complianceBannerNowOnlyRecording:"U bent nu alleen deze vergadering aan het opnemen.",complianceBannerNowOnlyTranscription:"U bent nu alleen deze vergadering aan het transcriberen.",complianceBannerRecordingAndTranscriptionSaved:"Opname en transcriptie worden opgeslagen.",complianceBannerRecordingAndTranscriptionStarted:"Opname en transcriptie zijn gestart.",complianceBannerRecordingAndTranscriptionStopped:"Opname en transcriptie zijn gestopt.",complianceBannerRecordingSaving:"De opname wordt opgeslagen.",complianceBannerRecordingStarted:"De opname is gestart.",complianceBannerRecordingStopped:"De opname is gestopt.",complianceBannerTranscriptionStarted:"Transcriptie is gestart.",complianceBannerTranscriptionConsent:"Door deel te nemen, geeft u toestemming voor het transcriberen van deze vergadering.",complianceBannerTranscriptionSaving:"Transcriptie wordt opgeslagen.",complianceBannerTranscriptionStopped:"Transcriptie is gestopt.",configurationPageTitle:"Een oproep starten",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiren",copyInviteLinkActionedAriaLabel:"Uitnodigingskoppeling gekopieerd",defaultPlaceHolder:"Een optie selecteren",dismissSidePaneButtonLabel:"Sluiten",failedToJoinCallDueToNoNetworkMoreDetails:"De verbinding is verbroken vanwege een netwerkprobleem. Controleer de verbinding en neem opnieuw deel.",failedToJoinCallDueToNoNetworkTitle:"Verbinding verbroken",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"U hebt geen toegang gekregen in het gesprek. Als dit een fout is, neemt u opnieuw deel aan het gesprek.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Verwijderd uit lobby",learnMore:"Meer informatie",leftCallMoreDetails:"Als dit een vergissing was, neemt u opnieuw deel aan het gesprek.",leftCallTitle:"U hebt het gesprek verlaten",lobbyScreenConnectingToCallTitle:"Deelnemen aan oproep",lobbyScreenWaitingToBeAdmittedTitle:"Wachten om te worden toegelaten",microphonePermissionDenied:"Uw browser blokkeert de toegang tot uw microfoon",microphoneToggleInLobbyNotAllowed:"Kan niet dempen of dempen opheffen in de lobby.",mutedMessage:"Uw geluid is gedempt",networkReconnectMoreDetails:"Er is iets misgegaan. We proberen terug te gaan naar het gesprek.",networkReconnectTitle:"Wacht even",deniedPermissionToRoomDetails:"U bent niet gemachtigd om deel te nemen aan deze ruimte.",deniedPermissionToRoomTitle:"Machtiging voor de ruimte is geweigerd",peopleButtonLabel:"Personen",peoplePaneTitle:"Personen",peopleButtonTooltipOpen:"Deelnemers weergeven",peopleButtonTooltipClose:"Deelnemers verbergen",peoplePaneSubTitle:"In dit gesprek",privacyPolicy:"Privacybeleid",rejoinCallButtonLabel:"Opnieuw deelnemen aan gesprek",removedFromCallMoreDetails:"Een andere deelnemer heeft u uit het gesprek verwijderd.",removedFromCallTitle:"U bent verwijderd",removeMenuLabel:"Verwijderen",returnToCallButtonAriaDescription:"Terug naar gesprek",returnToCallButtonAriaLabel:"Terug",roomNotFoundDetails:"De opgegeven ruimte-id is niet geldig.",roomNotFoundTitle:"Ruimte niet gevonden",soundLabel:"Geluid",startCallButtonLabel:"Gesprek starten",openDialpadButtonLabel:"Telefoonnummer kiezen",peoplePaneAddPeopleButtonLabel:"Personen toevoegen",dialpadStartCallButtonLabel:"Bellen",dialpadModalTitle:"Telefoonnummer kiezen",dialpadModalAriaLabel:"Telefoonkiezer",dialpadCloseModalButtonAriaLabel:"Toetsenblok sluiten",moreButtonCallingLabel:"Meer",resumeCallButtonLabel:"Hervatten",resumingCallButtonLabel:"Hervatten...",resumeCallButtonAriaLabel:"Gesprek hervatten",resumingCallButtonAriaLabel:"Gesprek hervatten",holdScreenLabel:"U staat in de wacht",openDtmfDialpadLabel:"Toetsenblok weergeven",dtmfDialpadPlaceholderText:"Nummer invoeren",outboundCallingNoticeString:"Bellen..."};var chat$5={chatListHeader:"In deze chat",uploadFile:"Bestand uploaden"};var callWithChat$5={chatButtonLabel:"Chatten",chatButtonNewMessageNotificationLabel:"Nieuw bericht",chatButtonTooltipClosedWithMessageCount:"Chat weergeven ({unreadMessagesCount} ongelezen)",chatButtonTooltipClose:"Chat verbergen",chatButtonTooltipOpen:"Chat weergeven",chatPaneTitle:"Chatten",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiren",copyInviteLinkActionedAriaLabel:"Uitnodigingskoppeling gekopieerd",dismissSidePaneButtonLabel:"Sluiten",moreDrawerAudioDeviceMenuTitle:"Audioapparaat",moreDrawerButtonLabel:"Meer opties",moreDrawerButtonTooltip:"Meer opties",moreDrawerMicrophoneMenuTitle:"Microfoon",moreDrawerSpeakerMenuTitle:"Luidspreker",peopleButtonLabel:"Personen",peopleButtonTooltipOpen:"Deelnemers weergeven",peopleButtonTooltipClose:"Deelnemers verbergen",peoplePaneSubTitle:"In dit gesprek",peoplePaneTitle:"Personen",pictureInPictureTileAriaLabel:"Videofeeds. Klik om terug te keren naar het oproepscherm.",removeMenuLabel:"Verwijderen",openDialpadButtonLabel:"Telefoonnummer kiezen",returnToCallButtonAriaDescription:"Terug naar gesprek",returnToCallButtonAriaLabel:"Terug",peoplePaneAddPeopleButtonLabel:"Personen toevoegen",dialpadStartCallButtonLabel:"Bellen",dialpadModalTitle:"Telefoonnummer kiezen",dialpadModalAriaLabel:"Telefoonkiezer",dialpadCloseModalButtonAriaLabel:"Toetsenblok sluiten",openDtmfDialpadLabel:"Toetsenblok weergeven",dtmfDialpadPlaceholderText:"Nummer invoeren"};var nl_NL = {call:call$5,chat:chat$5,callWithChat:callWithChat$5};

var call$4={cameraLabel:"Cmera",cameraPermissionDenied:"Seu navegador est bloqueando o acesso  cmera",cameraTurnedOff:"Sua cmera est desativada",chatButtonLabel:"Chat",close:"Fechar",complianceBannerNowOnlyRecording:"Voc agora est apenas gravando esta reunio.",complianceBannerNowOnlyTranscription:"Voc agora est apenas transcrevendo esta reunio.",complianceBannerRecordingAndTranscriptionSaved:"A gravao e a transcrio esto sendo salvas.",complianceBannerRecordingAndTranscriptionStarted:"A gravao e a transcrio foram iniciadas.",complianceBannerRecordingAndTranscriptionStopped:"A gravao e a transcrio foram interrompidas.",complianceBannerRecordingSaving:"A gravao est sendo salva.",complianceBannerRecordingStarted:"A gravao foi iniciada.",complianceBannerRecordingStopped:"A gravao foi interrompida.",complianceBannerTranscriptionStarted:"A transcrio foi iniciada.",complianceBannerTranscriptionConsent:"Ao ingressar, voc est dando consentimento para que esta reunio seja transcrita.",complianceBannerTranscriptionSaving:"A transcrio est sendo salva.",complianceBannerTranscriptionStopped:"A transcrio foi interrompida.",configurationPageTitle:"Iniciar uma chamada",copyInviteLinkButtonLabel:"Copiar o link de convite",copyInviteLinkActionedAriaLabel:"Link de convite copiado",defaultPlaceHolder:"Selecionar uma opo",dismissSidePaneButtonLabel:"Fechar",failedToJoinCallDueToNoNetworkMoreDetails:"A chamada foi desconectada devido a um problema de rede. Verifique sua conexo e ingresse novamente.",failedToJoinCallDueToNoNetworkTitle:"Chamada desconectada",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Voc no recebeu entrada na chamada. Se isso foi um erro, ingresse novamente na chamada.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Ignorado do lobby",learnMore:"Saber mais",leftCallMoreDetails:"Se isso foi um erro, ingresse novamente na chamada.",leftCallTitle:"Voc saiu da chamada",lobbyScreenConnectingToCallTitle:"Ingressando na chamada",lobbyScreenWaitingToBeAdmittedTitle:"Esperando para ser admitido",microphonePermissionDenied:"Seu navegador est bloqueando o acesso ao microfone",microphoneToggleInLobbyNotAllowed:"No  possvel ativar ou desativar mudo enquanto estiver no lobby.",mutedMessage:"Voc est com o mudo ativado",networkReconnectMoreDetails:"Parece que algo deu errado. Estamos tentando retornar  chamada.",networkReconnectTitle:"Em espera",deniedPermissionToRoomDetails:"Voc no tem permisso para ingressar nesta sala.",deniedPermissionToRoomTitle:"Permisso negada para a sala",peopleButtonLabel:"Pessoas",peoplePaneTitle:"Pessoas",peopleButtonTooltipOpen:"Mostrar participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"Nesta chamada",privacyPolicy:"Poltica de privacidade",rejoinCallButtonLabel:"Reingressar na chamada",removedFromCallMoreDetails:"Outro participante removeu voc da chamada.",removedFromCallTitle:"Voc foi removido",removeMenuLabel:"Remover",returnToCallButtonAriaDescription:"Retornar  Chamada",returnToCallButtonAriaLabel:"Voltar",roomNotFoundDetails:"A ID da sala fornecida no  vlida.",roomNotFoundTitle:"Sala no encontrada",soundLabel:"Som",startCallButtonLabel:"Iniciar chamada",openDialpadButtonLabel:"Nmero de telefone de discagem",peoplePaneAddPeopleButtonLabel:"Adicionar Pessoas",dialpadStartCallButtonLabel:"Chamar",dialpadModalTitle:"Nmero de Telefone de Discagem",dialpadModalAriaLabel:"Teclado de discagem",dialpadCloseModalButtonAriaLabel:"Fechar teclado",moreButtonCallingLabel:"Mais",resumeCallButtonLabel:"Retomar",resumingCallButtonLabel:"Retomando",resumeCallButtonAriaLabel:"Retomar chamada",resumingCallButtonAriaLabel:"Retomar chamada",holdScreenLabel:"Voc est em espera",openDtmfDialpadLabel:"Mostrar teclado de discagem",dtmfDialpadPlaceholderText:"Digite o nmero",outboundCallingNoticeString:"Chamando..."};var chat$4={chatListHeader:"Neste chat",uploadFile:"Carregar Arquivo"};var callWithChat$4={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nova mensagem",chatButtonTooltipClosedWithMessageCount:"Mostrar chat ({unreadMessagesCount} no lido)",chatButtonTooltipClose:"Ocultar chat",chatButtonTooltipOpen:"Mostrar chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copiar o link de convite",copyInviteLinkActionedAriaLabel:"Link de convite copiado",dismissSidePaneButtonLabel:"Fechar",moreDrawerAudioDeviceMenuTitle:"Dispositivo de udio",moreDrawerButtonLabel:"Mais opes",moreDrawerButtonTooltip:"Mais opes",moreDrawerMicrophoneMenuTitle:"Microfone",moreDrawerSpeakerMenuTitle:"Alto-falante",peopleButtonLabel:"Pessoas",peopleButtonTooltipOpen:"Mostrar Participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"Nesta chamada",peoplePaneTitle:"Pessoas",pictureInPictureTileAriaLabel:"Feeds de vdeo. Clique para retornar  tela de chamada.",removeMenuLabel:"Remover",openDialpadButtonLabel:"Nmero de telefone de discagem",returnToCallButtonAriaDescription:"Retornar  Chamada",returnToCallButtonAriaLabel:"Voltar",peoplePaneAddPeopleButtonLabel:"Adicionar Pessoas",dialpadStartCallButtonLabel:"Chamar",dialpadModalTitle:"Nmero de Telefone de Discagem",dialpadModalAriaLabel:"Teclado de discagem",dialpadCloseModalButtonAriaLabel:"Fechar teclado",openDtmfDialpadLabel:"Mostrar teclado de discagem",dtmfDialpadPlaceholderText:"Digite o nmero"};var pt_BR = {call:call$4,chat:chat$4,callWithChat:callWithChat$4};

var call$3={cameraLabel:"",cameraPermissionDenied:"     ",cameraTurnedOff:" ",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"      .",complianceBannerNowOnlyTranscription:"      .",complianceBannerRecordingAndTranscriptionSaved:"   .",complianceBannerRecordingAndTranscriptionStarted:"   .",complianceBannerRecordingAndTranscriptionStopped:"   .",complianceBannerRecordingSaving:" .",complianceBannerRecordingStarted:" .",complianceBannerRecordingStopped:" .",complianceBannerTranscriptionStarted:" .",complianceBannerTranscriptionConsent:",       .",complianceBannerTranscriptionSaving:" .",complianceBannerTranscriptionStopped:" .",configurationPageTitle:"",copyInviteLinkButtonLabel:"   ",copyInviteLinkActionedAriaLabel:"     ",defaultPlaceHolder:"   ",dismissSidePaneButtonLabel:"",failedToJoinCallDueToNoNetworkMoreDetails:"   -   .      .",failedToJoinCallDueToNoNetworkTitle:" ",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"     .     ,    .",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"    \" \"",learnMore:"",leftCallMoreDetails:"    ,    .",leftCallTitle:"  ",lobbyScreenConnectingToCallTitle:"  ",lobbyScreenWaitingToBeAdmittedTitle:" ",microphonePermissionDenied:"     ",microphoneToggleInLobbyNotAllowed:"    ,   \" \".",mutedMessage:"  ",networkReconnectMoreDetails:", -   .     .",networkReconnectTitle:"",deniedPermissionToRoomDetails:"        .",deniedPermissionToRoomTitle:"    ",peopleButtonLabel:"",peoplePaneTitle:"",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:"  ",privacyPolicy:" ",rejoinCallButtonLabel:"   ",removedFromCallMoreDetails:"     .",removedFromCallTitle:"  ",removeMenuLabel:"",returnToCallButtonAriaDescription:"  ",returnToCallButtonAriaLabel:"",roomNotFoundDetails:"   .",roomNotFoundTitle:"  ",soundLabel:"",startCallButtonLabel:" ",openDialpadButtonLabel:"  ",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"  ",dialpadModalAriaLabel:"  ",dialpadCloseModalButtonAriaLabel:"   ",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"",resumeCallButtonAriaLabel:" ",resumingCallButtonAriaLabel:" ",holdScreenLabel:"   ",openDtmfDialpadLabel:"   ",dtmfDialpadPlaceholderText:" ",outboundCallingNoticeString:" ..."};var chat$3={chatListHeader:"  ",uploadFile:" "};var callWithChat$3={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:" ",chatButtonTooltipClosedWithMessageCount:"  (: {unreadMessagesCount})",chatButtonTooltipClose:" ",chatButtonTooltipOpen:" ",chatPaneTitle:"",copyInviteLinkButtonLabel:"   ",copyInviteLinkActionedAriaLabel:"     ",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:" ",moreDrawerButtonLabel:" ",moreDrawerButtonTooltip:" ",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",peopleButtonLabel:"",peopleButtonTooltipOpen:" ",peopleButtonTooltipClose:" ",peoplePaneSubTitle:"  ",peoplePaneTitle:"",pictureInPictureTileAriaLabel:" . ,     .",removeMenuLabel:"",openDialpadButtonLabel:"  ",returnToCallButtonAriaDescription:"  ",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:" ",dialpadStartCallButtonLabel:"",dialpadModalTitle:"  ",dialpadModalAriaLabel:"  ",dialpadCloseModalButtonAriaLabel:"   ",openDtmfDialpadLabel:"   ",dtmfDialpadPlaceholderText:" "};var ru_RU = {call:call$3,chat:chat$3,callWithChat:callWithChat$3};

var call$2={cameraLabel:"Kamera",cameraPermissionDenied:"Taraycnz kameranza eriimi engelliyor",cameraTurnedOff:"Kameranz kapatld",chatButtonLabel:"Sohbet",close:"Kapat",complianceBannerNowOnlyRecording:"u anda yalnzca bu toplanty kaydediyorsunuz.",complianceBannerNowOnlyTranscription:"u anda yalnzca bu toplantnn dkmn oluturuyorsunuz.",complianceBannerRecordingAndTranscriptionSaved:"Kayt ve dkm kaydediliyor.",complianceBannerRecordingAndTranscriptionStarted:"Kayt ve dkm balatld.",complianceBannerRecordingAndTranscriptionStopped:"Kayt ve dkm durduruldu.",complianceBannerRecordingSaving:"Kayt kaydediliyor.",complianceBannerRecordingStarted:"Kayt balad.",complianceBannerRecordingStopped:"Kayt durduruldu.",complianceBannerTranscriptionStarted:"Dkm balatld.",complianceBannerTranscriptionConsent:"Katlarak bu toplantnn dkmnn karlmasna onay verirsiniz.",complianceBannerTranscriptionSaving:"Dkm kaydediliyor.",complianceBannerTranscriptionStopped:"Dkm durduruldu.",configurationPageTitle:"Arama balatn",copyInviteLinkButtonLabel:"Davet balantsn kopyala",copyInviteLinkActionedAriaLabel:"Davet balants kopyaland",defaultPlaceHolder:"Bir seenek belirleyin",dismissSidePaneButtonLabel:"Kapat",failedToJoinCallDueToNoNetworkMoreDetails:"Bir a sorunu nedeniyle arama balants kesildi. Balantnz kontrol edin ve yeniden katln.",failedToJoinCallDueToNoNetworkTitle:"Arama kesildi",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Aramaya katlmanza izin verilmedi. Bu ilem yanllkla yapldysa aramaya yeniden katln.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Lobiden karld",learnMore:"Daha fazla bilgi edinin",leftCallMoreDetails:"Bu bir hataysa aramaya yeniden katln.",leftCallTitle:"Aramadan ayrldnz",lobbyScreenConnectingToCallTitle:"Aramaya katlyorsunuz",lobbyScreenWaitingToBeAdmittedTitle:"Kabul edilmeyi bekliyor",microphonePermissionDenied:"Taraycnz mikrofonunuza eriimi engelliyor",microphoneToggleInLobbyNotAllowed:"Lobideyken sesi kapatlamaz veya alamaz.",mutedMessage:"Sesiniz kapatld",networkReconnectMoreDetails:"Bir sorun olutu gibi grnyor. arya geri alnmaya allyor.",networkReconnectTitle:"Bekleyin",deniedPermissionToRoomDetails:"Bu odaya katlma izniniz yok.",deniedPermissionToRoomTitle:"Odaya izin verilmedi",peopleButtonLabel:"Kiiler",peoplePaneTitle:"Kiiler",peopleButtonTooltipOpen:"Katlmclar gster",peopleButtonTooltipClose:"Katlmclar gizle",peoplePaneSubTitle:"Bu aramada",privacyPolicy:"Gizlilik ilkesi",rejoinCallButtonLabel:"arya yeniden katl",removedFromCallMoreDetails:"Baka bir katlmc sizi aramadan kard.",removedFromCallTitle:"karldnz",removeMenuLabel:"Kaldr",returnToCallButtonAriaDescription:"Aramaya Dn",returnToCallButtonAriaLabel:"Geri",roomNotFoundDetails:"Salanan oda kimlii geerli deil.",roomNotFoundTitle:"Oda bulunamad",soundLabel:"Ses",startCallButtonLabel:"Arama balat",openDialpadButtonLabel:"Telefon numarasn evir",peoplePaneAddPeopleButtonLabel:"Kii Ekle",dialpadStartCallButtonLabel:"Ara",dialpadModalTitle:"Telefon Numarasn evir",dialpadModalAriaLabel:"Tu takm",dialpadCloseModalButtonAriaLabel:"Tu takmn kapat",moreButtonCallingLabel:"Dier",resumeCallButtonLabel:"Devam edin",resumingCallButtonLabel:"Devam ediyor...",resumeCallButtonAriaLabel:"Grmeye devam edin",resumingCallButtonAriaLabel:"Grmeye devam edin",holdScreenLabel:"Beklemeye alndnz",openDtmfDialpadLabel:"Tu takmn gster",dtmfDialpadPlaceholderText:"Numara girin",outboundCallingNoticeString:"Aranyor..."};var chat$2={chatListHeader:"Bu sohbette",uploadFile:"Dosyay Karya Ykle"};var callWithChat$2={chatButtonLabel:"Sohbet",chatButtonNewMessageNotificationLabel:"Yeni leti",chatButtonTooltipClosedWithMessageCount:"Sohbeti gster ({unreadMessagesCount} okunmam)",chatButtonTooltipClose:"Sohbeti gizle",chatButtonTooltipOpen:"Sohbeti gster",chatPaneTitle:"Sohbet",copyInviteLinkButtonLabel:"Davet balantsn kopyala",copyInviteLinkActionedAriaLabel:"Davet balants kopyaland",dismissSidePaneButtonLabel:"Kapat",moreDrawerAudioDeviceMenuTitle:"Ses Cihaz",moreDrawerButtonLabel:"Dier seenekler",moreDrawerButtonTooltip:"Dier seenekler",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Hoparlr",peopleButtonLabel:"Kiiler",peopleButtonTooltipOpen:"Katlmclar gster",peopleButtonTooltipClose:"Katlmclar gizle",peoplePaneSubTitle:"Bu aramada",peoplePaneTitle:"Kiiler",pictureInPictureTileAriaLabel:"Video Aklar. ar ekranna dnmek iin tklayn.",removeMenuLabel:"Kaldr",openDialpadButtonLabel:"Telefon numarasn evir",returnToCallButtonAriaDescription:"Aramaya Dn",returnToCallButtonAriaLabel:"Geri",peoplePaneAddPeopleButtonLabel:"Kii Ekle",dialpadStartCallButtonLabel:"Ara",dialpadModalTitle:"Telefon Numarasn evir",dialpadModalAriaLabel:"Tu takm",dialpadCloseModalButtonAriaLabel:"Tu takmn kapat",openDtmfDialpadLabel:"Tu takmn gster",dtmfDialpadPlaceholderText:"Numara girin"};var tr_TR = {call:call$2,chat:chat$2,callWithChat:callWithChat$2};

var call$1={cameraLabel:"",cameraPermissionDenied:"",cameraTurnedOff:"",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"",complianceBannerNowOnlyTranscription:"",complianceBannerRecordingAndTranscriptionSaved:"",complianceBannerRecordingAndTranscriptionStarted:"",complianceBannerRecordingAndTranscriptionStopped:"",complianceBannerRecordingSaving:"",complianceBannerRecordingStarted:"",complianceBannerRecordingStopped:"",complianceBannerTranscriptionStarted:"",complianceBannerTranscriptionConsent:"",complianceBannerTranscriptionSaving:"",complianceBannerTranscriptionStopped:"",configurationPageTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",defaultPlaceHolder:"",dismissSidePaneButtonLabel:"",failedToJoinCallDueToNoNetworkMoreDetails:"",failedToJoinCallDueToNoNetworkTitle:"",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"",learnMore:"",leftCallMoreDetails:"",leftCallTitle:"",lobbyScreenConnectingToCallTitle:"",lobbyScreenWaitingToBeAdmittedTitle:"",microphonePermissionDenied:"",microphoneToggleInLobbyNotAllowed:"",mutedMessage:"",networkReconnectMoreDetails:"",networkReconnectTitle:"",deniedPermissionToRoomDetails:"",deniedPermissionToRoomTitle:"",peopleButtonLabel:"",peoplePaneTitle:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:"",privacyPolicy:"",rejoinCallButtonLabel:"",removedFromCallMoreDetails:"",removedFromCallTitle:"",removeMenuLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",roomNotFoundDetails:" ID ",roomNotFoundTitle:"",soundLabel:"",startCallButtonLabel:"",openDialpadButtonLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"...",resumeCallButtonAriaLabel:"",resumingCallButtonAriaLabel:"",holdScreenLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:"",outboundCallingNoticeString:"..."};var chat$1={chatListHeader:"",uploadFile:""};var callWithChat$1={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:"",chatButtonTooltipClosedWithMessageCount:"({unreadMessagesCount} )",chatButtonTooltipClose:"",chatButtonTooltipOpen:"",chatPaneTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:"",moreDrawerButtonLabel:"",moreDrawerButtonTooltip:"",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",peopleButtonLabel:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:"",peoplePaneTitle:"",pictureInPictureTileAriaLabel:"",removeMenuLabel:"",openDialpadButtonLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:""};var zh_CN = {call:call$1,chat:chat$1,callWithChat:callWithChat$1};

var call={cameraLabel:"",cameraPermissionDenied:"",cameraTurnedOff:"",chatButtonLabel:"",close:"",complianceBannerNowOnlyRecording:"",complianceBannerNowOnlyTranscription:"",complianceBannerRecordingAndTranscriptionSaved:"",complianceBannerRecordingAndTranscriptionStarted:"",complianceBannerRecordingAndTranscriptionStopped:"",complianceBannerRecordingSaving:"",complianceBannerRecordingStarted:"",complianceBannerRecordingStopped:"",complianceBannerTranscriptionStarted:"",complianceBannerTranscriptionConsent:"",complianceBannerTranscriptionSaving:"",complianceBannerTranscriptionStopped:"",configurationPageTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",defaultPlaceHolder:"",dismissSidePaneButtonLabel:"",failedToJoinCallDueToNoNetworkMoreDetails:"",failedToJoinCallDueToNoNetworkTitle:"",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"",learnMore:"",leftCallMoreDetails:"",leftCallTitle:"",lobbyScreenConnectingToCallTitle:"",lobbyScreenWaitingToBeAdmittedTitle:"",microphonePermissionDenied:"",microphoneToggleInLobbyNotAllowed:"",mutedMessage:"",networkReconnectMoreDetails:"",networkReconnectTitle:"",deniedPermissionToRoomDetails:"",deniedPermissionToRoomTitle:"",peopleButtonLabel:"",peoplePaneTitle:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:"",privacyPolicy:"",rejoinCallButtonLabel:"",removedFromCallMoreDetails:"",removedFromCallTitle:"",removeMenuLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",roomNotFoundDetails:"",roomNotFoundTitle:"",soundLabel:"",startCallButtonLabel:"",openDialpadButtonLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",moreButtonCallingLabel:"",resumeCallButtonLabel:"",resumingCallButtonLabel:"...",resumeCallButtonAriaLabel:"",resumingCallButtonAriaLabel:"",holdScreenLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:"",outboundCallingNoticeString:"..."};var chat={chatListHeader:"",uploadFile:""};var callWithChat={chatButtonLabel:"",chatButtonNewMessageNotificationLabel:"",chatButtonTooltipClosedWithMessageCount:" ({unreadMessagesCount} )",chatButtonTooltipClose:"",chatButtonTooltipOpen:"",chatPaneTitle:"",copyInviteLinkButtonLabel:"",copyInviteLinkActionedAriaLabel:"",dismissSidePaneButtonLabel:"",moreDrawerAudioDeviceMenuTitle:"",moreDrawerButtonLabel:"",moreDrawerButtonTooltip:"",moreDrawerMicrophoneMenuTitle:"",moreDrawerSpeakerMenuTitle:"",peopleButtonLabel:"",peopleButtonTooltipOpen:"",peopleButtonTooltipClose:"",peoplePaneSubTitle:"",peoplePaneTitle:"",pictureInPictureTileAriaLabel:"",removeMenuLabel:"",openDialpadButtonLabel:"",returnToCallButtonAriaDescription:"",returnToCallButtonAriaLabel:"",peoplePaneAddPeopleButtonLabel:"",dialpadStartCallButtonLabel:"",dialpadModalTitle:"",dialpadModalAriaLabel:"",dialpadCloseModalButtonAriaLabel:"",openDtmfDialpadLabel:"",dtmfDialpadPlaceholderText:""};var zh_TW = {call:call,chat:chat,callWithChat:callWithChat};

const createCompositeStrings = (localizedStrings) => {
    const strings = Object.assign({}, en_US);
    Object.keys(localizedStrings).forEach((key) => {
        strings[key] = Object.assign(Object.assign({}, strings[key]), localizedStrings[key]);
    });
    return strings;
};
/**
 * Locale for English (US)
 *
 * @public
 */
const COMPOSITE_LOCALE_EN_US = {
    component: COMPONENT_LOCALE_EN_US,
    strings: en_US
};
/**
 * Locale for English (British)
 *
 * @public
 */
const COMPOSITE_LOCALE_EN_GB = {
    component: COMPONENT_LOCALE_EN_GB,
    strings: createCompositeStrings(en_GB)
};
/**
 * Locale for German (Germany)
 *
 * @public
 */
const COMPOSITE_LOCALE_DE_DE = {
    component: COMPONENT_LOCALE_DE_DE,
    strings: createCompositeStrings(de_DE)
};
/**
 * Locale for Spanish (Spain)
 *
 * @public
 */
const COMPOSITE_LOCALE_ES_ES = {
    component: COMPONENT_LOCALE_ES_ES,
    strings: createCompositeStrings(es_ES)
};
/**
 * Locale for French (France)
 *
 * @public
 */
const COMPOSITE_LOCALE_FR_FR = {
    component: COMPONENT_LOCALE_FR_FR,
    strings: createCompositeStrings(fr_FR)
};
/**
 * Locale for Italian (Italy)
 *
 * @public
 */
const COMPOSITE_LOCALE_IT_IT = {
    component: COMPONENT_LOCALE_IT_IT,
    strings: createCompositeStrings(it_IT)
};
/**
 * Locale for Japanese (Japan)
 *
 * @public
 */
const COMPOSITE_LOCALE_JA_JP = {
    component: COMPONENT_LOCALE_JA_JP,
    strings: createCompositeStrings(ja_JP)
};
/**
 * Locale for Korean (South Korea)
 *
 * @public
 */
const COMPOSITE_LOCALE_KO_KR = {
    component: COMPONENT_LOCALE_KO_KR,
    strings: createCompositeStrings(ko_KR)
};
/**
 * Locale for Dutch (Netherlands)
 *
 * @public
 */
const COMPOSITE_LOCALE_NL_NL = {
    component: COMPONENT_LOCALE_NL_NL,
    strings: createCompositeStrings(nl_NL)
};
/**
 * Locale for Portuguese (Brazil)
 *
 * @public
 */
const COMPOSITE_LOCALE_PT_BR = {
    component: COMPONENT_LOCALE_PT_BR,
    strings: createCompositeStrings(pt_BR)
};
/**
 * Locale for Russian (Russia)
 *
 * @public
 */
const COMPOSITE_LOCALE_RU_RU = {
    component: COMPONENT_LOCALE_RU_RU,
    strings: createCompositeStrings(ru_RU)
};
/**
 * Locale for Turkish (Turkey)
 *
 * @public
 */
const COMPOSITE_LOCALE_TR_TR = {
    component: COMPONENT_LOCALE_TR_TR,
    strings: createCompositeStrings(tr_TR)
};
/**
 * Locale for Chinese (Mainland China)
 *
 * @public
 */
const COMPOSITE_LOCALE_ZH_CN = {
    component: COMPONENT_LOCALE_ZH_CN,
    strings: createCompositeStrings(zh_CN)
};
/**
 * Locale for Chinese (Taiwan)
 *
 * @public
 */
const COMPOSITE_LOCALE_ZH_TW = {
    component: COMPONENT_LOCALE_ZH_TW,
    strings: createCompositeStrings(zh_TW)
};

// Copyright (c) Microsoft Corporation.
/**
 * Context for providing localized strings to components
 *
 * @private
 */
const LocaleContext = React.createContext(COMPOSITE_LOCALE_EN_US);
/**
 * Provider to provide localized strings for this library's composites.
 *
 * @private
 */
const LocalizationProvider = (props) => {
    const { locale, children } = props;
    return React__default['default'].createElement(LocaleContext.Provider, { value: locale },
        React__default['default'].createElement(LocalizationProvider$1, { locale: locale.component }, children));
};
/**
 * @private
 */
const useLocale = () => React.useContext(LocaleContext);

// Copyright (c) Microsoft Corporation.
const CoffeeIcon = () => React__default['default'].createElement(react.Text, { className: react.mergeStyles(coffeeIconStyle), "aria-hidden": true }, "\u2615");
const coffeeIconStyle = {
    // Fluent wraps all icons with <i> so we must force the fontStyle back to normal.
    fontStyle: 'normal',
    // By default our icons are 20px x 20px (for 1rem = 16px), make this a bit bigger for lobby.
    fontSize: '2rem'
};
/**
 * The default set of icons used by the composites directly (i.e. not via the components defined in this library).
 *
 * @public
 */
const COMPOSITE_ONLY_ICONS = {
    ChevronLeft: React__default['default'].createElement(react.FontIcon, { iconName: "ChevronLeft" }),
    Link: React__default['default'].createElement(react.FontIcon, { iconName: "Link" }),
    LobbyScreenConnectingToCall: React__default['default'].createElement(CoffeeIcon, null),
    LobbyScreenWaitingToBeAdmitted: React__default['default'].createElement(CoffeeIcon, null),
    LocalDeviceSettingsCamera: React__default['default'].createElement(reactIcons.Video20Filled, null),
    LocalDeviceSettingsMic: React__default['default'].createElement(reactIcons.MicOn20Filled, null),
    LocalDeviceSettingsSpeaker: React__default['default'].createElement(reactIcons.Speaker220Filled, null),
    LocalPreviewPlaceholder: React__default['default'].createElement(reactIcons.VideoOff20Filled, null),
    LocalCameraSwitch: React__default['default'].createElement(reactIcons.CameraSwitch24Regular, null),
    ControlBarChatButtonActive: React__default['default'].createElement(reactIcons.Chat20Filled, null),
    ControlBarChatButtonInactive: React__default['default'].createElement(reactIcons.Chat20Regular, null),
    ControlBarPeopleButton: React__default['default'].createElement(reactIcons.People20Regular, null),
    MoreDrawerMicrophones: React__default['default'].createElement(reactIcons.MicOn20Regular, null),
    MoreDrawerPeople: React__default['default'].createElement(reactIcons.People20Regular, null),
    MoreDrawerSpeakers: React__default['default'].createElement(reactIcons.Speaker220Regular, null),
    MoreDrawerSelectedMicrophone: React__default['default'].createElement(reactIcons.MicOn20Filled, null),
    MoreDrawerSelectedSpeaker: React__default['default'].createElement(reactIcons.Speaker220Filled, null),
    Muted: React__default['default'].createElement(reactIcons.MicOff20Filled, null),
    NetworkReconnectIcon: React__default['default'].createElement(reactIcons.CallMissed20Filled, null),
    NoticePageAccessDeniedTeamsMeeting: React__default['default'].createElement(reactIcons.PersonDelete20Filled, null),
    NoticePageJoinCallFailedDueToNoNetwork: React__default['default'].createElement(reactIcons.WifiWarning20Filled, null),
    NoticePageLeftCall: React__default['default'].createElement(reactIcons.CallEnd20Filled, null),
    NoticePageRemovedFromCall: React__default['default'].createElement(reactIcons.Info20Filled, null)
};
/**
 * The default set of icons that are available to used in the Composites.
 *
 * @public
 */
const DEFAULT_COMPOSITE_ICONS = Object.assign(Object.assign({}, DEFAULT_COMPONENT_ICONS), COMPOSITE_ONLY_ICONS);
/**
 * Icon wrapper to use when including customizable icons inside the CallComposite.
 * This wrapper ensures the icon name is being type-checked helping ensure no typos
 * and ensure that icon is customizable through the composite API.
 *
 * @private
 */
const CallCompositeIcon = (props) => React__default['default'].createElement(react.FontIcon, Object.assign({}, props));
/**
 * Icon wrapper to use when including customizable icons inside the CallWithChatComposite.
 * This wrapper ensures the icon name is being type-checked helping ensure no typos
 * and ensure that icon is customizable through the composite API.
 *
 * @private
 */
const CallWithChatCompositeIcon = (props) => React__default['default'].createElement(react.FontIcon, Object.assign({}, props));

/**
 * @private
 */
const globalLayerHostStyle = {
    position: 'fixed',
    zIndex: 1000000,
    inset: '0px',
    visibility: 'hidden'
};

// Copyright (c) Microsoft Corporation.
/**
 * A base provider {@link React.Context} to wrap components with other required providers
 * (e.g. icons, FluentThemeProvider, LocalizationProvider).
 *
 * Required providers are only wrapped once, with all other instances only passing children.
 *
 * @private
 */
const BaseProvider = (props) => {
    const { fluentTheme, rtl, locale } = props;
    const globalLayerHostId = reactHooks.useId('composite-global-hostId');
    /**
     * Pass only the children if we previously registered icons, and have previously wrapped the children in
     * FluentThemeProvider and LocalizationProvider
     */
    const alreadyWrapped = useBase();
    if (alreadyWrapped) {
        return React__default['default'].createElement(React__default['default'].Fragment, null, props.children);
    }
    /**
     * We register the default icon mappings merged with custom icons provided through props
     * to ensure all icons render correctly.
     */
    react.registerIcons({
        icons: Object.assign(Object.assign({}, DEFAULT_COMPOSITE_ICONS), props.icons)
    }); // we use Customizer to override default LayerHost injected to <body />
    // which stop polluting global dom tree and increase compatibility with react-full-screen
    const CompositeElement = React__default['default'].createElement(FluentThemeProvider, { fluentTheme: fluentTheme, rtl: rtl },
        React__default['default'].createElement("meta", { name: "viewport", content: "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" }),
        React__default['default'].createElement(react.Customizer, { scopedSettings: {
                Layer: {
                    hostId: globalLayerHostId
                }
            } },
            React__default['default'].createElement(WithBackgroundColor, null, props.children)),
        React__default['default'].createElement(react.LayerHost, { id: globalLayerHostId, className: react.mergeStyles(globalLayerHostStyle) }));
    const localizedElement = locale ? LocalizationProvider({
        locale,
        children: CompositeElement
    }) : CompositeElement;
    return React__default['default'].createElement(BaseContext.Provider, { value: true }, localizedElement);
};
/**
 * @private
 */
const BaseContext = React.createContext(false);
/**
 * @private
 */
const useBase = () => React.useContext(BaseContext);
/**
 * @private
 * Provides a wrapper with a background color to ensure that composites always have a background color.
 * This is necessary to ensure that composites are not transparent,
 * and the background color of it's parent elements doesn't show through the composite.
 */
const WithBackgroundColor = (props) => {
    const { children } = props;
    const theme = react.useTheme();
    const className = react.mergeStyles({
        background: theme.semanticColors.bodyBackground,
        height: '100%',
        width: '100%',
        position: 'relative'
    });
    return React__default['default'].createElement(react.Stack, { className: className }, children);
};

// Copyright (c) Microsoft Corporation.
const ChatAdapterContext = React.createContext(undefined);
/**
 * @private
 */
const ChatAdapterProvider = (props) => {
    const { adapter } = props;
    return React__default['default'].createElement(ChatAdapterContext.Provider, { value: adapter }, props.children);
};
/**
 * @private
 */
const useAdapter$1 = () => {
    const adapter = React.useContext(ChatAdapterContext);
    if (!adapter) {
        throw 'Cannot find adapter please initialize before usage.';
    }
    return adapter;
};

// Copyright (c) Microsoft Corporation.
const MESSAGE_THREAD_WIDTH = '41.25rem';
/**
 * @private
 * z-index to ensure that chat container has lower z-index than participant pane
 */
const CHAT_CONTAINER_ZINDEX = 1;
/**
 * @private
 */
const chatScreenContainerStyle = react.mergeStyles({
    height: '100%',
    width: '100%',
    minHeight: '13rem',
    minWidth: '17.5rem'
});
/**
 * @private
 */
const chatContainer = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'hidden',
    '*::-webkit-scrollbar': {
        width: '0.3rem',
        height: '0.3rem'
    },
    '.scroll::-webkit-scrollbar-track': {
        background: 'rgba(150, 150, 150)',
        borderRadius: '0.3rem'
    },
    '*::-webkit-scrollbar-thumb': {
        borderRadius: '10px',
        background: 'rgba(150, 150, 150)'
    }
});
/**
 * @private
 */
const chatArea = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'auto',
    position: 'relative' // Ensure that the absolute children components are positioned relative to the chat area
});
/**
 * @private
 */
const chatWrapper = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'hidden',
    zIndex: CHAT_CONTAINER_ZINDEX
});
/**
 * @private
 */
const chatHeaderContainerStyle = react.mergeStyles({
    width: '100%',
    paddingLeft: '1.5rem',
    paddingRight: '1.5rem',
    '@media screen and (max-width: 25rem)': {
        paddingLeft: '5%',
        paddingRight: '5%'
    },
    borderBottom: '0.063rem solid #DDDDDD'
});
/**
 * @private
 */
const topicNameLabelStyle = react.mergeStyles({
    fontSize: '1.1rem',
    lineHeight: '2.5rem',
    fontWeight: 600,
    marginRight: '0.125rem',
    textOverflow: 'ellipsis',
    overflowY: 'hidden'
});
/**
 * @private
 */
const messageThreadChatCompositeStyles = react.memoizeFunction((background) => ({
    root: {
        maxWidth: MESSAGE_THREAD_WIDTH
    },
    chatContainer: {
        background: background
    }
}));
/**
 * @private
 */
const typingIndicatorContainerStyles = {
    padding: '0rem 0.25rem'
};
/**
 * @private
 */
const sendboxContainerStyles = {
    maxWidth: MESSAGE_THREAD_WIDTH,
    width: '100%',
    alignSelf: 'center'
};

var __awaiter$9 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * An Avatar component made using the `Persona` component.
 * It allows you to specify a `userId` and a `dataProvider` to retrieve the `AvatarPersonaData`.
 * Read more about `Persona` component at https://developer.microsoft.com/fluentui#/controls/web/persona
 *
 * @private
 */
const AvatarPersona = (props) => {
    var _a, _b, _c, _d, _e, _f;
    const { userId, dataProvider, text, imageUrl, imageInitials, initialsColor, initialsTextColor, showOverflowTooltip } = props;
    const [data, setData] = React.useState();
    React.useEffect(() => {
        (() => __awaiter$9(void 0, void 0, void 0, function* () {
            if (dataProvider && userId) {
                const newData = yield dataProvider(userId);
                if (avatarDeepDifferenceCheck(data, newData)) {
                    setData(newData);
                }
            }
        }))();
    }, [data, dataProvider, userId]);
    return React__default['default'].createElement(react.Persona, Object.assign({}, props, { text: (_a = data === null || data === void 0 ? void 0 : data.text) !== null && _a !== void 0 ? _a : text, imageUrl: (_b = data === null || data === void 0 ? void 0 : data.imageUrl) !== null && _b !== void 0 ? _b : imageUrl, imageInitials: (_c = data === null || data === void 0 ? void 0 : data.imageInitials) !== null && _c !== void 0 ? _c : imageInitials, initialsColor: (_d = data === null || data === void 0 ? void 0 : data.initialsColor) !== null && _d !== void 0 ? _d : initialsColor, initialsTextColor: (_f = (_e = data === null || data === void 0 ? void 0 : data.initialsTextColor) !== null && _e !== void 0 ? _e : initialsTextColor) !== null && _f !== void 0 ? _f : 'white', showOverflowTooltip: showOverflowTooltip !== null && showOverflowTooltip !== void 0 ? showOverflowTooltip : false }));
};
const avatarDeepDifferenceCheck = (currentData, newData) => {
    return (currentData === null || currentData === void 0 ? void 0 : currentData.text) !== (newData === null || newData === void 0 ? void 0 : newData.text) || (currentData === null || currentData === void 0 ? void 0 : currentData.imageUrl) !== (newData === null || newData === void 0 ? void 0 : newData.imageUrl) || (currentData === null || currentData === void 0 ? void 0 : currentData.initialsColor) !== (newData === null || newData === void 0 ? void 0 : newData.initialsColor) || (currentData === null || currentData === void 0 ? void 0 : currentData.imageInitials) !== (newData === null || newData === void 0 ? void 0 : newData.imageInitials) || (currentData === null || currentData === void 0 ? void 0 : currentData.initialsTextColor) !== (newData === null || newData === void 0 ? void 0 : newData.initialsTextColor);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatHeader = (props) => {
    return React__default['default'].createElement(react.Stack, { className: chatHeaderContainerStyle, horizontal: true },
        React__default['default'].createElement(react.Stack.Item, { align: "center" },
            React__default['default'].createElement("div", { className: topicNameLabelStyle }, props.topic)));
};
const getTopicName = (state, props) => {
    var _a, _b;
    return ((_b = (_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.topic) || '';
};
/**
 * @private
 */
const getHeaderProps = reselect__namespace.createSelector([getTopicName], (topic) => {
    return {
        topic: topic
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * A wrapper to return {@link FileUploadButton} component conditionally.
 * It will return `<></>` for stable builds.
 * @internal
 */
const FileUploadButtonWrapper = (props) => {
    return React__default['default'].createElement(React__default['default'].Fragment, null);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useAdaptedSelector$1 = (selector, selectorProps) => {
    return useSelectorWithAdaptation$1(selector, adaptCompositeState$1, selectorProps);
};
/**
 * @private
 */
const useSelectorWithAdaptation$1 = (selector, adaptState, selectorProps) => {
    const adapter = useAdapter$1(); // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const threadId = adapter.getState().thread.threadId;
    const threadConfigProps = React.useMemo(() => ({
        threadId
    }), [threadId]);
    const [props, setProps] = React.useState(selector(adaptState(adapter.getState()), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps));
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(adaptState(state), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        adapter.onStateChange(onStateChange);
        return () => {
            adapter.offStateChange(onStateChange);
        };
    }, [adaptState, adapter, selector, selectorProps, threadConfigProps]);
    return props;
};
const memoizeState$1 = memoizeOne__default['default']((userId, displayName, threads, latestErrors) => ({
    userId,
    displayName,
    threads,
    latestErrors
}));
const memoizeThreads = memoizeOne__default['default']((thread) => ({
    [thread.threadId]: thread
}));
const adaptCompositeState$1 = (compositeState) => {
    return memoizeState$1(compositeState.userId, compositeState.displayName, memoizeThreads(compositeState.thread), ( // This is an unsafe type expansion.
    // compositeState.latestErrors can contain properties that are not valid in ChatErrors.
    //
    // But there is no way to check for valid property names at runtime:
    // - The set of valid property names is built from types in the @azure/communication-chat.
    //   Thus we don't have a literal array of allowed strings at runtime.
    // - Due to minification / uglification, the property names from the objects at runtime can't be used
    //   to compare against permissible values inferred from the types.
    //
    // This is not a huge problem -- it simply means that our adapted selector will include some extra operations
    // that are unknown to the UI component and data binding libraries. Generic handling of the errors (e.g.,
    // just displaying them in some UI surface) will continue to work for these operations. Handling of
    // specific operations (e.g., acting on errors related to permission issues) will ignore these operations.
    compositeState.latestErrors));
};

/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers$1 = (_component) => {
    return createCompositeHandlers$1(useAdapter$1());
};
const createCompositeHandlers$1 = memoizeOne__default['default']((adapter) => ({
    onSendMessage: adapter.sendMessage,
    onLoadPreviousChatMessages: adapter.loadPreviousChatMessages,
    onMessageSeen: adapter.sendReadReceipt,
    onTyping: adapter.sendTypingIndicator,
    onRemoveParticipant: adapter.removeParticipant,
    updateThreadTopicName: adapter.setTopic,
    onUpdateMessage: adapter.updateMessage,
    onDeleteMessage: adapter.deleteMessage
}));

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const usePropsFor$2 = (component) => {
    const selector = getSelector(component);
    if (!selector) {
        throw new Error("Can't find the selector for component, please check supported component list");
    }
    return Object.assign(Object.assign({}, useAdaptedSelector$1(selector)), useHandlers$1());
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const sidePaneContainerStyles = {
    root: {
        height: '100%',
        padding: '0.5rem 0.25rem',
        width: '21.5rem'
    }
};
/**
 * @private
 */
({
    root: Object.assign(Object.assign({}, sidePaneContainerStyles), { display: 'none' })
});
/**
 * @private
 */
const sidePaneHeaderStyles = {
    root: {
        lineHeight: '1.25rem',
        padding: '0.25rem',
        fontWeight: '600'
    }
};
/**
 * @private
 */
const sidePaneHeaderContainerStyles = {
    root: {
        margin: '0 0.25rem'
    }
};
/**
 * @private
 */
const paneBodyContainer = {
    root: {
        flexDirection: 'column',
        display: 'flex'
    }
};
/**
 * @private
 */
const scrollableContainer = {
    root: {
        flexBasis: '0',
        flexGrow: '1',
        overflowY: 'auto'
    }
};
/**
 * @private
 */
const scrollableContainerContents = {
    root: {
        flexGrow: '1',
        flexBasis: '0',
        maxWidth: '100%',
        // Create a new stacking context so that `pipStyles` can set zIndex above the container.
        position: 'relative'
    }
};
/**
 * @private
 */
const peoplePaneContainerTokens = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const participantListContainerPadding = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const participantListStack = react.mergeStyles({
    height: '100%'
});
/**
 * @private
 */
const participantListContainerStyle = react.mergeStyles({
    height: '100%',
    overflowY: 'auto',
    overflowX: 'hidden'
});
/**
 * @private
 */
const participantListStyle = {
    root: {
        padding: '0rem'
    },
    participantItemStyles: {
        root: {
            padding: '0.5rem'
        }
    }
};
/**
 * @private
 */
const participantListMobileStyle = {
    root: {
        padding: '0rem'
    },
    participantItemStyles: {
        root: {
            padding: '0.5rem 1rem'
        }
    }
};
/**
 * @private
 */
const displayNameStyles = {
    root: {
        padding: '0.5rem',
        textOverflow: 'ellipsis',
        overflow: 'hidden'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatScreen = (props) => {
    const { onFetchAvatarPersonaData, onRenderMessage, onRenderTypingIndicator, options, styles, fileSharing, formFactor } = props;
    const defaultNumberOfChatMessagesToReload = 5;
    const adapter = useAdapter$1();
    const theme = useTheme();
    React.useEffect(() => {
        // Initial data should be always fetched by the composite(or external caller) instead of the adapter
        adapter.fetchInitialData();
    }, [adapter]);
    const messageThreadProps = usePropsFor$2(MessageThread);
    const sendBoxProps = usePropsFor$2(SendBox);
    const typingIndicatorProps = usePropsFor$2(TypingIndicator);
    const headerProps = useAdaptedSelector$1(getHeaderProps);
    const errorBarProps = usePropsFor$2(ErrorBar);
    const onRenderAvatarCallback = React.useCallback((userId, defaultOptions) => {
        return React__default['default'].createElement(AvatarPersona, Object.assign({ userId: userId, hidePersonaDetails: true }, defaultOptions, { dataProvider: onFetchAvatarPersonaData }));
    }, [onFetchAvatarPersonaData]);
    const messageThreadStyles = Object.assign({}, messageThreadChatCompositeStyles(theme.semanticColors.bodyBackground), styles === null || styles === void 0 ? void 0 : styles.messageThread);
    const typingIndicatorStyles = Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.typingIndicator);
    const sendBoxStyles = Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.sendBox);
    const userId = toFlatCommunicationIdentifier(adapter.getState().userId);
    const fileUploadButtonOnChange = React.useCallback((files) => {
        if (!files) {
            return;
        }
    }, [adapter, fileSharing, userId]);
    const AttachFileButton = React.useCallback(() => {
        if (!(fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler)) {
            return null;
        }
        return React__default['default'].createElement(FileUploadButtonWrapper, { accept: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, multiple: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, onChange: fileUploadButtonOnChange });
    }, [fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler, fileUploadButtonOnChange]);
    return React__default['default'].createElement(react.Stack, { className: chatContainer, grow: true },
        (options === null || options === void 0 ? void 0 : options.topic) !== false && React__default['default'].createElement(ChatHeader, Object.assign({}, headerProps)),
        React__default['default'].createElement(react.Stack, { className: chatArea, tokens: participantListContainerPadding, horizontal: true, grow: true },
            React__default['default'].createElement(react.Stack, { className: chatWrapper, grow: true },
                (options === null || options === void 0 ? void 0 : options.errorBar) !== false && React__default['default'].createElement(ErrorBar, Object.assign({}, errorBarProps)),
                React__default['default'].createElement(MessageThread, Object.assign({}, messageThreadProps, { onRenderAvatar: onRenderAvatarCallback, onRenderMessage: onRenderMessage, numberOfChatMessagesToReload: defaultNumberOfChatMessagesToReload, styles: messageThreadStyles })),
                React__default['default'].createElement(react.Stack, { className: react.mergeStyles(sendboxContainerStyles) },
                    React__default['default'].createElement("div", { className: react.mergeStyles(typingIndicatorContainerStyles) }, onRenderTypingIndicator ? onRenderTypingIndicator(typingIndicatorProps.typingUsers) : React__default['default'].createElement(TypingIndicator, Object.assign({}, typingIndicatorProps, { styles: typingIndicatorStyles }))),
                    React__default['default'].createElement(react.Stack, { horizontal: formFactor === 'mobile' },
                        formFactor === 'mobile' && React__default['default'].createElement(react.Stack, { verticalAlign: "center" },
                            React__default['default'].createElement(AttachFileButton, null)),
                        React__default['default'].createElement(react.Stack, { grow: true },
                            React__default['default'].createElement(SendBox, Object.assign({}, sendBoxProps, { autoFocus: options === null || options === void 0 ? void 0 : options.autoFocus, styles: sendBoxStyles }))),
                        formFactor !== 'mobile' && React__default['default'].createElement(AttachFileButton, null))))));
};

/**
 * A customizable UI composite for the chat experience.
 *
 * @remarks Chat composite min width and height are respectively 17.5rem and 20rem (280px and 320px, with default rem at 16px)
 *
 * @public
 */
const ChatComposite = (props) => {
    const { adapter, options, onFetchAvatarPersonaData, onRenderTypingIndicator, onRenderMessage, onFetchParticipantMenuItems } = props;
    const formFactor = props['formFactor'] || 'desktop';
    /**
     * @TODO Remove this function and pass the props directly when file-sharing is promoted to stable.
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    const fileSharingOptions = () => {
        return {};
    };
    return React__default['default'].createElement("div", { className: chatScreenContainerStyle },
        React__default['default'].createElement(BaseProvider, Object.assign({}, props),
            React__default['default'].createElement(ChatAdapterProvider, { adapter: adapter },
                React__default['default'].createElement(ChatScreen, Object.assign({ formFactor: formFactor, options: options, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onRenderTypingIndicator: onRenderTypingIndicator, onRenderMessage: onRenderMessage, onFetchParticipantMenuItems: onFetchParticipantMenuItems }, fileSharingOptions())))));
};

// Copyright (c) Microsoft Corporation.
const CallAdapterContext = React.createContext(undefined);
/**
 * @private
 */
const CallAdapterProvider = (props) => {
    const { adapter } = props;
    return React__default['default'].createElement(CallAdapterContext.Provider, { value: adapter }, props.children);
};
/**
 * @private
 */
const useAdapter = () => {
    const adapter = React.useContext(CallAdapterContext);
    if (!adapter) {
        throw 'Cannot find adapter please initialize before usage.';
    }
    return adapter;
};

/** @private */
const containerDivStyles = {
    position: 'relative',
    width: '100%',
    height: '100%'
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useAdaptedSelector = (selector, selectorProps) => {
    return useSelectorWithAdaptation(selector, adaptCompositeState, selectorProps);
};
/**
 * @private
 */
const useSelectorWithAdaptation = (selector, adaptState, selectorProps) => {
    var _a;
    const adapter = useAdapter(); // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const callId = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.id;
    const callConfigProps = React.useMemo(() => ({
        callId
    }), [callId]);
    const [props, setProps] = React.useState(selector(adaptState(adapter.getState()), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callConfigProps));
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(adaptState(state), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        adapter.onStateChange(onStateChange);
        return () => {
            adapter.offStateChange(onStateChange);
        };
    }, [adaptState, adapter, selector, selectorProps, callConfigProps]);
    return props;
};
const memoizeState = memoizeOne__default['default']((userId, deviceManager, calls, latestErrors, displayName) => ({
    userId,
    incomingCalls: {},
    incomingCallsEnded: {},
    callsEnded: {},
    deviceManager,
    callAgent: {
        displayName
    },
    calls,
    latestErrors
}));
const memoizeCalls = memoizeOne__default['default']((call) => call ? {
    [call.id]: call
} : {});
const adaptCompositeState = (compositeState) => {
    return memoizeState(compositeState.userId, compositeState.devices, memoizeCalls(compositeState.call), ( // This is an unsafe type expansion.
    // compositeState.latestErrors can contain properties that are not valid in CallErrors.
    //
    // But there is no way to check for valid property names at runtime:
    // - The set of valid property names is built from types in the @azure/communication-calling.
    //   Thus we don't have a literal array of allowed strings at runtime.
    // - Due to minification / uglification, the property names from the objects at runtime can't be used
    //   to compare against permissible values inferred from the types.
    //
    // This is not a huge problem -- it simply means that our adapted selector will include some extra operations
    // that are unknown to the UI component and data binding libraries. Generic handling of the errors (e.g.,
    // just displaying them in some UI surface) will continue to work for these operations. Handling of
    // specific operations (e.g., acting on errors related to permission issues) will ignore these operations.
    compositeState.latestErrors), compositeState.displayName);
};

/**
 * Subset of CallCompositePages that represent an end call state.
 * @private
 */
const END_CALL_PAGES = ['accessDeniedTeamsMeeting', 'joinCallFailedDueToNoNetwork', 'leftCall', 'removedFromCall'];

// Copyright (c) Microsoft Corporation.
const ACCESS_DENIED_TEAMS_MEETING_SUB_CODE = 5854;
const REMOTE_PSTN_USER_HUNG_UP = 560000;
const REMOVED_FROM_CALL_SUB_CODES = [5000, 5300, REMOTE_PSTN_USER_HUNG_UP];
/**
 * @private
 */
const isCameraOn = (state) => {
    if (state.call) {
        const stream = state.call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
        return !!stream;
    }
    else {
        if (state.devices.selectedCamera) {
            const previewOn = _isPreviewOn(state.devices);
            return previewOn;
        }
    }
    return false;
};
/**
 * Reduce the set of call controls visible on mobile.
 * For example do not show screenshare button.
 *
 * @private
 */
const reduceCallControlsForMobile = (callControlOptions) => {
    if (callControlOptions === false) {
        return false;
    } // Ensure call controls a valid object.
    const reduceCallControlOptions = callControlOptions === true ? {} : callControlOptions || {}; // Set to compressed mode when composite is optimized for mobile
    reduceCallControlOptions.displayType = 'compact'; // Do not show screen share button when composite is optimized for mobile unless the developer
    // has explicitly opted in.
    if (reduceCallControlOptions.screenShareButton !== true) {
        reduceCallControlOptions.screenShareButton = false;
    }
    return reduceCallControlOptions;
};
var CallEndReasons;
(function (CallEndReasons) {
    CallEndReasons[CallEndReasons["LEFT_CALL"] = 0] = "LEFT_CALL";
    CallEndReasons[CallEndReasons["ACCESS_DENIED"] = 1] = "ACCESS_DENIED";
    CallEndReasons[CallEndReasons["REMOVED_FROM_CALL"] = 2] = "REMOVED_FROM_CALL";
    CallEndReasons[CallEndReasons["ROOM_NOT_FOUND"] = 3] = "ROOM_NOT_FOUND";
    CallEndReasons[CallEndReasons["DENIED_PERMISSION_TO_ROOM"] = 4] = "DENIED_PERMISSION_TO_ROOM";
})(CallEndReasons || (CallEndReasons = {}));
const getCallEndReason = (call) => {
    var _a, _b, _c;
    const remoteParticipantsEndedArray = Array.from(Object.values(call.remoteParticipantsEnded));
    /**
     * Handle the special case in a PSTN call where removing the last user kicks the caller out of the call.
     * The code and subcode is the same as when a user is removed from a teams interop call.
     * Hence, we look at the last remote participant removed to determine if the last participant removed was a phone number.
     * If yes, the caller was kicked out of the call, but we need to show them that they left the call.
     * Note: This check will only work for 1:1 PSTN Calls. The subcode is different for 1:N PSTN calls, and we do not need to handle that case.
     */
    if (remoteParticipantsEndedArray.length === 1 && communicationCommon.isPhoneNumberIdentifier(remoteParticipantsEndedArray[0].identifier) && ((_a = call.callEndReason) === null || _a === void 0 ? void 0 : _a.subCode) !== REMOTE_PSTN_USER_HUNG_UP) {
        return CallEndReasons.LEFT_CALL;
    }
    if (((_b = call.callEndReason) === null || _b === void 0 ? void 0 : _b.subCode) && call.callEndReason.subCode === ACCESS_DENIED_TEAMS_MEETING_SUB_CODE) {
        return CallEndReasons.ACCESS_DENIED;
    }
    if (((_c = call.callEndReason) === null || _c === void 0 ? void 0 : _c.subCode) && REMOVED_FROM_CALL_SUB_CODES.includes(call.callEndReason.subCode)) {
        return CallEndReasons.REMOVED_FROM_CALL;
    }
    if (call.callEndReason) {
        // No error codes match, assume the user simply left the call regularly
        return CallEndReasons.LEFT_CALL;
    }
    throw new Error('No matching call end reason');
};
/**
 * Get the current call composite page based on the current call composite state
 *
 * @param Call - The current call state
 * @param previousCall - The state of the most recent previous call that has ended.
 *
 * @remarks - The previousCall state is needed to determine if the call has ended.
 * When the call ends a new call object is created, and so we must lookback at the
 * previous call state to understand how the call has ended. If there is no previous
 * call we know that this is a fresh call and can display the configuration page.
 *
 * @private
 */
const getCallCompositePage = (call, previousCall) => {
    // Must check for ongoing call *before* looking at any previous calls.
    // If the composite completes one call and joins another, the previous calls
    // will be populated, but not relevant for determining the page.
    if (call) {
        // `_isInLobbyOrConnecting` needs to be checked first because `_isInCall` also returns true when call is in lobby.
        if (_isInLobbyOrConnecting(call === null || call === void 0 ? void 0 : call.state)) {
            return 'lobby'; // `LocalHold` needs to be checked before `isInCall` since it is also a state that's considered in call.
        }
        else if ((call === null || call === void 0 ? void 0 : call.state) === 'LocalHold') {
            return 'call';
        }
        else if (_isInCall(call === null || call === void 0 ? void 0 : call.state)) {
            return 'call';
        }
        else {
            // When the call object has been constructed after clicking , but before 'connecting' has been
            // set on the call object, we continue to show the configuration screen.
            // The call object does not correctly reflect local device state until `call.state` moves to `connecting`.
            // Moving to the 'lobby' page too soon leads to components that depend on the `call` object to show incorrect
            // transitional state.
            return 'configuration';
        }
    }
    if (previousCall) {
        const reason = getCallEndReason(previousCall);
        switch (reason) {
            case CallEndReasons.ACCESS_DENIED:
                return 'accessDeniedTeamsMeeting';
            case CallEndReasons.REMOVED_FROM_CALL:
                return 'removedFromCall';
            case CallEndReasons.LEFT_CALL:
                if (previousCall.diagnostics.network.latest.noNetwork) {
                    return 'joinCallFailedDueToNoNetwork';
                }
                return 'leftCall';
        }
    } // No call state - show starting page (configuration)
    return 'configuration';
};
/** @private */
const IsCallEndedPage = (page) => END_CALL_PAGES.includes(page);
/**
 * Creates a new call control options object and sets the correct values for disabling
 * the buttons provided in the `disabledControls` array.
 * Returns a new object without changing the original object.
 * @param callControlOptions options for the call control component that need to be modified.
 * @param disabledControls An array of controls to disable.
 * @returns a copy of callControlOptions with disabledControls disabled
 * @private
 */
const disableCallControls = (callControlOptions, disabledControls) => {
    var _a;
    if (callControlOptions === false) {
        return false;
    } // Ensure we clone the prop if it is an object to ensure we do not mutate the original prop.
    let newOptions = (_a = (callControlOptions instanceof Object ? Object.assign({}, callControlOptions) : callControlOptions)) !== null && _a !== void 0 ? _a : {};
    if (newOptions === true || newOptions === undefined) {
        newOptions = disabledControls.reduce((acc, key) => {
            acc[key] = {
                disabled: true
            };
            return acc;
        }, {});
    }
    else {
        disabledControls.forEach(key => {
            if (newOptions[key] !== false) {
                newOptions[key] = {
                    disabled: true
                };
            }
        });
    }
    return newOptions;
};
/**
 * Check if a disabled object is provided for a button and returns if the button is disabled.
 * A button is only disabled if is explicitly set to disabled.
 *
 * @param option
 * @returns whether a button is disabled
 * @private
 */
const isDisabled$2 = (option) => {
    if (option === undefined || typeof option === 'boolean') {
        return false;
    }
    return option.disabled;
};

var __awaiter$8 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers = (_component) => {
    return createCompositeHandlers(useAdapter());
};
const createCompositeHandlers = memoizeOne__default['default']((adapter) => ({
    onCreateLocalStreamView: (options) => __awaiter$8(void 0, void 0, void 0, function* () {
        return yield adapter.createStreamView(undefined, options);
    }),
    onCreateRemoteStreamView: (userId, options) => __awaiter$8(void 0, void 0, void 0, function* () {
        return yield adapter.createStreamView(userId, options);
    }),
    onHangUp: (forEveryone) => __awaiter$8(void 0, void 0, void 0, function* () {
        yield adapter.leaveCall(forEveryone);
    }),
    onRemoveParticipant: (userId) => __awaiter$8(void 0, void 0, void 0, function* () {
        yield adapter.removeParticipant(userId);
    }),
    onSelectCamera: (deviceInfo, options) => __awaiter$8(void 0, void 0, void 0, function* () {
        yield adapter.setCamera(deviceInfo, options);
    }),
    onSelectMicrophone: (deviceInfo) => __awaiter$8(void 0, void 0, void 0, function* () {
        yield adapter.setMicrophone(deviceInfo);
    }),
    onSelectSpeaker: (deviceInfo) => __awaiter$8(void 0, void 0, void 0, function* () {
        yield adapter.setSpeaker(deviceInfo);
    }),
    onStartCall: (participants, options) => {
        const rawIds = participants.map(participant => toFlatCommunicationIdentifier(participant));
        return adapter.startCall(rawIds, options);
    },
    onStartScreenShare: () => __awaiter$8(void 0, void 0, void 0, function* () {
        yield adapter.startScreenShare();
    }),
    onStopScreenShare: () => __awaiter$8(void 0, void 0, void 0, function* () {
        yield adapter.stopScreenShare();
    }),
    onToggleCamera: (options) => __awaiter$8(void 0, void 0, void 0, function* () {
        isCameraOn(adapter.getState()) ? yield adapter.stopCamera() : yield adapter.startCamera(options);
    }),
    onToggleMicrophone: () => __awaiter$8(void 0, void 0, void 0, function* () {
        var _a;
        return ((_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.isMuted) ? yield adapter.unmute() : yield adapter.mute();
    }),
    onToggleScreenShare: () => __awaiter$8(void 0, void 0, void 0, function* () {
        var _b;
        return ((_b = adapter.getState().call) === null || _b === void 0 ? void 0 : _b.isScreenSharingOn) ? yield adapter.stopScreenShare() : yield adapter.startScreenShare();
    }),
    onStartLocalVideo: () => __awaiter$8(void 0, void 0, void 0, function* () {
        if (adapter.getState().call) {
            return adapter.startCamera();
        }
    }),
    onDisposeLocalStreamView: () => __awaiter$8(void 0, void 0, void 0, function* () {
        return adapter.disposeStreamView();
    }),
    onDisposeRemoteStreamView: (userId) => __awaiter$8(void 0, void 0, void 0, function* () {
        return adapter.disposeStreamView(userId);
    })
}));

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const usePropsFor$1 = (component) => {
    const selector = getSelector$1(component);
    if (!selector) {
        throw new Error("Can't find the selector for component, please check supported component list");
    }
    return Object.assign(Object.assign({}, useAdaptedSelector(selector)), useHandlers());
};

// Copyright (c) Microsoft Corporation.
const MINIMUM_TOUCH_TARGET_HEIGHT_REM = 3;
/**
 * @private
 */
const groupCallLeaveButtonStyle = {
    root: {
        border: '0.125rem',
        borderRadius: 2,
        height: '2.1875rem',
        width: '6.5625rem'
    },
    flexContainer: {
        flexFlow: 'row'
    }
};
/**
 * @private
 */
const groupCallLeaveButtonCompressedStyle = {
    root: {
        border: '0',
        borderRadius: '0.5rem'
    },
    flexContainer: {
        flexFlow: 'row'
    }
};
/**
 * Styles that can be applied to ensure flyout items have the minimum touch target size.
 *
 * @private
 */
const buttonFlyoutIncreasedSizeStyles = {
    root: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        maxHeight: 'unset'
    },
    linkContent: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        maxHeight: 'unset'
    },
    icon: {
        maxHeight: 'unset',
        textAlign: 'center'
    }
};
/**
 * @private
 */
const participantButtonWithIncreasedTouchTargets = {
    menuStyles: {
        menuItemStyles: buttonFlyoutIncreasedSizeStyles,
        participantListStyles: {
            participantItemStyles: {
                root: {
                    height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`
                },
                participantSubMenuItemsStyles: buttonFlyoutIncreasedSizeStyles
            }
        }
    }
};
/**
 * @private
 */
const devicesButtonWithIncreasedTouchTargets = {
    menuStyles: {
        menuItemStyles: buttonFlyoutIncreasedSizeStyles
    }
};
/**
 * @private
 */
const controlButtonBaseStyle = {
    label: {
        minWidth: '2.25rem'
    }
};
/**
 * @private
 */
const concatButtonBaseStyles = (...styles) => {
    let result = controlButtonBaseStyle;
    styles.forEach(style => {
        result = react.concatStyleSets(result, style);
    });
    return result;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const Camera = (props) => {
    const cameraButtonProps = usePropsFor$1(CameraButton);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]);
    return React__default['default'].createElement(CameraButton, Object.assign({ "data-ui-id": "call-composite-camera-button" }, cameraButtonProps, { showLabel: props.displayType !== 'compact', styles: styles, enableDeviceSelectionMenu: props.splitButtonsForDeviceSelection, disabled: cameraButtonProps.disabled || props.disabled }));
};

// Copyright (c) Microsoft Corporation.
/** @private */
const Devices = (props) => {
    const devicesButtonProps = usePropsFor$1(DevicesButton);
    const augmentedDeviceButtonProps = React.useMemo(() => (Object.assign({}, devicesButtonProps)), [devicesButtonProps]);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles(props.increaseFlyoutItemSize ? devicesButtonWithIncreasedTouchTargets : {}, (_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.increaseFlyoutItemSize, props.styles]);
    return React__default['default'].createElement(DevicesButton
    /* By setting `persistMenu?` to true, we prevent options menu from getting hidden every time a participant joins or leaves. */
    , Object.assign({ 
        /* By setting `persistMenu?` to true, we prevent options menu from getting hidden every time a participant joins or leaves. */
        persistMenu: true }, augmentedDeviceButtonProps, { showLabel: props.displayType !== 'compact', styles: styles, "data-ui-id": "calling-composite-devices-button", disabled: props.disabled }));
};

// Copyright (c) Microsoft Corporation.
/** @private */
const EndCall = (props) => {
    const compactMode = props.displayType === 'compact';
    const hangUpButtonProps = usePropsFor$1(EndCallButton);
    const styles = React.useMemo(() => { var _a; return react.concatStyleSets(compactMode ? groupCallLeaveButtonCompressedStyle : groupCallLeaveButtonStyle, (_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [compactMode, props.styles]);
    return React__default['default'].createElement(EndCallButton, Object.assign({ "data-ui-id": "call-composite-hangup-button" }, hangUpButtonProps, { styles: styles, showLabel: !compactMode }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useSelector$1 = (selector, selectorProps) => {
    // use selector with no adaptation
    return useSelectorWithAdaptation(selector, state => state, selectorProps);
};

/**
 * @private
 */
const getDisplayName = (state) => state.displayName;
/**
 * @private
 */
const getCallStatus = (state) => { var _a, _b; return (_b = (_a = state.call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None'; };
/**
 * @private
 */
const getDeviceManager = (state) => state.devices;
/**
 * @private
 */
const getIsScreenShareOn = (state) => { var _a, _b; return (_b = (_a = state.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) !== null && _b !== void 0 ? _b : false; };
/**
 * @private
 */
const getIsPreviewCameraOn = (state) => _isPreviewOn(state.devices);
/**
 * @private
 */
const getPage = (state) => state.page;
/**
 * @private
 */
const getLocalMicrophoneEnabled = (state) => state.isLocalPreviewMicrophoneEnabled;
/**
 * @private
 */
const getLocalVideoStreams = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.localVideoStreams; };
/**
 * @private
 */
const getIsTranscriptionActive = (state) => { var _a; return !!((_a = state.call) === null || _a === void 0 ? void 0 : _a.transcription.isTranscriptionActive); };
/**
 * @private
 */
const getIsRecordingActive = (state) => { var _a; return !!((_a = state.call) === null || _a === void 0 ? void 0 : _a.recording.isRecordingActive); };
/**
 * @private
 */
const getUserFacingDiagnostics = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.diagnostics; };
/**
 * @private
 */
const getDominantSpeakerInfo = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.dominantSpeakers; };
/**
 * @private
 */
const getRemoteParticipants = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.remoteParticipants; };

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const Microphone = (props) => {
    const microphoneButtonProps = usePropsFor$1(MicrophoneButton);
    const callStatus = useSelector$1(getCallStatus);
    const isLocalMicrophoneEnabled = useSelector$1(getLocalMicrophoneEnabled);
    const strings = useLocale().strings.call;
    /**
     * When call is in Lobby, microphone button should be disabled.
     * This is due to to headless limitation where a call can not be muted/unmuted in lobby.
     */
    if (_isInLobbyOrConnecting(callStatus)) {
        microphoneButtonProps.disabled = true; // Lobby page should show the microphone status that was set on the local preview/configuration
        // page until the user successfully joins the call.
        microphoneButtonProps.checked = isLocalMicrophoneEnabled;
    }
    const microphoneButtonStrings = _isInLobbyOrConnecting(callStatus) ? {
        strings: {
            tooltipOffContent: strings.microphoneToggleInLobbyNotAllowed,
            tooltipOnContent: strings.microphoneToggleInLobbyNotAllowed
        }
    } : {};
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]); // tab focus on MicrophoneButton on page load
    return React__default['default'].createElement(MicrophoneButton, Object.assign({ autoFocus: true, "data-ui-id": "call-composite-microphone-button" }, microphoneButtonProps, { showLabel: props.displayType !== 'compact', styles: styles }, microphoneButtonStrings, { enableDeviceSelectionMenu: props.splitButtonsForDeviceSelection, disabled: microphoneButtonProps.disabled || props.disabled }));
};

// Copyright (c) Microsoft Corporation.
/** @private */
const Participants = (props) => {
    const participantsButtonProps = usePropsFor$1(ParticipantsButton);
    const participantsButtonStyles = React.useMemo(() => { var _a; return concatButtonBaseStyles(props.increaseFlyoutItemSize ? participantButtonWithIncreasedTouchTargets : {}, (_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.increaseFlyoutItemSize, props.styles]);
    return React__default['default'].createElement(ParticipantsButton, Object.assign({ "data-ui-id": "call-composite-participants-button" }, participantsButtonProps, { showLabel: props.displayType !== 'compact', callInvitationURL: props.callInvitationURL, onFetchParticipantMenuItems: props.onFetchParticipantMenuItems, disabled: isDisabled$1(props.option) || props.disabled, styles: participantsButtonStyles, showParticipantOverflowTooltip: !props.isMobile }));
};
const isDisabled$1 = (option) => {
    if (option === undefined || option === true || option === false) {
        return false;
    }
    return option.disabled;
};

// Copyright (c) Microsoft Corporation.
/** @private */
const ScreenShare = (props) => {
    const screenShareButtonProps = usePropsFor$1(ScreenShareButton);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]);
    const screenShareButtonDisabled = () => {
        return isDisabled(props.option);
    };
    return React__default['default'].createElement(ScreenShareButton, Object.assign({ "data-ui-id": "call-composite-screenshare-button" }, screenShareButtonProps, { showLabel: props.displayType !== 'compact', disabled: screenShareButtonDisabled() || props.disabled, styles: styles }));
};
const isDisabled = (option) => {
    if (option === undefined || option === true || option === false) {
        return false;
    }
    return option.disabled;
};

// Copyright (c) Microsoft Corporation.
const controlBarStyles = react.memoizeFunction((background) => ({
    root: {
        background: background
    }
}));
/**
 * @private
 */
const CallControls = (props) => {
    const options = React.useMemo(() => typeof props.options === 'boolean' ? {} : props.options, [props.options]);
    const theme = react.useTheme();
    // when props.options is false then we want to hide the whole control bar.
    if (props.options === false) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    let screenShareButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.screenShareButton);
    let microphoneButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.microphoneButton);
    let cameraButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.cameraButton);
    return React__default['default'].createElement(react.Stack, { horizontalAlign: "center" },
        React__default['default'].createElement(react.Stack.Item, null,
            React__default['default'].createElement(ControlBar, { layout: "horizontal", styles: controlBarStyles(theme.semanticColors.bodyBackground) },
                microphoneButtonIsEnabled && React__default['default'].createElement(Microphone, { displayType: options === null || options === void 0 ? void 0 : options.displayType, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.microphoneButton) }),
                cameraButtonIsEnabled && React__default['default'].createElement(Camera, { displayType: options === null || options === void 0 ? void 0 : options.displayType, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.cameraButton) }),
                screenShareButtonIsEnabled && React__default['default'].createElement(ScreenShare, { option: options === null || options === void 0 ? void 0 : options.screenShareButton, displayType: options === null || options === void 0 ? void 0 : options.displayType, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.screenShareButton) }),
                isEnabled$2(options === null || options === void 0 ? void 0 : options.participantsButton) && React__default['default'].createElement(Participants, { option: options === null || options === void 0 ? void 0 : options.participantsButton, callInvitationURL: props.callInvitationURL, onFetchParticipantMenuItems: props.onFetchParticipantMenuItems, displayType: options === null || options === void 0 ? void 0 : options.displayType, increaseFlyoutItemSize: props.increaseFlyoutItemSize, isMobile: props.isMobile, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.participantsButton) }),
                isEnabled$2(options === null || options === void 0 ? void 0 : options.devicesButton) && React__default['default'].createElement(Devices, { displayType: options === null || options === void 0 ? void 0 : options.displayType, increaseFlyoutItemSize: props.increaseFlyoutItemSize, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.devicesButton) }),
                isEnabled$2(options === null || options === void 0 ? void 0 : options.endCallButton) && React__default['default'].createElement(EndCall, { displayType: options === null || options === void 0 ? void 0 : options.displayType }))));
};
const isEnabled$2 = (option) => option !== false;

/** @private */
const controlBarContainerStyles$1 = {
    paddingTop: '0.25rem',
    paddingBottom: '0.25rem',
    // @TODO: this should be exposed through a custom CallComposite Theme API that extends the fluent theme with semantic values
    boxShadow: `
    0px 6.400000095367432px 14.399999618530273px 0px #00000021;
    0px 1.2000000476837158px 3.5999999046325684px 0px #0000001A;
  `
};

// Copyright (c) Microsoft Corporation.
const VIDEO_GALLERY_Z_INDEX = 1; // The control bar must be in a higher z-band than the video gallery so the drop shadow appears on top of the video gallery
const CONTROL_BAR_Z_INDEX = VIDEO_GALLERY_Z_INDEX + 1; // The notification container should be in the highest z-band to ensure it shows on top of all other content.
const NOTIFICATION_CONTAINER_Z_INDEX = Math.max(CONTROL_BAR_Z_INDEX, VIDEO_GALLERY_Z_INDEX) + 1;
/**
 * @private
 */
const callControlsContainerStyles = react.mergeStyles(controlBarContainerStyles$1, {
    zIndex: CONTROL_BAR_Z_INDEX
});
const containerStyle$2 = {
    width: '100%',
    position: 'relative',
    minHeight: '13rem' // linked to minimum space allocated to media gallery
};
/**
 * @private
 */
const containerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, containerStyle$2), { minWidth: '30rem' }));
/**
 * @private
 */
const containerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, containerStyle$2), { minWidth: '17.5rem' }));
/**
 * @private
 */
const galleryParentContainerStyles = (backgroundColor) => ({
    root: {
        zIndex: VIDEO_GALLERY_Z_INDEX,
        width: '100%',
        background: backgroundColor
    }
});
/**
 * @private
 */
const mediaGalleryContainerStyles = {
    root: {
        height: '100%'
    }
};
/**
 * @private
 */
const notificationsContainerStyles = {
    root: {
        width: '100%',
        position: 'absolute',
        top: 0,
        left: 0,
        padding: '1rem',
        zIndex: NOTIFICATION_CONTAINER_Z_INDEX,
        pointerEvents: 'none' // to allow the operation of controls underneath the notification container
    }
};
/**
 * @private
 */
const bannerNotificationStyles = {
    root: {
        pointerEvents: 'auto' // to allow the dismissal or error and warning bars in the notification container
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * Notify the user that they're muted.
 */
function MutedNotification(props) {
    const locale = useLocale();
    const theme = react.useTheme();
    return React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "center", className: react.mergeStyles(props.speakingWhileMuted === true ? isSpeakingAndMutedAnimationStyles : isNotSpeakingAndMutedAnimationStyles) },
        React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(stackStyle(theme)) },
            React__default['default'].createElement(CallCompositeIcon, { iconName: "Muted", className: react.mergeStyles(iconStyle(theme)) }),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(textStyle(theme)), "aria-live": 'polite' }, locale.strings.call.mutedMessage)));
}
const stackStyle = (theme) => {
    return {
        background: theme.palette.black,
        gap: `1rem`,
        padding: `1rem`,
        borderRadius: theme.effects.roundedCorner4,
        width: 'fit-content',
        opacity: 0.8
    };
};
const iconStyle = (theme) => {
    return {
        color: theme.palette.white,
        maxHeight: '1.25rem'
    };
};
const textStyle = (theme) => {
    return {
        color: theme.palette.white,
        fontSize: `1rem`
    };
};
const isSpeakingAndMutedAnimationStyles = Object.assign({}, react.AnimationStyles.fadeIn100);
const isNotSpeakingAndMutedAnimationStyles = Object.assign(Object.assign({}, react.AnimationStyles.fadeOut200), { display: 'none' });

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallArrangement = (props) => {
    var _a;
    const containerClassName = React.useMemo(() => {
        return props.mobileView ? containerStyleMobile : containerStyleDesktop;
    }, [props.mobileView]);
    const theme = useTheme();
    const callGalleryStyles = React.useMemo(() => galleryParentContainerStyles(theme.palette.neutralLighterAlt), [theme.palette.neutralLighterAlt]);
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    // To be removed once feature is out of beta, replace with callCompositeContainerCSS
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    const callCompositeContainerFlex = () => {
        return {
            display: 'flex'
        };
    };
    let errorBarProps = props.errorBarProps;
    return React__default['default'].createElement("div", { ref: containerRef, className: react.mergeStyles(containerDivStyles) },
        React__default['default'].createElement(react.Stack, { verticalFill: true, horizontalAlign: "stretch", className: containerClassName, "data-ui-id": props.dataUiId },
            React__default['default'].createElement(react.Stack, { horizontal: true, grow: true },
                React__default['default'].createElement(react.Stack.Item, { styles: notificationsContainerStyles },
                    React__default['default'].createElement(react.Stack, { styles: bannerNotificationStyles },
                        React__default['default'].createElement(_ComplianceBanner, Object.assign({}, props.complianceBannerProps))),
                    errorBarProps !== false && React__default['default'].createElement(react.Stack, { styles: bannerNotificationStyles },
                        React__default['default'].createElement(ErrorBar, Object.assign({}, errorBarProps))),
                    !!props.mutedNotificationProps && React__default['default'].createElement(MutedNotification, Object.assign({}, props.mutedNotificationProps))),
                React__default['default'].createElement(react.Stack.Item, { grow: true, style: callCompositeContainerFlex() },
                    React__default['default'].createElement(react.Stack.Item, { styles: callGalleryStyles, grow: true }, props.onRenderGalleryContent && React__default['default'].createElement(react.Stack, { verticalFill: true, styles: mediaGalleryContainerStyles }, props.onRenderGalleryContent())))),
            ((_a = props.callControlProps) === null || _a === void 0 ? void 0 : _a.options) !== false && React__default['default'].createElement(react.Stack.Item, { className: callControlsContainerStyles },
                React__default['default'].createElement(CallControls, Object.assign({}, props.callControlProps, { containerWidth: containerWidth, containerHeight: containerHeight, isMobile: props.mobileView })))));
};

// Copyright (c) Microsoft Corporation.
/**
 * Provides data attributes to {@link LocalVideoCameraCycleButton} component.
 * @public
 */
const localVideoCameraCycleButtonSelector = reselect.createSelector([getDeviceManager], deviceManager => {
    return {
        cameras: deviceManager.cameras,
        selectedCamera: deviceManager.selectedCamera
    };
});

// Copyright (c) Microsoft Corporation.
const VideoGalleryStyles = {
    root: {
        height: '100%',
        minHeight: '10rem',
        // space affordance to ensure media gallery is never collapsed
        minWidth: '6rem'
    }
};
const localVideoViewOptions$3 = {
    scalingMode: 'Crop',
    isMirrored: true
};
const remoteVideoViewOptions$1 = {
    scalingMode: 'Crop'
};
/**
 * @private
 */
const MediaGallery = (props) => {
    const videoGalleryProps = usePropsFor$1(VideoGallery);
    const cameraSwitcherCameras = useSelector$1(localVideoCameraCycleButtonSelector);
    const cameraSwitcherCallback = useHandlers();
    const cameraSwitcherProps = React.useMemo(() => {
        return Object.assign(Object.assign({}, cameraSwitcherCallback), cameraSwitcherCameras);
    }, [cameraSwitcherCallback, cameraSwitcherCameras]);
    const onRenderAvatar = React.useCallback((userId, options) => {
        return React__default['default'].createElement(react.Stack, { className: react.mergeStyles({
                position: 'absolute',
                height: '100%',
                width: '100%'
            }) },
            React__default['default'].createElement(react.Stack, { styles: {
                    root: {
                        margin: 'auto',
                        maxHeight: '100%'
                    }
                } },
                React__default['default'].createElement(AvatarPersona, Object.assign({ userId: userId }, options, { dataProvider: props.onFetchAvatarPersonaData }))));
    }, [props.onFetchAvatarPersonaData]);
    useLocalVideoStartTrigger(!!props.isVideoStreamOn);
    const VideoGalleryMemoized = React.useMemo(() => {
        return React__default['default'].createElement(VideoGallery, Object.assign({}, videoGalleryProps, { localVideoViewOptions: localVideoViewOptions$3, remoteVideoViewOptions: remoteVideoViewOptions$1, styles: VideoGalleryStyles, layout: "floatingLocalVideo", showCameraSwitcherInLocalPreview: props.isMobile, localVideoCameraCycleButtonProps: cameraSwitcherProps, onRenderAvatar: onRenderAvatar }));
    }, [videoGalleryProps, props.isMobile, onRenderAvatar, cameraSwitcherProps]);
    return VideoGalleryMemoized;
};
/**
 * @private
 *
 * `shouldTransition` is an extra predicate that controls whether this hooks actually transitions the call.
 * The rule of hooks disallows calling the hook conditionally, so this predicate can be used to make the decision.
 */
const useLocalVideoStartTrigger = (isLocalVideoAvailable, shouldTransition) => {
    // Once a call is joined, we need to transition the local preview camera setting into the call.
    // This logic is needed on any screen that we might join a call from:
    // - The Media gallery
    // - The lobby page
    // - The networkReconnect interstitial that may show at the start of a call.
    //
    // @TODO: Can we simply have the callHandlers handle this transition logic.
    const [isButtonStatusSynced, setIsButtonStatusSynced] = React.useState(false);
    const isPreviewCameraOn = useSelector$1(getIsPreviewCameraOn);
    const mediaGalleryHandlers = useHandlers();
    React.useEffect(() => {
        if (shouldTransition !== false) {
            if (isPreviewCameraOn && !isLocalVideoAvailable && !isButtonStatusSynced) {
                mediaGalleryHandlers.onStartLocalVideo();
            }
            setIsButtonStatusSynced(true);
        }
    }, [shouldTransition, isButtonStatusSynced, isPreviewCameraOn, isLocalVideoAvailable, mediaGalleryHandlers]);
};

// So we need to explicitly layer the background and contents.
const OVERLAY_BACKGROUND_ZINDEX = 0;
const OVERLAY_CONTENT_ZINDEX = OVERLAY_BACKGROUND_ZINDEX + 1;
/**
 * @private
 */
const containerStyles = {
    root: {
        height: '100%',
        width: '100%',
        position: 'relative'
    }
};
/**
 * @private
 */
const overlayBackgroundStyles = (palette, isVideoReady) => {
    return {
        position: 'absolute',
        height: '100%',
        width: '100%',
        background: isVideoReady ? 'black' : palette.neutralLighterAlt,
        opacity: isVideoReady ? 0.6 : 1,
        zIndex: OVERLAY_BACKGROUND_ZINDEX
    };
};
/**
 * @private
 */
const overlayContentStyles = {
    height: '100%',
    width: '100%',
    zIndex: OVERLAY_CONTENT_ZINDEX
};
/**
 * @private
 */
const videoTileStyles = {
    root: {
        height: '100%',
        width: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
const onRenderEmptyPlaceholder = () => React__default['default'].createElement(React__default['default'].Fragment, null);
const localVideoViewOptions$2 = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * @private
 */
const ExpandedLocalVideoTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const renderElement = videoStream === null || videoStream === void 0 ? void 0 : videoStream.renderElement;
    const palette = useTheme().palette;
    React.useEffect(() => {
        if (videoStream && isVideoReady) {
            props.onCreateLocalStreamView && props.onCreateLocalStreamView(localVideoViewOptions$2).catch(err => console.log('Can not render video', err));
        }
    }, [isVideoReady, videoStream, props, renderElement]);
    return React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", styles: containerStyles, grow: true },
        React__default['default'].createElement(VideoTile, { styles: videoTileStyles, renderElement: renderElement ? React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement }) : undefined, onRenderPlaceholder: onRenderEmptyPlaceholder }, props.overlayContent && React__default['default'].createElement(React__default['default'].Fragment, null,
            React__default['default'].createElement(react.Stack, { className: react.mergeStyles(overlayBackgroundStyles(palette, isVideoReady)) }),
            React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(overlayContentStyles) }, props.overlayContent))));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const containerStyle$1 = {
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem',
    gap: `1.5rem`
};
/**
 * @private
 */
const titleContainerStyle = {
    gap: `1rem`
};
/**
 * @private
 */
const titleStyle$1 = (palette, isVideoReady) => ({
    fontSize: '1.25rem',
    fontWeight: react.FontWeights.semibold,
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});
/**
 * @private
 */
const moreDetailsStyle$1 = (palette, isVideoReady) => ({
    fontSize: '1rem',
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const NetworkReconnectTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const palette = useTheme().palette;
    const strings = useLocale().strings.call;
    const handlers = useHandlers(); // This tile may be shown at the beginning of a call.
    // So we need to transition local video to the call.
    useLocalVideoStartTrigger(!!props.localParticipantVideoStream.isAvailable);
    return React__default['default'].createElement(ExpandedLocalVideoTile, Object.assign({ localParticipantVideoStream: props.localParticipantVideoStream, overlayContent: React__default['default'].createElement(react.Stack, { verticalFill: true, horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(containerStyle$1), "aria-atomic": true },
            React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(titleContainerStyle) },
                React__default['default'].createElement(CallCompositeIcon, { iconName: "NetworkReconnectIcon", className: react.mergeStyles(titleStyle$1) }),
                React__default['default'].createElement(react.Text, { className: react.mergeStyles(titleStyle$1(palette, isVideoReady)), "aria-live": 'assertive' }, strings.networkReconnectTitle)),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(moreDetailsStyle$1(palette, isVideoReady)), "aria-live": 'assertive' }, strings.networkReconnectMoreDetails)) }, handlers));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const callStatusSelector = reselect.createSelector([getCallStatus, getIsScreenShareOn], (callStatus, isScreenShareOn) => {
    return {
        callStatus,
        isScreenShareOn
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const complianceBannerSelector = reselect__namespace.createSelector([getIsTranscriptionActive, getIsRecordingActive], (isTranscriptionActive, isRecordingActive) => {
    return {
        callTranscribeState: isTranscriptionActive,
        callRecordState: isRecordingActive
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mediaGallerySelector = reselect__namespace.createSelector([getLocalVideoStreams], localVideoStreams => {
    var _a, _b;
    return {
        isVideoStreamOn: !!((_b = (_a = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(stream => stream.mediaStreamType === 'Video')) === null || _a === void 0 ? void 0 : _a.view) === null || _b === void 0 ? void 0 : _b.target)
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mutedNotificationSelector = reselect__namespace.createSelector([getUserFacingDiagnostics], diagnostics => {
    var _a;
    return {
        speakingWhileMuted: !!((_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.speakingWhileMicrophoneIsMuted) === null || _a === void 0 ? void 0 : _a.value)
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const localVideoSelector = reselect__namespace.createSelector([callStatusSelector, getDeviceManager, getLocalVideoStreams], (callStatus, deviceManager, localVideoStreams) => {
    var _a, _b;
    let localVideoStream;
    if (_isInCall(callStatus.callStatus)) {
        localVideoStream = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(i => i.mediaStreamType === 'Video');
    }
    else if (_isPreviewOn(deviceManager)) {
        // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
        // handle cases where 'Preview' view is in progress and not necessary completed.
        localVideoStream = deviceManager.unparentedViews[0];
    }
    return {
        isAvailable: !!localVideoStream,
        isMirrored: (_a = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
        renderElement: (_b = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _b === void 0 ? void 0 : _b.target
    };
});

/**
 * @private
 */
const lobbySelector = reselect__namespace.createSelector([localVideoSelector], localVideoStreamInfo => {
    return {
        localParticipantVideoStream: localVideoStreamInfo
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const networkReconnectTileSelector = reselect__namespace.createSelector([getUserFacingDiagnostics, lobbySelector], (diagnostics, lobbyProps) => {
    var _a;
    return {
        networkReconnectValue: (_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReconnect) === null || _a === void 0 ? void 0 : _a.value,
        localParticipantVideoStream: lobbyProps.localParticipantVideoStream
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallPage = (props) => {
    const { callInvitationURL, onRenderAvatar, onFetchAvatarPersonaData, onFetchParticipantMenuItems, options, mobileView } = props; // To use useProps to get these states, we need to create another file wrapping Call,
    // It seems unnecessary in this case, so we get the updated states using this approach.
    const { callStatus } = useSelector$1(callStatusSelector);
    const mediaGalleryProps = useSelector$1(mediaGallerySelector);
    const mediaGalleryHandlers = useHandlers();
    const complianceBannerProps = useSelector$1(complianceBannerSelector);
    const errorBarProps = usePropsFor$1(ErrorBar);
    const mutedNotificationProps = useSelector$1(mutedNotificationSelector);
    const networkReconnectTileProps = useSelector$1(networkReconnectTileSelector);
    const strings = useLocale().strings.call; // Reduce the controls shown when mobile view is enabled.
    const callControlOptions = mobileView ? reduceCallControlsForMobile(options === null || options === void 0 ? void 0 : options.callControls) : options === null || options === void 0 ? void 0 : options.callControls;
    return React__default['default'].createElement(CallArrangement, { complianceBannerProps: Object.assign(Object.assign({}, complianceBannerProps), { strings }), errorBarProps: (options === null || options === void 0 ? void 0 : options.errorBar) !== false && Object.assign({}, errorBarProps), mutedNotificationProps: mutedNotificationProps, callControlProps: {
            callInvitationURL: callInvitationURL,
            onFetchParticipantMenuItems: onFetchParticipantMenuItems,
            options: callControlOptions,
            increaseFlyoutItemSize: mobileView
        }, mobileView: mobileView, onRenderGalleryContent: () => _isInCall(callStatus) ? isNetworkHealthy(networkReconnectTileProps.networkReconnectValue) ? React__default['default'].createElement(MediaGallery, Object.assign({ isMobile: mobileView }, mediaGalleryProps, mediaGalleryHandlers, { onRenderAvatar: onRenderAvatar, onFetchAvatarPersonaData: onFetchAvatarPersonaData })) : React__default['default'].createElement(NetworkReconnectTile, Object.assign({}, networkReconnectTileProps)) : React__default['default'].createElement(React__default['default'].Fragment, null), dataUiId: 'call-page' });
};
/**
 * @private
 */
const isNetworkHealthy = (value) => {
    // We know that the value is actually of type DiagnosticQuality for this diagnostic.
    // We ignore any boolen values, considering the network to still be healthy.
    // Thus, only DiagnosticQuality.Poor or .Bad indicate network problems.
    return value === true || value === false || value === undefined || value === communicationCalling.DiagnosticQuality.Good;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mainStackTokens = {
    childrenGap: '1rem'
};
/**
 * @private
 */
const dropDownStyles = (theme) => ({
    caretDownWrapper: {
        height: '2.5rem',
        lineHeight: '2.5rem'
    },
    dropdownItem: {
        fontSize: '0.875rem',
        height: '2.5rem',
        background: theme.palette.neutralQuaternaryAlt
    },
    dropdown: {
        height: '2.5rem',
        width: '100%',
        svg: {
            verticalAlign: 'top'
        }
    },
    title: {
        fontSize: '0.875rem',
        height: '2.5rem',
        lineHeight: '2.3125rem'
    },
    label: {
        fontWeight: 600,
        fontSize: '0.875rem'
    },
    errorMessage: {
        fontSize: '0.875rem'
    }
});
/**
 * @private
 */
const dropDownTitleIconStyles = react.mergeStyles({
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    minWidth: '0',
    maxWidth: '100%',
    overflowWrap: 'break-word',
    margin: '.063rem'
});
/**
 * @private
 */
const optionIconStyles = react.mergeStyles({
    marginRight: '8px',
    verticalAlign: 'text-top'
});

/**
 * @private
 */
const ConfigurationpageCameraDropdown = (props) => {
    return props.cameraGrantedDropdown;
};

/**
 * @private
 */
const ConfigurationpageMicDropdown = (props) => {
    return props.micGrantedDropdown;
};

const getDropDownList = (list) => {
    // Remove duplicates
    const noDuplicates = new Map();
    for (const item of list) {
        noDuplicates.set(item.id, item);
    }
    const dropdownList = [];
    for (const item of noDuplicates.values()) {
        dropdownList.push({
            key: item.id,
            text: item.name === '' ? item.deviceType : item.name
        });
    }
    return dropdownList;
};
const getOptionIcon = (type) => {
    if (type === 'Camera') {
        return React__default['default'].createElement(CallCompositeIcon, { iconName: "LocalDeviceSettingsCamera", className: optionIconStyles });
    }
    else if (type === 'Microphone') {
        return React__default['default'].createElement(CallCompositeIcon, { iconName: "LocalDeviceSettingsMic", className: optionIconStyles });
    }
    else if (type === 'Speaker') {
        return React__default['default'].createElement(CallCompositeIcon, { iconName: "LocalDeviceSettingsSpeaker", className: optionIconStyles });
    }
    else {
        return undefined;
    }
};
const onRenderTitle = (iconType, props) => {
    const icon = props && getOptionIcon(iconType);
    return props ? React__default['default'].createElement("div", { className: dropDownTitleIconStyles },
        icon,
        React__default['default'].createElement("span", null, props[0].text)) : React__default['default'].createElement(React__default['default'].Fragment, null);
};
const localVideoViewOptions$1 = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * @private
 */
const LocalDeviceSettings = (props) => {
    var _a;
    const theme = useTheme();
    const locale = useLocale();
    const defaultPlaceHolder = locale.strings.call.defaultPlaceHolder;
    const cameraLabel = locale.strings.call.cameraLabel;
    const soundLabel = locale.strings.call.soundLabel;
    const cameraPermissionGranted = props.cameraPermissionGranted;
    const micPermissionGranted = props.microphonePermissionGranted;
    const cameraGrantedDropdown = React__default['default'].createElement(react.Dropdown, { "data-ui-id": "call-composite-local-camera-settings", "aria-labelledby": 'call-composite-local-camera-settings-label', placeholder: defaultPlaceHolder, options: cameraPermissionGranted ? getDropDownList(props.cameras) : [{
                key: 'deniedOrUnknown',
                text: ''
            }], styles: dropDownStyles(theme), disabled: !cameraPermissionGranted, errorMessage: props.cameraPermissionGranted === undefined || props.cameraPermissionGranted ? undefined : locale.strings.call.cameraPermissionDenied, defaultSelectedKey: micPermissionGranted ? props.selectedCamera ? props.selectedCamera.id : props.cameras ? (_a = props.cameras[0]) === null || _a === void 0 ? void 0 : _a.id : '' : 'deniedOrUnknown', onChange: (event, option, index) => {
            props.onSelectCamera(props.cameras[index !== null && index !== void 0 ? index : 0], localVideoViewOptions$1);
        }, onRenderTitle: (props) => onRenderTitle('Camera', props) });
    const micGrantedDropdown = React__default['default'].createElement(React__default['default'].Fragment, null, React__default['default'].createElement(react.Dropdown, { "aria-labelledby": 'call-composite-local-sound-settings-label', placeholder: defaultPlaceHolder, styles: dropDownStyles(theme), disabled: !micPermissionGranted, errorMessage: props.microphonePermissionGranted === undefined || props.microphonePermissionGranted ? undefined : locale.strings.call.microphonePermissionDenied, options: micPermissionGranted ? getDropDownList(props.microphones) : [{
                key: 'deniedOrUnknown',
                text: ''
            }], defaultSelectedKey: micPermissionGranted ? props.selectedMicrophone ? props.selectedMicrophone.id : defaultDeviceId(props.microphones) : 'deniedOrUnknown', onChange: (event, option, index) => {
            props.onSelectMicrophone(props.microphones[index !== null && index !== void 0 ? index : 0]);
        }, onRenderTitle: (props) => onRenderTitle('Microphone', props) }));
    return React__default['default'].createElement(react.Stack, { "data-ui-id": "call-composite-device-settings", tokens: mainStackTokens },
        React__default['default'].createElement(react.Stack, null,
            React__default['default'].createElement(react.Label, { id: 'call-composite-local-camera-settings-label', className: react.mergeStyles(dropDownStyles(theme).label), disabled: !cameraPermissionGranted }, cameraLabel),
            React__default['default'].createElement(ConfigurationpageCameraDropdown, { cameraGrantedDropdown: cameraGrantedDropdown, cameraPermissionGranted: cameraPermissionGranted !== null && cameraPermissionGranted !== void 0 ? cameraPermissionGranted : false })),
        React__default['default'].createElement(react.Stack, null,
            React__default['default'].createElement(react.Label, { id: 'call-composite-local-sound-settings-label', className: react.mergeStyles(dropDownStyles(theme).label), disabled: !micPermissionGranted }, soundLabel),
            React__default['default'].createElement(react.Stack, { "data-ui-id": "call-composite-sound-settings", tokens: mainStackTokens },
                React__default['default'].createElement(ConfigurationpageMicDropdown, { micGrantedDropdown: micGrantedDropdown, micPermissionGranted: micPermissionGranted !== null && micPermissionGranted !== void 0 ? micPermissionGranted : false }),
                React__default['default'].createElement(react.Dropdown, { "aria-labelledby": 'call-composite-local-sound-settings-label', placeholder: defaultPlaceHolder, styles: dropDownStyles(theme), disabled: props.speakers.length === 0, options: getDropDownList(props.speakers), defaultSelectedKey: props.selectedSpeaker ? props.selectedSpeaker.id : defaultDeviceId(props.speakers), onChange: (event, option, index) => {
                        props.onSelectSpeaker(props.speakers[index !== null && index !== void 0 ? index : 0]);
                    }, onRenderTitle: (props) => onRenderTitle('Speaker', props) }))));
};
const defaultDeviceId = (devices) => {
    if (devices.length === 0) {
        return '';
    }
    const defaultDevice = devices.find(device => device.isSystemDefault);
    if (defaultDevice) {
        return defaultDevice.id;
    }
    return devices[0].id;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const videoCameraIconStyle = react.mergeStyles({
    marginRight: '0.375rem',
    fontSize: '1.375rem'
});
/**
 * @private
 */
const buttonStyle = react.mergeStyles({
    fontWeight: 600,
    fontSize: '0.875rem',
    // 14px
    height: '2.75rem',
    width: '100%'
});
/**
 * @private
 */
const buttonWithIconStyles = {
    textContainer: {
        display: 'contents'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const StartCallButton = (props) => {
    const { rejoinCall } = props;
    const locale = useLocale();
    return React__default['default'].createElement(react.PrimaryButton, Object.assign({}, props, { "data-ui-id": "call-composite-start-call-button", className: react.mergeStyles(buttonStyle, props.className), styles: buttonWithIconStyles, text: rejoinCall ? locale.strings.call.rejoinCallButtonLabel : locale.strings.call.startCallButtonLabel, onRenderIcon: () => React__default['default'].createElement(reactIcons.Video20Filled, { className: videoCameraIconStyle }) }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const devicePermissionSelector = reselect__namespace.createSelector([getDeviceManager], deviceManager => {
    return {
        video: deviceManager.deviceAccess ? deviceManager.deviceAccess.video : undefined,
        audio: deviceManager.deviceAccess ? deviceManager.deviceAccess.audio : undefined
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const localPreviewSelector = reselect__namespace.createSelector([getDeviceManager], deviceManager => {
    // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
    // handle cases where 'Preview' view is in progress and not necessary completed.
    const view = deviceManager.unparentedViews.length > 0 && deviceManager.unparentedViews[0].view;
    return {
        videoStreamElement: view ? view.target : null
    };
});

// Copyright (c) Microsoft Corporation.
const localPreviewContainerStyle = {
    borderRadius: '.25rem'
};
/**
 * @private
 */
const localPreviewContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, localPreviewContainerStyle), { width: '50%', minWidth: '11rem', maxWidth: '25rem', height: '18.75rem', padding: '0.5rem' }));
/**
 * @private
 */
const localPreviewContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, localPreviewContainerStyle), { width: '100%', height: '100%' }));
/**
 * @private
 */
const cameraOffLabelStyle = react.mergeStyles({
    fontSize: '0.75rem' // 12px
});
/**
 * @private
 */
const localPreviewTileStyle = {
    root: {
        borderRadius: '.25rem'
    }
};

var __awaiter$7 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const LocalPreview = (props) => {
    const locale = useLocale();
    const cameraButtonProps = usePropsFor$1(CameraButton);
    const localPreviewProps = useSelector$1(localPreviewSelector);
    const devicesButtonProps = usePropsFor$1(DevicesButton);
    const { audio: microphonePermissionGranted, video: cameraPermissionGranted } = useSelector$1(devicePermissionSelector);
    const isLocalMicrophoneEnabled = useSelector$1(getLocalMicrophoneEnabled);
    const adapter = useAdapter();
    const onToggleMic = React.useCallback(() => __awaiter$7(void 0, void 0, void 0, function* () {
        isLocalMicrophoneEnabled ? adapter.mute() : adapter.unmute();
    }), [adapter, isLocalMicrophoneEnabled]);
    const theme = useTheme();
    const onRenderPlaceholder = React.useCallback(() => {
        return React__default['default'].createElement(react.Stack, { className: react.mergeStyles({
                width: '100%',
                height: '100%'
            }), verticalAlign: "center", tokens: {
                childrenGap: '0.25rem'
            } },
            React__default['default'].createElement(react.Stack.Item, { align: "center" },
                React__default['default'].createElement(CallCompositeIcon, { iconName: "LocalPreviewPlaceholder", className: react.mergeStyles(cameraOffLabelStyle, {
                        color: theme.palette.neutralTertiary
                    }) })),
            React__default['default'].createElement(react.Stack.Item, { align: "center" },
                React__default['default'].createElement(react.Text, { className: react.mergeStyles(cameraOffLabelStyle, {
                        color: theme.palette.neutralSecondary
                    }) }, locale.strings.call.cameraTurnedOff)));
    }, [theme, locale.strings.call.cameraTurnedOff]);
    const devicesButtonStyles = props.mobileView ? {
        menuStyles: {
            menuItemStyles: buttonFlyoutIncreasedSizeStyles
        }
    } : undefined;
    return React__default['default'].createElement(react.Stack, { "data-ui-id": "call-composite-local-preview", className: props.mobileView ? localPreviewContainerStyleMobile : localPreviewContainerStyleDesktop },
        React__default['default'].createElement(VideoTile, { styles: localPreviewTileStyle, renderElement: (localPreviewProps === null || localPreviewProps === void 0 ? void 0 : localPreviewProps.videoStreamElement) ? React__default['default'].createElement(StreamMedia, { videoStreamElement: localPreviewProps.videoStreamElement }) : undefined, onRenderPlaceholder: onRenderPlaceholder },
            React__default['default'].createElement(ControlBar, { layout: "floatingBottom" },
                React__default['default'].createElement(MicrophoneButton, { "data-ui-id": "call-composite-local-device-settings-microphone-button", checked: isLocalMicrophoneEnabled, onToggleMicrophone: onToggleMic, disabled: !microphonePermissionGranted, showLabel: true }),
                React__default['default'].createElement(CameraButton, Object.assign({ "data-ui-id": "call-composite-local-device-settings-camera-button" }, cameraButtonProps, { showLabel: true, disabled: !cameraPermissionGranted })),
                props.showDevicesButton && React__default['default'].createElement(DevicesButton, Object.assign({ "data-ui-id": "call-composite-local-device-settings-options-button" }, devicesButtonProps, { disabled: !microphonePermissionGranted || !cameraPermissionGranted, showLabel: true, styles: devicesButtonStyles })))));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const configurationStackTokensDesktop = {
    childrenGap: '2rem'
};
/**
 * @private
 */
const configurationStackTokensMobile = {
    childrenGap: '1rem'
};
const configurationContainerStyle = {
    height: '100%',
    width: '100%',
    padding: '0.5rem'
};
/**
 * @private
 */
const configurationContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, configurationContainerStyle), { minWidth: '25rem', 
    // sum of min-width from children + ChildrenGap * (nb of children - 1) + padding * 2 = (11 + 11) + (2 * 1) + 0.5 * 2
    minHeight: '22rem' // max height of SelectionContainer + padding * 2 = 21 + 0.5 * 2
 }));
/**
 * @private
 */
const configurationContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, configurationContainerStyle), { minWidth: '16rem', 
    // from LocalPreview: ControlBar width + 0.5 * 2 for spacing + padding * 2 = 14 + 0.5 * 2 + 0.5 * 2
    minHeight: '13rem' }));
/**
 * @private
 */
const selectionContainerStyle = react.mergeStyles({
    width: '50%',
    minWidth: '11rem',
    maxWidth: '18.75rem',
    padding: '0.5rem'
});
/**
 * @private
 */
const titleContainerStyleDesktop = react.mergeStyles({
    fontSize: '1.25rem',
    lineHeight: '1.75rem',
    fontWeight: 600
});
/**
 * @private
 */
const titleContainerStyleMobile = react.mergeStyles({
    fontSize: '1.0625rem',
    lineHeight: '1.375rem',
    fontWeight: 600,
    textAlign: 'center'
});
/**
 * @private
 */
const callDetailsContainerStylesDesktop = {
    root: {
        marginBottom: '1.563rem'
    }
};
const callDetailsStyle = {
    fontSize: '0.9375',
    lineHeight: '1.25rem',
    marginTop: '0.25rem'
};
/**
 * @private
 */
const callDetailsStyleDesktop = react.mergeStyles(Object.assign({}, callDetailsStyle));
/**
 * @private
 */
const callDetailsStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, callDetailsStyle), { textAlign: 'center' }));
/**
 * @private
 */
const startCallButtonContainerStyleDesktop = {
    root: {
        paddingTop: '1.125rem'
    }
};
/**
 * @private
 */
const startCallButtonContainerStyleMobile = {
    root: {
        textAlign: 'center'
    }
};
/**
 * @private
 */
const startCallButtonStyleMobile = react.mergeStyles({
    width: '100%',
    maxWidth: 'unset'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ConfigurationPage = (props) => {
    var _a;
    const { startCallHandler, mobileView } = props;
    const options = useAdaptedSelector(getSelector$1(DevicesButton));
    const localDeviceSettingsHandlers = useHandlers();
    const { video: cameraPermissionGranted, audio: microphonePermissionGranted } = useSelector$1(devicePermissionSelector);
    let errorBarProps = usePropsFor$1(ErrorBar);
    const adapter = useAdapter();
    const deviceState = adapter.getState().devices;
    let disableStartCallButton = !microphonePermissionGranted || ((_a = deviceState.microphones) === null || _a === void 0 ? void 0 : _a.length) === 0;
    const locale = useLocale();
    const title = React__default['default'].createElement(react.Stack.Item, { className: mobileView ? titleContainerStyleMobile : titleContainerStyleDesktop }, locale.strings.call.configurationPageTitle);
    const callDescription = locale.strings.call.configurationPageCallDetails && React__default['default'].createElement(react.Stack.Item, { className: mobileView ? callDetailsStyleMobile : callDetailsStyleDesktop }, locale.strings.call.configurationPageCallDetails);
    let mobileWithPreview = mobileView;
    return React__default['default'].createElement(react.Stack, { className: mobileView ? configurationContainerStyleMobile : configurationContainerStyleDesktop },
        React__default['default'].createElement(react.Stack, { styles: bannerNotificationStyles },
            React__default['default'].createElement(ErrorBar, Object.assign({}, errorBarProps))),
        React__default['default'].createElement(react.Stack, { grow: true, horizontal: !mobileWithPreview, horizontalAlign: mobileWithPreview ? 'stretch' : 'center', verticalAlign: "center", tokens: mobileWithPreview ? configurationStackTokensMobile : configurationStackTokensDesktop },
            mobileWithPreview && React__default['default'].createElement(react.Stack.Item, null,
                title,
                callDescription),
            localPreviewTrampoline(mobileWithPreview),
            React__default['default'].createElement(react.Stack, { className: mobileView ? undefined : selectionContainerStyle },
                !mobileWithPreview && React__default['default'].createElement(React__default['default'].Fragment, null,
                    React__default['default'].createElement(react.Stack.Item, { styles: callDetailsContainerStylesDesktop },
                        title,
                        callDescription),
                    React__default['default'].createElement(LocalDeviceSettings, Object.assign({}, options, localDeviceSettingsHandlers, { cameraPermissionGranted: cameraPermissionGranted, microphonePermissionGranted: microphonePermissionGranted }))),
                React__default['default'].createElement(react.Stack, { styles: mobileWithPreview ? startCallButtonContainerStyleMobile : startCallButtonContainerStyleDesktop },
                    React__default['default'].createElement(StartCallButton, { className: mobileWithPreview ? startCallButtonStyleMobile : undefined, onClick: startCallHandler, disabled: disableStartCallButton })))));
};
const localPreviewTrampoline = (mobileView, doNotShow) => {
    return React__default['default'].createElement(LocalPreview, { mobileView: mobileView, showDevicesButton: mobileView });
};

/**
 * @private
 */
const containerStyle = {
    maxWidth: '22.5rem',
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem'
};
/**
 * @private
 */
const containerItemGap = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const rejoinCallButtonContainerStyles = {
    root: {
        paddingTop: '1.125rem'
    }
};
/**
 * @private
 */
const titleStyles = {
    fontSize: '1.25rem',
    fontWeight: 600
};
/**
 * @private
 */
const moreDetailsStyles = {
    fontSize: '1rem'
};

// Copyright (c) Microsoft Corporation.
/**
 * Generic page with a title and more details text for serving up a notice to the user.
 *
 * @private
 */
function NoticePage(props) {
    const adapter = useAdapter();
    return React__default['default'].createElement(react.Stack, { verticalFill: true, verticalAlign: "center", horizontalAlign: "center", "data-ui-id": props.dataUiId, "aria-atomic": true },
        React__default['default'].createElement(react.Stack, { className: react.mergeStyles(containerStyle), tokens: containerItemGap },
            props.iconName && React__default['default'].createElement(CallCompositeIcon, { iconName: props.iconName }),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(titleStyles), "aria-live": "assertive" }, props.title),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(moreDetailsStyles), "aria-live": "assertive" }, props.moreDetails),
            React__default['default'].createElement(react.Stack, { styles: rejoinCallButtonContainerStyles },
                React__default['default'].createElement(StartCallButton, { onClick: () => adapter.joinCall(), disabled: false, rejoinCall: true, autoFocus: true }))));
}

/**
 * @private
 */
const overlayContainerStyle = {
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem'
};
/**
 * @private
 */
const titleStyle = (palette, isVideoReady) => {
    return {
        fontSize: '1.75rem',
        color: isVideoReady ? 'white' : palette.neutralPrimary,
        textAlign: 'center'
    };
};
/**
 * @private
 */
const moreDetailsStyle = (palette, isVideoReady) => ({
    fontSize: '1rem',
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const LobbyTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const palette = useTheme().palette;
    const handlers = useHandlers();
    return React__default['default'].createElement(ExpandedLocalVideoTile, Object.assign({ localParticipantVideoStream: props.localParticipantVideoStream, overlayContent: props.overlayProps ? React__default['default'].createElement(react.Stack, { verticalFill: true, horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(overlayContainerStyle), "aria-atomic": true },
            React__default['default'].createElement(react.Stack.Item, { className: react.mergeStyles(titleStyle(palette, isVideoReady)) }, props.overlayProps.overlayIcon),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(titleStyle(palette, isVideoReady)), "aria-live": "assertive" }, props.overlayProps.title),
            props.overlayProps.moreDetails && React__default['default'].createElement(react.Text, { className: react.mergeStyles(moreDetailsStyle(palette, isVideoReady)), "aria-live": "assertive" }, props.overlayProps.moreDetails)) : undefined }, handlers));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const LobbyPage = (props) => {
    var _a, _b, _c, _d;
    const errorBarProps = usePropsFor$1(ErrorBar);
    const lobbyProps = useSelector$1(lobbySelector);
    const strings = useLocale().strings.call;
    const callState = useSelector$1(getCallStatus);
    const inLobby = callState === 'InLobby';
    const participants = (_a = useSelector$1(getRemoteParticipants)) !== null && _a !== void 0 ? _a : {};
    useLocalVideoStartTrigger(lobbyProps.localParticipantVideoStream.isAvailable, inLobby); // Reduce the controls shown when mobile view is enabled.
    let callControlOptions = props.mobileView ? reduceCallControlsForMobile((_b = props.options) === null || _b === void 0 ? void 0 : _b.callControls) : (_c = props.options) === null || _c === void 0 ? void 0 : _c.callControls;
    callControlOptions = disableCallControls(callControlOptions, ['screenShareButton', 'participantsButton']);
    return React__default['default'].createElement(CallArrangement, { complianceBannerProps: {
            strings
        }, errorBarProps: ((_d = props.options) === null || _d === void 0 ? void 0 : _d.errorBar) !== false && Object.assign({}, errorBarProps), callControlProps: {
            options: callControlOptions,
            increaseFlyoutItemSize: props.mobileView
        }, mobileView: props.mobileView, onRenderGalleryContent: () => React__default['default'].createElement(LobbyTile, Object.assign({}, lobbyProps, { overlayProps: overlayProps(strings, inLobby, Object.values(participants)) })), dataUiId: 'lobby-page' });
};
const overlayProps = (strings, inLobby, remoteParticipants) => {
    /**
     * Only grab the first participant because there will only be one in this situation.
     * when starting a call with multiple people the call goes to the connected state and composite goes directly to
     * videoGallery.
     *
     * We also need to check the participant state since in a group call the remote participants array will populate just before
     * the user joins. In this situation we also check the participant states. in a groupCall the state of the participants
     * will be 'Idle'.
     */
    const outboundCallParticipant = remoteParticipants[0] && ['Ringing', 'Connecting'].includes(remoteParticipants[0].state) && remoteParticipants.length === 1 ? remoteParticipants[0] : undefined;
    return inLobby ? overlayPropsWaitingToBeAdmitted(strings) : outboundCallParticipant ? overlayPropsOutboundCall(strings, outboundCallParticipant) : overlayPropsConnectingToCall(strings);
};
const overlayPropsConnectingToCall = (strings) => ({
    title: strings.lobbyScreenConnectingToCallTitle,
    moreDetails: strings.lobbyScreenConnectingToCallMoreDetails,
    overlayIcon: React__default['default'].createElement(CallCompositeIcon, { iconName: "LobbyScreenConnectingToCall" })
});
const overlayPropsWaitingToBeAdmitted = (strings) => ({
    title: strings.lobbyScreenWaitingToBeAdmittedTitle,
    moreDetails: strings.lobbyScreenWaitingToBeAdmittedMoreDetails,
    overlayIcon: React__default['default'].createElement(CallCompositeIcon, { iconName: "LobbyScreenWaitingToBeAdmitted" })
});
const overlayPropsOutboundCall = (strings, participant) => {
    if (communicationCommon.isPhoneNumberIdentifier(participant.identifier)) {
        return {
            title: participant.identifier.phoneNumber,
            moreDetails: outboundCallStringsTrampoline()
        };
    }
    else {
        return {
            title: outboundCallStringsTrampoline()
        };
    }
};
const outboundCallStringsTrampoline = (strings) => {
    return '';
};

// Copyright (c) Microsoft Corporation.
const mainScreenContainerStyle = {
    height: '100%',
    width: '100%'
};
/**
 * @private
 */
const mainScreenContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, mainScreenContainerStyle), { minWidth: '30rem', 
    // max of min-width of composite pages (Call page)
    minHeight: '22rem' // max height of min-height of composite pages (Configuration page)
 }));
/**
 * @private
 */
const mainScreenContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, mainScreenContainerStyle), { minWidth: '17.5rem', 
    // max of min-width of composite pages (Call page)
    minHeight: '13rem' // max height of min-height of composite pages (Configuration page & Call page)
 }));

var __awaiter$6 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const MainScreen = (props) => {
    const { callInvitationUrl, onRenderAvatar, onFetchAvatarPersonaData, onFetchParticipantMenuItems } = props;
    const page = useSelector$1(getPage);
    const adapter = useAdapter();
    const locale = useLocale();
    let pageElement;
    switch (page) {
        case 'configuration':
            pageElement = React__default['default'].createElement(ConfigurationPage, { mobileView: props.mobileView, startCallHandler: () => {
                    adapter.joinCall();
                } });
            break;
        case 'accessDeniedTeamsMeeting':
            pageElement = React__default['default'].createElement(NoticePage, { iconName: "NoticePageAccessDeniedTeamsMeeting", title: locale.strings.call.failedToJoinTeamsMeetingReasonAccessDeniedTitle, moreDetails: locale.strings.call.failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails, dataUiId: 'access-denied-teams-meeting-page' });
            break;
        case 'removedFromCall':
            pageElement = React__default['default'].createElement(NoticePage, { iconName: "NoticePageRemovedFromCall", title: locale.strings.call.removedFromCallTitle, moreDetails: locale.strings.call.removedFromCallMoreDetails, dataUiId: 'removed-from-call-page' });
            break;
        case 'joinCallFailedDueToNoNetwork':
            pageElement = React__default['default'].createElement(NoticePage, { iconName: "NoticePageJoinCallFailedDueToNoNetwork", title: locale.strings.call.failedToJoinCallDueToNoNetworkTitle, moreDetails: locale.strings.call.failedToJoinCallDueToNoNetworkMoreDetails, dataUiId: 'join-call-failed-due-to-no-network-page' });
            break;
        case 'leftCall':
            pageElement = React__default['default'].createElement(NoticePage, { iconName: "NoticePageLeftCall", title: locale.strings.call.leftCallTitle, moreDetails: locale.strings.call.leftCallMoreDetails, dataUiId: 'left-call-page' });
            break;
        case 'lobby':
            pageElement = React__default['default'].createElement(LobbyPage, { mobileView: props.mobileView, options: props.options });
            break;
        case 'call':
            pageElement = React__default['default'].createElement(CallPage, { onRenderAvatar: onRenderAvatar, callInvitationURL: callInvitationUrl, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: onFetchParticipantMenuItems, mobileView: props.mobileView, options: props.options });
            break;
        /* @conditional-compile-remove(PSTN-calls) */
        /* @conditional-compile-remove(one-to-n-calling) */
        case holdPageTrampoline():
            pageElement = React__default['default'].createElement(React__default['default'].Fragment, null);
            break;
        case unsupportedEnvironmentPageTrampoline():
            pageElement = React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    if (!pageElement) {
        throw new Error('Invalid call composite page');
    }
    // default retElement for stable version
    let retElement = pageElement;
    return retElement;
};
/**
 * A customizable UI composite for calling experience.
 *
 * @remarks Call composite min width/height are as follow:
 * - mobile: 17.5rem x 21rem (280px x 336px, with default rem at 16px)
 * - desktop: 30rem x 22rem (480px x 352px, with default rem at 16px)
 *
 * @public
 */
const CallComposite = (props) => {
    const { adapter, callInvitationUrl, onFetchAvatarPersonaData, onFetchParticipantMenuItems, options, formFactor = 'desktop' } = props;
    React.useEffect(() => {
        (() => __awaiter$6(void 0, void 0, void 0, function* () {
            yield adapter.askDevicePermission({
                video: true,
                audio: true
            });
            adapter.queryCameras();
            adapter.queryMicrophones();
            adapter.querySpeakers();
        }))();
    }, [adapter]);
    const mobileView = formFactor === 'mobile';
    const mainScreenContainerClassName = React.useMemo(() => {
        return mobileView ? mainScreenContainerStyleMobile : mainScreenContainerStyleDesktop;
    }, [mobileView]);
    return React__default['default'].createElement("div", { className: mainScreenContainerClassName },
        React__default['default'].createElement(BaseProvider, Object.assign({}, props),
            React__default['default'].createElement(CallAdapterProvider, { adapter: adapter },
                React__default['default'].createElement(MainScreen, { callInvitationUrl: callInvitationUrl, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: onFetchParticipantMenuItems, mobileView: mobileView, options: options }))));
};
const holdPageTrampoline = () => {
    return 'call';
};
const unsupportedEnvironmentPageTrampoline = () => {
    return 'call';
};

/**
 * @private
 */
class ParticipantSubscriber {
    constructor(participant, emitter) {
        this.isMutedChangedHandler = () => {
            this.emitter.emit('isMutedChanged', {
                participantId: this.participant.identifier,
                isMuted: this.participant.isMuted
            });
        };
        this.displayNameChangedHandler = () => {
            this.emitter.emit('displayNameChanged', {
                participantId: this.participant.identifier,
                displayName: this.participant.displayName
            });
        };
        this.isSpeakingChangedHandler = () => {
            this.emitter.emit('isSpeakingChanged', {
                participantId: this.participant.identifier,
                isSpeaking: this.participant.isSpeaking
            });
        };
        this.videoStreamsUpdatedHandler = (event) => {
            this.emitter.emit('videoStreamsUpdated', event);
        };
        this.participant = participant;
        this.emitter = emitter;
        this.subscribeParticipantEvents();
    }
    subscribeParticipantEvents() {
        this.participant.on('isMutedChanged', this.isMutedChangedHandler);
        this.participant.on('displayNameChanged', this.displayNameChangedHandler);
        this.participant.on('isSpeakingChanged', this.isSpeakingChangedHandler);
        this.participant.on('videoStreamsUpdated', this.videoStreamsUpdatedHandler);
    }
    unsubscribeAll() {
        this.participant.off('isMutedChanged', this.isMutedChangedHandler);
        this.participant.off('displayNameChanged', this.displayNameChangedHandler);
        this.participant.off('isSpeakingChanged', this.isSpeakingChangedHandler);
        this.participant.off('videoStreamsUpdated', this.videoStreamsUpdatedHandler);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
class DiagnosticsForwarder {
    constructor(emitter, call) {
        this.unsubscribe = () => {
            this._diagnostics.network.off('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
            this._diagnostics.media.off('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
        };
        this._diagnostics = call.feature(communicationCalling.Features.UserFacingDiagnostics);
        this._emitter = emitter;
        this.subscribe();
    }
    subscribe() {
        this._diagnostics.network.on('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
        this._diagnostics.media.on('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
    }
    networkDiagnosticsChanged(args) {
        const event = Object.assign({ type: 'network' }, args);
        this._emitter.emit('diagnosticChanged', event);
    }
    mediaDiagnosticsChanged(args) {
        const event = Object.assign({ type: 'media' }, args);
        this._emitter.emit('diagnosticChanged', event);
    }
}

var __awaiter$5 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/** Context of call, which is a centralized context for all state updates */
class CallContext {
    constructor(clientState, isTeamsCall) {
        var _a;
        this.emitter = new EventEmitter.EventEmitter();
        this.state = {
            isLocalPreviewMicrophoneEnabled: false,
            userId: clientState.userId,
            displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName,
            devices: clientState.deviceManager,
            call: undefined,
            page: 'configuration',
            latestErrors: clientState.latestErrors,
            isTeamsCall
        };
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setIsLocalMicrophoneEnabled(isLocalPreviewMicrophoneEnabled) {
        this.setState(Object.assign(Object.assign({}, this.state), { isLocalPreviewMicrophoneEnabled }));
    } // This is the key to find current call object in client state
    setCurrentCallId(callId) {
        this.callId = callId;
    }
    onCallEnded(handler) {
        this.emitter.on('callEnded', handler);
    }
    offCallEnded(handler) {
        this.emitter.off('callEnded', handler);
    }
    updateClientState(clientState) {
        var _a;
        let call = this.callId ? clientState.calls[this.callId] : undefined;
        const latestEndedCall = findLatestEndedCall(clientState.callsEnded); // As the state is transitioning to a new state, trigger appropriate callback events.
        const oldPage = this.state.page;
        const newPage = getCallCompositePage(call, latestEndedCall);
        if (!IsCallEndedPage(oldPage) && IsCallEndedPage(newPage)) {
            this.emitter.emit('callEnded', {
                callId: this.callId
            }); // Reset the callId to undefined as the call has ended.
            this.setCurrentCallId(undefined); // Make sure that the call is set to undefined in the state.
            call = undefined;
        }
        if (this.state.page) {
            this.setState(Object.assign(Object.assign({}, this.state), { userId: clientState.userId, displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName, call, page: newPage, endedCall: latestEndedCall, devices: clientState.deviceManager, latestErrors: clientState.latestErrors }));
        }
    }
}
const findLatestEndedCall = (calls) => {
    var _a, _b, _c, _d;
    const callStates = Object.values(calls);
    if (callStates.length === 0) {
        return undefined;
    }
    let latestCall = callStates[0];
    for (const call of callStates.slice(1)) {
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) > ((_d = (_c = latestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            latestCall = call;
        }
    }
    return latestCall;
};
/**
 * @private
 */
class AzureCommunicationCallAdapter {
    constructor(callClient, locator, callAgent, deviceManager) {
        this.participantSubscribers = new Map();
        this.emitter = new EventEmitter.EventEmitter();
        this.isMyMutedChanged = () => {
            var _a;
            this.emitter.emit('isMutedChanged', {
                participantId: this.getState().userId,
                isMuted: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isMuted
            });
        };
        this.bindPublicMethods();
        this.callClient = callClient;
        this.callAgent = callAgent;
        this.locator = locator;
        this.deviceManager = deviceManager;
        const isTeamsMeeting = ('meetingLink' in this.locator);
        this.context = new CallContext(callClient.getState(), isTeamsMeeting);
        this.context.onCallEnded(endCallData => this.emitter.emit('callEnded', endCallData));
        const onStateChange = (clientState) => {
            var _a;
            // unsubscribe when the instance gets disposed
            if (!this) {
                callClient.offStateChange(onStateChange);
                return;
            } // `updateClientState` searches for the current call from all the calls in the state using a cached `call.id`
            // from the call object. `call.id` can change during a call. We must update the cached `call.id` before
            // calling `updateClientState` so that we find the correct state object for the call even when `call.id`
            // has changed.
            // https://github.com/Azure/communication-ui-library/pull/1820
            if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) {
                this.context.setCurrentCallId(this.call.id);
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createDefaultCallingHandlers(callClient, callAgent, deviceManager, undefined);
        this.onClientStateChange = onStateChange;
        this.subscribeDeviceManagerEvents();
        this.callClient.onStateChange(onStateChange);
    } // TODO: update this to include the 'selectedCameraChanged' when calling adds it to the device manager
    get call() {
        return this._call;
    }
    set call(newCall) {
        this.resetDiagnosticsForwarder(newCall);
        this._call = newCall;
    }
    subscribeDeviceManagerEvents() {
        this.deviceManager.on('selectedMicrophoneChanged', () => {
            this.emitter.emit('selectedMicrophoneChanged');
        });
        this.deviceManager.on('selectedSpeakerChanged', () => {
            this.emitter.emit('selectedSpeakerChanged');
        });
    }
    bindPublicMethods() {
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startCall.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.on.bind(this);
        this.off.bind(this);
        this.processNewCall.bind(this);
    }
    dispose() {
        this.resetDiagnosticsForwarder();
        this.callClient.offStateChange(this.onClientStateChange);
        this.callAgent.dispose();
    }
    queryCameras() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                return this.deviceManager.getCameras();
            }));
        });
    }
    queryMicrophones() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                return this.deviceManager.getMicrophones();
            }));
        });
    }
    querySpeakers() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                return this.deviceManager.isSpeakerSelectionAvailable ? this.deviceManager.getSpeakers() : [];
            }));
        });
    }
    askDevicePermission(constrain) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.deviceManager.askDevicePermission(constrain);
            }));
        });
    }
    joinCall(microphoneOn) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call!');
        }
        return this.teeErrorToEventEmitter(() => {
            const audioOptions = {
                muted: !(microphoneOn !== null && microphoneOn !== void 0 ? microphoneOn : this.getState().isLocalPreviewMicrophoneEnabled)
            }; // TODO: find a way to expose stream to here
            const videoOptions = {
                localVideoStreams: this.localStream ? [this.localStream] : undefined
            };
            const call = this._joinCall(audioOptions, videoOptions);
            this.processNewCall(call);
            return call;
        });
    }
    _joinCall(audioOptions, videoOptions) {
        const isTeamsMeeting = ('meetingLink' in this.locator);
        if (isTeamsMeeting) {
            return this.callAgent.join(this.locator, {
                audioOptions,
                videoOptions
            });
        }
        return this.callAgent.join(this.locator, {
            audioOptions,
            videoOptions
        });
    }
    createStreamView(remoteUserId, options) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                return yield this.handlers.onCreateLocalStreamView(options);
            }
            else {
                return yield this.handlers.onCreateRemoteStreamView(remoteUserId, options);
            }
        });
    }
    disposeStreamView(remoteUserId) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                yield this.handlers.onDisposeLocalStreamView();
            }
            else {
                yield this.handlers.onDisposeRemoteStreamView(remoteUserId);
            }
        });
    }
    leaveCall(forEveryone) {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield this.handlers.onHangUp(forEveryone);
            this.unsubscribeCallEvents();
            this.handlers = createDefaultCallingHandlers(this.callClient, this.callAgent, this.deviceManager, undefined); // We set the adapter.call object to undefined immediately when a call is ended.
            // We do not set the context.callId to undefined because it is a part of the immutable data flow loop.
            this.call = undefined;
            this.stopCamera();
            this.mute();
        });
    }
    setCamera(device, options) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onSelectCamera(device, options);
            }));
        });
    }
    setMicrophone(device) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onSelectMicrophone(device);
            }));
        });
    }
    setSpeaker(device) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                yield this.handlers.onSelectSpeaker(device);
            }));
        });
    }
    startCamera(options) {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                if (!isCameraOn(this.getState())) {
                    yield this.handlers.onToggleCamera(options);
                }
            }));
        });
    }
    stopCamera() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                if (isCameraOn(this.getState())) {
                    yield this.handlers.onToggleCamera();
                }
            }));
        });
    }
    mute() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(false);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && !((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    unmute() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(true);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && ((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    startScreenShare() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                var _a;
                if (!((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn)) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    stopScreenShare() {
        return __awaiter$5(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$5(this, void 0, void 0, function* () {
                var _a;
                if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    startCall(participants, options) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call.');
        }
        const idsToAdd = participants.map(participant => {
            // FIXME: `onStartCall` does not allow a Teams user.
            // Need some way to return an error if a Teams user is provided.
            const backendId = _toCommunicationIdentifier(participant);
            if (communicationCommon.isPhoneNumberIdentifier(backendId)) {
                if ((options === null || options === void 0 ? void 0 : options.alternateCallerId) === undefined) {
                    throw new Error('Unable to start call, PSTN user present with no alternateCallerId.');
                }
                return backendId;
            }
            else if (communicationCommon.isCommunicationUserIdentifier(backendId)) {
                return backendId;
            }
            return backendId;
        });
        const call = this.handlers.onStartCall(idsToAdd, options);
        if (!call) {
            throw new Error('Unable to start call.');
        }
        this.processNewCall(call);
        return this.call;
    }
    processNewCall(call) {
        this.call = call;
        this.context.setCurrentCallId(call.id); // Resync state after callId is set
        this.context.updateClientState(this.callClient.getState());
        this.handlers = createDefaultCallingHandlers(this.callClient, this.callAgent, this.deviceManager, this.call);
        this.subscribeCallEvents();
    }
    removeParticipant(userId) {
        return __awaiter$5(this, void 0, void 0, function* () {
            let participant = userId;
            this.handlers.onRemoveParticipant(participant);
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    subscribeCallEvents() {
        var _a, _b, _c, _d;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.on('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.on('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.on('idChanged', this.callIdChanged.bind(this));
    }
    unsubscribeCallEvents() {
        var _a, _b, _c, _d;
        for (const subscriber of this.participantSubscribers.values()) {
            subscriber.unsubscribeAll();
        }
        this.participantSubscribers.clear();
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.off('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.off('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.off('idChanged', this.callIdChanged.bind(this));
    }
    onRemoteParticipantsUpdated({ added, removed }) {
        if (added && added.length > 0) {
            this.emitter.emit('participantsJoined', added);
        }
        if (removed && removed.length > 0) {
            this.emitter.emit('participantsLeft', removed);
        }
        added.forEach(participant => {
            this.participantSubscribers.set(toFlatCommunicationIdentifier(participant.identifier), new ParticipantSubscriber(participant, this.emitter));
        });
        removed.forEach(participant => {
            const subscriber = this.participantSubscribers.get(toFlatCommunicationIdentifier(participant.identifier));
            subscriber && subscriber.unsubscribeAll();
            this.participantSubscribers.delete(toFlatCommunicationIdentifier(participant.identifier));
        });
    }
    isScreenSharingOnChanged() {
        var _a;
        this.emitter.emit('isLocalScreenSharingActiveChanged', {
            isScreenSharingOn: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn
        });
    }
    callIdChanged() {
        var _a;
        ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) && this.emitter.emit('callIdChanged', {
            callId: this.call.id
        });
    }
    resetDiagnosticsForwarder(newCall) {
        if (this.diagnosticsForwarder) {
            this.diagnosticsForwarder.unsubscribe();
        }
        if (newCall) {
            this.diagnosticsForwarder = new DiagnosticsForwarder(this.emitter, newCall);
        }
    }
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter$5(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isCallError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
    teeErrorToEventEmitter(f) {
        try {
            return f();
        }
        catch (error) {
            if (isCallError(error)) {
                this.emitter.emit('error', error);
            }
            throw error;
        }
    }
}
/**
 * Create a {@link CallAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link CallAdapter} provided by this library.
 *
 * Note: `displayName` can be a maximum of 256 characters.
 *
 * @public
 */
const createAzureCommunicationCallAdapter = ({ userId, displayName, credential, locator }) => __awaiter$5(void 0, void 0, void 0, function* () {
    const callClient = createStatefulCallClient({
        userId
    });
    const callAgent = yield callClient.createCallAgent(credential, {
        displayName
    });
    const adapter = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, locator);
    return adapter;
});
/**
 * A custom React hook to simplify the creation of {@link CallAdapter}.
 *
 * Similar to {@link createAzureCommunicationCallAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
const useAzureCommunicationCallAdapter = (args, afterCreate, beforeDispose) => {
    const { credential, displayName, locator, userId } = args; // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = React.useState(undefined); // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = React.useRef(undefined);
    const afterCreateRef = React.useRef(undefined);
    const beforeDisposeRef = React.useRef(undefined); // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    React.useEffect(() => {
        if (!credential || !displayName || !locator || !userId) {
            return;
        }
        (() => __awaiter$5(void 0, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = yield createAzureCommunicationCallAdapter({
                credential,
                displayName,
                locator,
                userId
            });
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            setAdapter(newAdapter);
        }))();
    }, // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, locator, userId]); // Dispose any existing adapter when the component unmounts.
    React.useEffect(() => {
        return () => {
            (() => __awaiter$5(void 0, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
};
/**
 * Create a {@link CallAdapter} using the provided {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallAdapter} for a simpler API.
 *
 * @public
 */
const createAzureCommunicationCallAdapterFromClient = (callClient, callAgent, locator) => __awaiter$5(void 0, void 0, void 0, function* () {
    const deviceManager = yield callClient.getDeviceManager();
    return new AzureCommunicationCallAdapter(callClient, locator, callAgent, deviceManager);
});
const isCallError = (e) => {
    return e['target'] !== undefined && e['innerError'] !== undefined;
};

// Copyright (c) Microsoft Corporation.
const icon$1 = () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: 'ControlBarPeopleButton' });
/**
 * @private
 */
const PeopleButton = (props) => {
    const { strings, onRenderOnIcon, onRenderOffIcon, onClick } = props;
    const theme = useTheme();
    const styles = React.useMemo(() => {
        var _a;
        return react.concatStyleSets({
            rootChecked: {
                background: theme.palette.neutralLight
            }
        }, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    }, [props.styles, theme.palette.neutralLight]);
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { strings: strings, labelKey: 'peopleButtonLabelKey', onRenderOnIcon: onRenderOnIcon !== null && onRenderOnIcon !== void 0 ? onRenderOnIcon : icon$1, onRenderOffIcon: onRenderOffIcon !== null && onRenderOffIcon !== void 0 ? onRenderOffIcon : icon$1, onClick: onClick, styles: styles }));
};

// Copyright (c) Microsoft Corporation.
/**
 * The hook to bypass limitation of conditional build for CallWithChatComposite
 * Remove this and use useLocale() instead when merge CallWithChatComposite from beta
 *
 * @private
 */
const useCallWithChatCompositeStrings = () => {
    const locale = useLocale(); // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return locale.strings.callWithChat;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatButton = (props) => {
    const strings = Object.assign({ label: props.label }, props.strings);
    const theme = useTheme();
    const styles = React.useMemo(() => {
        var _a;
        return react.concatStyleSets({
            rootChecked: {
                background: theme.palette.neutralLight
            }
        }, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    }, [props.styles, theme.palette.neutralLight]);
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { labelKey: 'chatButtonLabelKey', strings: strings, onClick: props.onClick, styles: styles }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const NotificationIcon = (props) => {
    const { chatMessagesCount, label } = props;
    const theme = react.useTheme();
    const renderNumber = (numberOfMessages) => {
        if (numberOfMessages < 1) {
            return React__default['default'].createElement(React__default['default'].Fragment, null);
        }
        else {
            const textNumberOfMessages = numberOfMessages < 9 ? numberOfMessages : '9+';
            return React__default['default'].createElement(react.Text, { role: 'status', "aria-label": textNumberOfMessages + label, styles: notificationTextStyles(theme) }, textNumberOfMessages);
        }
    };
    return React__default['default'].createElement(react.Stack, { "data-ui-id": "call-with-chat-composite-chat-button-unread-icon", horizontalAlign: "center", verticalAlign: "center", styles: notificationIconContainerStyles(theme) },
        React__default['default'].createElement(react.Stack, null, renderNumber(chatMessagesCount)));
};
const notificationIconPaddingREM = 0.225;
const notificationSizeREM = 1;
const notificationIconContainerStyles = react.memoizeFunction((theme) => ({
    root: {
        borderRadius: `${notificationSizeREM}rem`,
        // Create a css circle. This should match the height.
        height: `${notificationSizeREM}rem`,
        minWidth: `${notificationSizeREM}rem`,
        // use min-width over width as we want to extend the width of the notification icon when contents is more than one character (e.g. 9+)
        background: theme.palette.themePrimary,
        border: `0.0625rem solid white`,
        // border should always be white
        padding: `${notificationIconPaddingREM}rem`,
        // positioning to place the badge within the button appropriately.
        position: 'absolute',
        top: `-${0.5 - notificationIconPaddingREM / 2}rem`,
        left: `${0.5 + notificationIconPaddingREM / 2}rem`
    }
}));
const notificationTextStyles = react.memoizeFunction((theme) => ({
    root: {
        color: 'white',
        fontSize: theme.fonts.xSmall.fontSize
    }
}));

/**
 * Helper function to determine if the message in the event is a valid one from a user.
 * Display name is used since system messages will not have one.
 */
const validNewChatMessage = (message) => !!message.senderDisplayName && (message.type === 'text' || message.type === 'html');
const filledIcon = React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: 'ControlBarChatButtonActive' });
const regularIcon = React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: 'ControlBarChatButtonInactive' });
/**
 * @private
 */
const ChatButtonWithUnreadMessagesBadge = (props) => {
    var _a, _b, _c, _d;
    const { chatAdapter, isChatPaneVisible, newMessageLabel } = props;
    const [unreadChatMessagesCount, setUnreadChatMessagesCount] = React.useState(0);
    const baseIcon = props.showLabel ? regularIcon : filledIcon;
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const numberOfMsgToolTip = ((_a = props.strings) === null || _a === void 0 ? void 0 : _a.tooltipOffContent) && unreadChatMessagesCount > 0 ? _formatString(callWithChatStrings.chatButtonTooltipClosedWithMessageCount, {
        unreadMessagesCount: `${unreadChatMessagesCount}`
    }) : undefined;
    const chatStrings = React.useMemo(() => {
        var _a, _b, _c;
        return ({
            label: (_a = props.strings) === null || _a === void 0 ? void 0 : _a.label,
            tooltipOffContent: numberOfMsgToolTip ? numberOfMsgToolTip : (_b = props.strings) === null || _b === void 0 ? void 0 : _b.tooltipOffContent,
            tooltipOnContent: (_c = props.strings) === null || _c === void 0 ? void 0 : _c.tooltipOnContent
        });
    }, [numberOfMsgToolTip, (_b = props.strings) === null || _b === void 0 ? void 0 : _b.label, (_c = props.strings) === null || _c === void 0 ? void 0 : _c.tooltipOffContent, (_d = props.strings) === null || _d === void 0 ? void 0 : _d.tooltipOnContent]);
    const onRenderOnIcon = React.useCallback(() => baseIcon, [baseIcon]);
    const notificationOnIcon = React.useCallback(() => {
        return React__default['default'].createElement(react.Stack, { styles: chatNotificationContainerStyles },
            unreadChatMessagesCount > 0 && React__default['default'].createElement(NotificationIcon, { chatMessagesCount: unreadChatMessagesCount, label: newMessageLabel }),
            baseIcon);
    }, [unreadChatMessagesCount, newMessageLabel, baseIcon]);
    React.useEffect(() => {
        if (isChatPaneVisible) {
            setUnreadChatMessagesCount(0);
            return;
        }
        const incrementUnreadChatMessagesCount = (event) => {
            if (!isChatPaneVisible && validNewChatMessage(event.message)) {
                setUnreadChatMessagesCount(unreadChatMessagesCount + 1);
            }
        };
        chatAdapter.on('messageReceived', incrementUnreadChatMessagesCount);
        return () => {
            chatAdapter.off('messageReceived', incrementUnreadChatMessagesCount);
        };
    }, [chatAdapter, setUnreadChatMessagesCount, isChatPaneVisible, unreadChatMessagesCount]);
    return React__default['default'].createElement(ChatButton, Object.assign({}, props, { "data-ui-id": "call-with-chat-composite-chat-button", onRenderOffIcon: notificationOnIcon, onRenderOnIcon: onRenderOnIcon, strings: chatStrings }));
};
const chatNotificationContainerStyles = {
    root: {
        display: 'inline',
        position: 'relative'
    }
};

// Copyright (c) Microsoft Corporation.
const icon = () => React__default['default'].createElement(reactIcons.MoreHorizontal20Filled, { key: 'chatOnIconKey', primaryFill: "currentColor" });
/**
 * @private
 */
const MoreButton = (props) => {
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { labelKey: 'optionsButtonLabelKey', showLabel: props.showLabel, onRenderOnIcon: icon, onRenderOffIcon: icon, onClick: props.onClick, "data-ui-id": 'call-with-chat-composite-more-button' }));
};

// Copyright (c) Microsoft Corporation.
const inferCallWithChatControlOptions$1 = (mobileView, callWithChatControls) => {
    if (callWithChatControls === false) {
        return false;
    }
    const options = callWithChatControls === true || callWithChatControls === undefined ? {} : callWithChatControls;
    if (mobileView) {
        // Set to compressed mode when composite is optimized for mobile
        options.displayType = 'compact'; // Do not show screen share button when composite is optimized for mobile unless the developer
        // has explicitly opted in.
        if (options.screenShareButton !== true) {
            options.screenShareButton = false;
        }
    }
    return options;
};
/**
 * @private
 */
const CallWithChatControlBar = (props) => {
    const theme = react.useTheme();
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const options = inferCallWithChatControlOptions$1(props.mobileView, props.callControls);
    const chatButtonStrings = React.useMemo(() => ({
        label: callWithChatStrings.chatButtonLabel,
        tooltipOffContent: callWithChatStrings.chatButtonTooltipOpen,
        tooltipOnContent: callWithChatStrings.chatButtonTooltipClose
    }), [callWithChatStrings]);
    const peopleButtonStrings = React.useMemo(() => ({
        label: callWithChatStrings.peopleButtonLabel,
        tooltipOffContent: callWithChatStrings.peopleButtonTooltipOpen,
        tooltipOnContent: callWithChatStrings.peopleButtonTooltipClose
    }), [callWithChatStrings]);
    const moreButtonStrings = React.useMemo(() => ({
        label: callWithChatStrings.moreDrawerButtonLabel,
        tooltipContent: callWithChatStrings.moreDrawerButtonTooltip
    }), [callWithChatStrings]);
    const centerContainerStyles = React.useMemo(() => {
        const styles = !props.mobileView ? desktopControlBarStyles : {};
        return react.mergeStyleSets(styles, {
            root: {
                // Enforce a background color on control bar to ensure it matches the composite background color.
                background: theme.semanticColors.bodyBackground
            }
        });
    }, [props.mobileView, theme.semanticColors.bodyBackground]);
    const screenShareButtonStyles = React.useMemo(() => !props.mobileView ? getDesktopScreenShareButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const commonButtonStyles = React.useMemo(() => !props.mobileView ? getDesktopCommonButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const endCallButtonStyles = React.useMemo(() => !props.mobileView ? getDesktopEndCallButtonStyles(theme) : undefined, [props.mobileView, theme]);
    // when options is false then we want to hide the whole control bar.
    if (options === false) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    const chatButton = React__default['default'].createElement(ChatButtonWithUnreadMessagesBadge, { chatAdapter: props.chatAdapter, checked: props.chatButtonChecked, showLabel: options.displayType !== 'compact', isChatPaneVisible: props.chatButtonChecked, onClick: props.onChatButtonClicked, disabled: props.disableButtonsForLobbyPage || isDisabled$2(options.chatButton), strings: chatButtonStrings, styles: commonButtonStyles, newMessageLabel: callWithChatStrings.chatButtonNewMessageNotificationLabel });
    return React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(callControlsContainerStyles, controlBarContainerStyles$1) },
        React__default['default'].createElement(react.Stack.Item, { grow: true },
            React__default['default'].createElement(CallAdapterProvider, { adapter: props.callAdapter },
                React__default['default'].createElement(react.Stack, { horizontalAlign: "center" },
                    React__default['default'].createElement(react.Stack.Item, null,
                        React__default['default'].createElement(ControlBar, { layout: "horizontal", styles: centerContainerStyles },
                            isEnabled$1(options.microphoneButton) && React__default['default'].createElement(Microphone, { displayType: options.displayType, styles: commonButtonStyles, splitButtonsForDeviceSelection: !props.mobileView }),
                            isEnabled$1(options.cameraButton) && React__default['default'].createElement(Camera, { displayType: options.displayType, styles: commonButtonStyles, splitButtonsForDeviceSelection: !props.mobileView }),
                            props.mobileView && isEnabled$1(options === null || options === void 0 ? void 0 : options.chatButton) && chatButton,
                            isEnabled$1(options.screenShareButton) && React__default['default'].createElement(ScreenShare, { option: options.screenShareButton, displayType: options.displayType, styles: screenShareButtonStyles }),
                            props.mobileView && React__default['default'].createElement(MoreButton, { "data-ui-id": "call-with-chat-composite-more-button", strings: moreButtonStrings, onClick: props.onMoreButtonClicked, disabled: props.disableButtonsForLobbyPage }),
                            React__default['default'].createElement(EndCall, { displayType: "compact", styles: endCallButtonStyles })))))),
        !props.mobileView && React__default['default'].createElement(react.Stack, { horizontal: true, className: !props.mobileView ? react.mergeStyles(desktopButtonContainerStyle) : undefined },
            isEnabled$1(options === null || options === void 0 ? void 0 : options.peopleButton) && React__default['default'].createElement(PeopleButton, { checked: props.peopleButtonChecked, showLabel: options.displayType !== 'compact', onClick: props.onPeopleButtonClicked, "data-ui-id": "call-with-chat-composite-people-button", disabled: props.disableButtonsForLobbyPage || isDisabled$2(options.peopleButton), strings: peopleButtonStrings, styles: commonButtonStyles }),
            isEnabled$1(options === null || options === void 0 ? void 0 : options.chatButton) && chatButton));
};
const desktopButtonContainerStyle = {
    padding: '0.75rem',
    columnGap: '0.5rem'
};
const desktopControlBarStyles = {
    root: desktopButtonContainerStyle
};
const getDesktopCommonButtonStyles = (theme) => ({
    root: {
        border: `solid 1px ${theme.palette.neutralQuaternaryAlt}`,
        borderRadius: theme.effects.roundedCorner4,
        minHeight: '2.5rem',
        maxWidth: '12rem' // allot extra space than the regular ControlBarButton. This is to give extra room to have the icon beside the text.
    },
    flexContainer: {
        display: 'flex',
        flexFlow: 'row nowrap'
    },
    textContainer: {
        // Override the default so that label doesn't introduce a new block.
        display: 'inline',
        // Ensure width is set to permit child to show ellipsis when there is a label that is too long
        maxWidth: '100%'
    },
    label: {
        fontSize: theme.fonts.medium.fontSize,
        // Ensure there is enough space between the icon and text to allow for the unread messages badge in the chat button
        marginLeft: '0.625rem',
        // Ensure letters that go above and below the standard text line like 'g', 'y', 'j' are not clipped
        lineHeight: '1.5rem',
        // Do not allow very long button texts to ruin the control bar experience, instead ensure long text is truncated and shows ellipsis
        display: 'block',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        overflow: 'hidden'
    },
    splitButtonMenuButton: {
        border: `solid 1px ${theme.palette.neutralQuaternaryAlt}`,
        borderTopRightRadius: theme.effects.roundedCorner4,
        borderBottomRightRadius: theme.effects.roundedCorner4,
        borderTopLeftRadius: '0',
        borderBottomLeftRadius: '0'
    },
    splitButtonMenuButtonChecked: {
        // Default colors the menu half similarly for :hover and when button is checked.
        // To align with how the left-half is styled, override the checked style.
        background: 'none'
    }
});
const getDesktopScreenShareButtonStyles = (theme) => {
    const overrideStyles = {
        border: 'none',
        background: theme.palette.themePrimary,
        color: theme.palette.white,
        '* > svg': {
            fill: theme.palette.white
        }
    };
    const overrides = {
        rootChecked: overrideStyles,
        rootCheckedHovered: overrideStyles
    };
    return react.concatStyleSets(getDesktopCommonButtonStyles(theme), overrides);
};
const getDesktopEndCallButtonStyles = (theme) => {
    const overrides = {
        root: {
            // Suppress border around the dark-red button.
            border: 'none'
        }
    };
    return react.concatStyleSets(getDesktopCommonButtonStyles(theme), overrides);
};
const isEnabled$1 = (option) => option !== false;

/**
 * @private
 */
const compositeOuterContainerStyles = {
    root: {
        width: '100%',
        // Create a new stacking context so that DrawerMenu can be positioned absolutely.
        position: 'relative'
    }
};
/** @private */
const callCompositeContainerStyles = {
    root: {
        // Start a new stacking context so that any `position:absolute` elements
        // inside the call composite do not compete with its siblings.
        position: 'relative'
    }
};
/** @private */
const controlBarContainerStyles = {
    root: {
        // Start a new stacking context so that any `position:absolute` elements
        // inside the control bar do not compete with its siblings.
        position: 'relative'
    }
};
/** @private */
const drawerContainerStyles = {
    root: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        // Any zIndex > 0 will work because this is the only absolutely
        // positioned element in the container.
        zIndex: 1
    }
};

var __awaiter$4 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/**
 * Facade around the CallWithChatAdapter to satisfy the call adapter interface.
 *
 * @private
 */
class CallWithChatBackedCallAdapter {
    constructor(callWithChatAdapter) {
        // In order to unsubscribe the handler when offStateChange is called we must have a mapping of the original handler to the newly created handler.
        this.eventStore = new Map();
        this.on = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.on('callError', listener);
                case 'participantsJoined':
                    return this.callWithChatAdapter.on('callParticipantsJoined', listener);
                case 'participantsLeft':
                    return this.callWithChatAdapter.on('callParticipantsLeft', listener);
                default:
                    return this.callWithChatAdapter.on(event, listener);
            }
        };
        this.off = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.off('callError', listener);
                case 'participantsJoined':
                    return this.callWithChatAdapter.off('callParticipantsJoined', listener);
                case 'participantsLeft':
                    return this.callWithChatAdapter.off('callParticipantsLeft', listener);
                default:
                    return this.callWithChatAdapter.off(event, listener);
            }
        };
        this.onStateChange = (handler) => {
            const convertedHandler = (state) => {
                handler(callAdapterStateFromCallWithChatAdapterState(state));
            };
            this.callWithChatAdapter.onStateChange(convertedHandler);
            this.eventStore.set(handler, convertedHandler);
        };
        this.offStateChange = (handler) => {
            const convertedHandler = this.eventStore.get(handler);
            convertedHandler && this.callWithChatAdapter.offStateChange(convertedHandler);
        };
        this.getState = () => callAdapterStateFromCallWithChatAdapterState(this.callWithChatAdapter.getState());
        this.dispose = () => this.callWithChatAdapter.dispose();
        this.joinCall = (microphoneOn) => {
            return this.callWithChatAdapter.joinCall(microphoneOn);
        };
        this.leaveCall = (forEveryone) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.leaveCall(forEveryone); });
        this.startCall = (participants, options) => {
            let communicationParticipants = participants;
            return this.callWithChatAdapter.startCall(communicationParticipants, options);
        };
        this.setCamera = (sourceId, options) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.setCamera(sourceId, options); });
        this.setMicrophone = (sourceId) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.setMicrophone(sourceId); });
        this.setSpeaker = (sourceId) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.setSpeaker(sourceId); });
        this.askDevicePermission = (constraints) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.askDevicePermission(constraints); });
        this.queryCameras = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.queryCameras(); });
        this.queryMicrophones = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.queryMicrophones(); });
        this.querySpeakers = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.querySpeakers(); });
        this.startCamera = (options) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.startCamera(options); });
        this.stopCamera = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.stopCamera(); });
        this.mute = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.mute(); });
        this.unmute = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.unmute(); });
        this.startScreenShare = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.startScreenShare(); });
        this.stopScreenShare = () => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.stopScreenShare(); });
        this.removeParticipant = (userId) => __awaiter$4(this, void 0, void 0, function* () {
            let participant = userId;
            yield this.callWithChatAdapter.removeParticipant(participant);
        });
        this.createStreamView = (remoteUserId, options) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.createStreamView(remoteUserId, options); });
        this.disposeStreamView = (remoteUserId, options) => __awaiter$4(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.disposeStreamView(remoteUserId, options); });
        this.callWithChatAdapter = callWithChatAdapter;
    }
}
function callAdapterStateFromCallWithChatAdapterState(callWithChatAdapterState) {
    return {
        isLocalPreviewMicrophoneEnabled: callWithChatAdapterState.isLocalPreviewMicrophoneEnabled,
        page: callWithChatAdapterState.page,
        userId: callWithChatAdapterState.userId,
        displayName: callWithChatAdapterState.displayName,
        call: callWithChatAdapterState.call,
        devices: callWithChatAdapterState.devices,
        isTeamsCall: callWithChatAdapterState.isTeamsCall,
        latestErrors: callWithChatAdapterState.latestCallErrors
    };
}

var __awaiter$3 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Facade around the CallWithChatAdapter to satisfy the chat adapter interface.
 *
 * @private
 */
class CallWithChatBackedChatAdapter {
    constructor(callWithChatAdapter) {
        // In order to unsubscribe the handler when offStateChange is called we must have a mapping of the original handler to the newly created handler.
        this.eventStore = new Map();
        this.fetchInitialData = () => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.fetchInitialData(); });
        this.sendMessage = (content) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.sendMessage(content); });
        this.sendReadReceipt = (chatMessageId) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.sendReadReceipt(chatMessageId); });
        this.sendTypingIndicator = () => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.sendTypingIndicator(); });
        this.removeParticipant = (userId) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.removeParticipant(userId); });
        this.loadPreviousChatMessages = (messagesToLoad) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.loadPreviousChatMessages(messagesToLoad); });
        this.dispose = () => this.callWithChatAdapter.dispose();
        this.onStateChange = (handler) => {
            const convertedHandler = (state) => {
                handler(chatAdapterStateFromCallWithChatAdapterState(state));
            };
            this.callWithChatAdapter.onStateChange(convertedHandler);
            this.eventStore.set(handler, convertedHandler);
        };
        this.offStateChange = (handler) => {
            const convertedHandler = this.eventStore.get(handler);
            convertedHandler && this.callWithChatAdapter.offStateChange(convertedHandler);
        };
        this.getState = () => chatAdapterStateFromCallWithChatAdapterState(this.callWithChatAdapter.getState());
        /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
        this.on = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.on('chatError', listener);
                case 'participantsAdded':
                    return this.callWithChatAdapter.on('chatParticipantsAdded', listener);
                case 'participantsRemoved':
                    return this.callWithChatAdapter.on('chatParticipantsRemoved', listener);
                default:
                    return this.callWithChatAdapter.on(event, listener);
            }
        };
        this.off = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.off('chatError', listener);
                case 'participantsAdded':
                    return this.callWithChatAdapter.off('chatParticipantsAdded', listener);
                case 'participantsRemoved':
                    return this.callWithChatAdapter.off('chatParticipantsRemoved', listener);
                default:
                    return this.callWithChatAdapter.off(event, listener);
            }
        };
        this.updateMessage = (messageId, content, metadata) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.updateMessage(messageId, content, metadata); });
        this.deleteMessage = (messageId) => __awaiter$3(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.deleteMessage(messageId); });
        this.clearErrors = (errorTypes) => {
            throw new Error(`Method not supported in CallWithChatComposite.`);
        };
        this.setTopic = (topicName) => __awaiter$3(this, void 0, void 0, function* () {
            throw new Error(`Chat Topics are not supported in CallWithChatComposite.`);
        });
        this.callWithChatAdapter = callWithChatAdapter;
    }
}
function chatAdapterStateFromCallWithChatAdapterState(callWithChatAdapterState) {
    if (!callWithChatAdapterState.chat) {
        throw new Error('Chat thread state id undefined.');
    }
    return {
        userId: callWithChatAdapterState.userId,
        displayName: callWithChatAdapterState.displayName || '',
        thread: callWithChatAdapterState.chat,
        latestErrors: callWithChatAdapterState.latestChatErrors
    };
}

// Copyright (c) Microsoft Corporation.
const inferCallWithChatControlOptions = (callWithChatControls) => {
    if (callWithChatControls === false) {
        return false;
    }
    const options = callWithChatControls === true || callWithChatControls === undefined ? {} : callWithChatControls;
    return options;
};
/** @private */
const MoreDrawer = (props) => {
    var _a, _b;
    const drawerMenuItems = [];
    const { speakers, onSelectSpeaker, onLightDismiss } = props;
    const onSpeakerItemClick = React.useCallback((_ev, itemKey) => {
        const selected = speakers === null || speakers === void 0 ? void 0 : speakers.find(speaker => speaker.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectSpeaker(selected);
        }
        onLightDismiss();
    }, [speakers, onSelectSpeaker, onLightDismiss]);
    const drawerSelectionOptions = inferCallWithChatControlOptions(props.callControls);
    if (props.speakers && props.speakers.length > 0) {
        drawerMenuItems.push({
            itemKey: 'speakers',
            disabled: props.disableButtonsForHoldScreen,
            text: props.strings.speakerMenuTitle,
            iconProps: {
                iconName: 'MoreDrawerSpeakers'
            },
            subMenuProps: props.speakers.map(speaker => ({
                itemKey: speaker.id,
                iconProps: {
                    iconName: isDeviceSelected(speaker, props.selectedSpeaker) ? 'MoreDrawerSelectedSpeaker' : 'MoreDrawerSpeakers'
                },
                text: speaker.name,
                onItemClick: onSpeakerItemClick,
                secondaryIconProps: isDeviceSelected(speaker, props.selectedSpeaker) ? {
                    iconName: 'Accept'
                } : undefined
            })),
            secondaryText: (_a = props.selectedSpeaker) === null || _a === void 0 ? void 0 : _a.name
        });
    }
    const { microphones, onSelectMicrophone } = props;
    const onMicrophoneItemClick = React.useCallback((_ev, itemKey) => {
        const selected = microphones === null || microphones === void 0 ? void 0 : microphones.find(mic => mic.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectMicrophone(selected);
        }
        onLightDismiss();
    }, [microphones, onSelectMicrophone, onLightDismiss]);
    if (props.microphones && props.microphones.length > 0) {
        // Set props as Microphone if speakers can be enumerated else set as Audio Device
        const speakersAvailable = props.speakers && props.speakers.length > 0;
        const itemKey = speakersAvailable ? 'microphones' : 'audioDevices';
        const text = speakersAvailable ? props.strings.microphoneMenuTitle : props.strings.audioDeviceMenuTitle;
        const iconName = speakersAvailable ? 'MoreDrawerMicrophones' : 'MoreDrawerSpeakers';
        const selectedIconName = speakersAvailable ? 'MoreDrawerSelectedMicrophone' : 'MoreDrawerSelectedSpeaker';
        drawerMenuItems.push({
            itemKey: itemKey,
            disabled: props.disableButtonsForHoldScreen,
            text: text,
            iconProps: {
                iconName: iconName
            },
            subMenuProps: props.microphones.map(mic => ({
                itemKey: mic.id,
                iconProps: {
                    iconName: isDeviceSelected(mic, props.selectedMicrophone) ? selectedIconName : iconName
                },
                text: mic.name,
                onItemClick: onMicrophoneItemClick,
                secondaryIconProps: isDeviceSelected(mic, props.selectedMicrophone) ? {
                    iconName: 'Accept'
                } : undefined,
                disabled: drawerSelectionOptions !== false ? isDisabled$2(drawerSelectionOptions.microphoneButton) : undefined
            })),
            secondaryText: (_b = props.selectedMicrophone) === null || _b === void 0 ? void 0 : _b.name
        });
    }
    if (drawerSelectionOptions !== false && isEnabled(drawerSelectionOptions === null || drawerSelectionOptions === void 0 ? void 0 : drawerSelectionOptions.peopleButton)) {
        drawerMenuItems.push({
            itemKey: 'people',
            text: props.strings.peopleButtonLabel,
            iconProps: {
                iconName: 'MoreDrawerPeople'
            },
            onItemClick: props.onPeopleButtonClicked,
            disabled: drawerSelectionOptions !== false ? isDisabled$2(drawerSelectionOptions.peopleButton) : undefined
        });
    }
    return React__default['default'].createElement(_DrawerMenu, { items: drawerMenuItems, onLightDismiss: props.onLightDismiss });
};
const isDeviceSelected = (speaker, selectedSpeaker) => !!selectedSpeaker && speaker.id === selectedSpeaker.id;
const isEnabled = (option) => option !== false;

/**
 * @private
 */
const moreDrawerSelector = reselect__namespace.createSelector([getDeviceManager], deviceManager => {
    return {
        microphones: deviceManager.microphones,
        speakers: deviceManager.speakers,
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker
    };
});

// Copyright (c) Microsoft Corporation.
/** @private */
const PreparedMoreDrawer = (props) => {
    const strings = useCallWithChatCompositeStrings();
    const moreDrawerStrings = React.useMemo(() => ({
        peopleButtonLabel: strings.peopleButtonLabel,
        audioDeviceMenuTitle: strings.moreDrawerAudioDeviceMenuTitle,
        microphoneMenuTitle: strings.moreDrawerMicrophoneMenuTitle,
        speakerMenuTitle: strings.moreDrawerSpeakerMenuTitle
    }), [strings]);
    const deviceProps = useSelector$1(moreDrawerSelector);
    const callHandlers = useHandlers();
    return React__default['default'].createElement(MoreDrawer, Object.assign({}, props, deviceProps, callHandlers, { strings: moreDrawerStrings }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const SidePaneHeader = (props) => {
    const theme = useTheme();
    const sidePaneCloseButtonStyles = React.useMemo(() => ({
        root: {
            minWidth: '1.5rem',
            padding: 0,
            backgroundColor: theme.semanticColors.bodyBackground
        },
        icon: {
            color: theme.palette.neutralSecondary
        },
        iconHovered: {
            color: theme.palette.neutralSecondary
        },
        iconPressed: {
            color: theme.palette.neutralSecondary
        }
    }), [theme.palette.neutralSecondary, theme.semanticColors.bodyBackground]);
    return React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "space-between", styles: sidePaneHeaderContainerStyles },
        React__default['default'].createElement(react.Stack.Item, { styles: sidePaneHeaderStyles }, props.headingText),
        React__default['default'].createElement(react.CommandBarButton, { ariaLabel: props.strings.dismissSidePaneButtonLabel, styles: sidePaneCloseButtonStyles, iconProps: {
                iconName: 'cancel'
            }, onClick: props.onClose }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const LocalAndRemotePIP = (props) => {
    var _a, _b;
    const { localParticipant, dominantRemoteParticipant, onCreateLocalStreamView, onDisposeLocalStreamView, onCreateRemoteStreamView, onDisposeRemoteStreamView } = props;
    const localVideoTileProps = React.useMemo(() => {
        var _a, _b;
        return ({
            onCreateLocalStreamView,
            onDisposeLocalStreamView,
            localVideoViewOptions,
            displayName: localParticipant.displayName,
            showLabel: false,
            showMuteIndicator: false,
            showCameraSwitcherInLocalPreview: false,
            isAvailable: (_a = localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable,
            renderElement: (_b = localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement
        });
    }, [localParticipant.displayName, (_a = localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable, (_b = localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement, onCreateLocalStreamView, onDisposeLocalStreamView]);
    const remoteVideoTileProps = React.useMemo(() => {
        var _a, _b, _c;
        return !dominantRemoteParticipant ? undefined : {
            onCreateRemoteStreamView,
            onDisposeRemoteStreamView,
            remoteVideoViewOptions,
            displayName: dominantRemoteParticipant === null || dominantRemoteParticipant === void 0 ? void 0 : dominantRemoteParticipant.displayName,
            showLabel: false,
            showMuteIndicator: false,
            isAvailable: (_a = dominantRemoteParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable,
            isReceiving: (_b = dominantRemoteParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.isReceiving,
            renderElement: (_c = dominantRemoteParticipant.videoStream) === null || _c === void 0 ? void 0 : _c.renderElement,
            userId: dominantRemoteParticipant.userId,
            key: dominantRemoteParticipant.userId
        };
    }, [dominantRemoteParticipant, onCreateRemoteStreamView, onDisposeRemoteStreamView]);
    const locale = useLocale();
    const ariaLabel = locale.strings.callWithChat.pictureInPictureTileAriaLabel;
    const strings = React.useMemo(() => ({
        rootAriaLabel: ariaLabel
    }), [ariaLabel]); // If there are no remote participants, show the local participant as the primary tile
    const primaryTileProps = React.useMemo(() => ({
        children: remoteVideoTileProps ? React__default['default'].createElement(_RemoteVideoTile, Object.assign({}, remoteVideoTileProps)) : React__default['default'].createElement(_LocalVideoTile, Object.assign({}, localVideoTileProps)),
        // TODO: when the calling SDK provides height/width stream information - update this to reflect the stream orientation.
        orientation: 'portrait'
    }), [localVideoTileProps, remoteVideoTileProps]); // If we are showing the local participant as the primary tile, show nothing for the secondary tile
    const secondaryTileProps = React.useMemo(() => remoteVideoTileProps ? {
        children: React__default['default'].createElement(_LocalVideoTile, Object.assign({}, localVideoTileProps, { personaMinSize: 20 })),
        // TODO: when the calling SDK provides height/width stream information - update this to reflect the stream orientation.
        orientation: 'portrait'
    } : undefined, [localVideoTileProps, remoteVideoTileProps]);
    return React__default['default'].createElement(_PictureInPictureInPicture, { onClick: props.onClick, strings: strings, primaryTile: primaryTileProps, secondaryTile: secondaryTileProps });
};
const localVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: true
};
const remoteVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: false
};

// Copyright (c) Microsoft Corporation.
/**
 * Get the most dominant remote participant, if no dominant speaker IDs exist, this uses
 * one of the remote participants with no bias towards which one.
 *
 * @private
 */
const dominantRemoteParticipantSelector = reselect__namespace.createSelector([getRemoteParticipants, getDominantSpeakerInfo], (remoteParticipants, dominantSpeakerInfo) => {
    const dominantSpeakers = _dominantSpeakersWithFlatId(dominantSpeakerInfo);
    const dominantRemoteParticipant = remoteParticipants && Object.keys(remoteParticipants).length > 0 ? findDominantRemoteParticipant(remoteParticipants, dominantSpeakers !== null && dominantSpeakers !== void 0 ? dominantSpeakers : []) : undefined;
    return dominantRemoteParticipant ? _videoGalleryRemoteParticipantsMemo(updateUserDisplayNamesTrampoline(Object.values(dominantRemoteParticipant)))[0] : undefined;
});
const findDominantRemoteParticipant = (remoteParticipants, dominantSpeakerIds) => {
    let dominantRemoteParticipantId = dominantSpeakerIds[0]; // Fallback to using the first remote participant if there are no dominant speaker IDs
    // or if the dominant speaker is no longer available in the list of remoteParticipantIds
    const remoteParticipantIds = Object.keys(remoteParticipants);
    if (!dominantRemoteParticipantId || !remoteParticipantIds.includes(dominantRemoteParticipantId)) {
        dominantRemoteParticipantId = remoteParticipantIds[0];
    }
    return {
        dominantRemoteParticipantId: remoteParticipants[dominantRemoteParticipantId]
    };
};
const updateUserDisplayNamesTrampoline = (remoteParticipants) => {
    return remoteParticipants;
};

/**
 * Picture in picture in picture needs to display the most-dominant remote speaker, as well as the local participant video.
 * @private
 */
const localAndRemotePIPSelector = reselect__namespace.createSelector([getDisplayName, dominantRemoteParticipantSelector, localVideoSelector], (displayName, dominantRemoteParticipant, localVideoStreamInfo) => {
    return {
        localParticipant: {
            displayName,
            videoStream: localVideoStreamInfo
        },
        dominantRemoteParticipant
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * Default Modal PIP related pixel measurements used for ModalLocalAndremotePIP and common/utils.
 *
 * @private
 */
const MODAL_PIP_DEFAULT_PX = {
    rightPositionPx: 16,
    topPositionPx: 52,
    widthPx: 88,
    heightPx: 128
};
/**
 * @private
 */
const getPipStyles = (theme) => ({
    modal: {
        main: Object.assign(Object.assign({ borderRadius: theme.effects.roundedCorner4, boxShadow: theme.effects.elevation8, 
            // Above the message thread / people pane.
            zIndex: 2 }, (theme.rtl ? {
            left: _pxToRem(MODAL_PIP_DEFAULT_PX.rightPositionPx)
        } : {
            right: _pxToRem(MODAL_PIP_DEFAULT_PX.rightPositionPx)
        })), { top: _pxToRem(MODAL_PIP_DEFAULT_PX.topPositionPx) })
    }
});
/**
 * @private
 */
const PIPContainerStyle = {
    root: {
        position: 'absolute',
        width: '100%',
        height: '100%',
        pointerEvents: 'none'
    }
};
/**
 * @private
 */
const hiddenStyle = react.concatStyleSets(PIPContainerStyle, {
    root: {
        display: 'none'
    }
});
/**
 * @private
 */
const modalStyle = {
    main: {
        minWidth: 'min-content',
        minHeight: 'min-content',
        position: 'absolute',
        overflow: 'hidden',
        // pointer events for root Modal div set to auto to make LocalAndRemotePIP interactive
        pointerEvents: 'auto',
        touchAction: 'none'
    },
    root: {
        width: '100%',
        height: '100%',
        // pointer events for root Modal div set to none to make descendants interactive
        pointerEvents: 'none'
    }
};
/**
 * Styles for layer host to bound the modal wrapping PiPiP in the mobile pane.
 * @private
 */
const modalLayerHostStyle = {
    display: 'flex',
    position: 'absolute',
    left: 0,
    top: 0,
    width: '100%',
    height: '100%',
    overflow: 'hidden',
    // pointer events for layerHost set to none to make descendants interactive
    pointerEvents: 'none'
};

// Copyright (c) Microsoft Corporation.
/**
 * Drag options for Modal in {@link ModalLocalAndRemotePIP} component
 */
const DRAG_OPTIONS = {
    moveMenuItemText: 'Move',
    closeMenuItemText: 'Close',
    menu: react.ContextualMenu,
    keepInBounds: true
};
/**
 * A wrapping component with a draggable {@link LocalAndRemotePIP} component that is bound to a LayerHost component with id
 * specified by `modalLayerHostId` prop
 * @private
 */
const ModalLocalAndRemotePIP = (props) => {
    var _a;
    const rootStyles = props.hidden ? hiddenStyle : PIPContainerStyle;
    const pictureInPictureProps = useSelector$1(localAndRemotePIPSelector);
    const pictureInPictureHandlers = useHandlers();
    const localAndRemotePIP = React.useMemo(() => {
        return React__default['default'].createElement(LocalAndRemotePIP, Object.assign({}, pictureInPictureProps, pictureInPictureHandlers));
    }, [pictureInPictureProps, pictureInPictureHandlers]);
    const modalStylesThemed = react.concatStyleSets(modalStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.modal);
    return React__default['default'].createElement(react.Stack, { styles: rootStyles },
        React__default['default'].createElement(_ModalClone, { isOpen: true, isModeless: true, dragOptions: DRAG_OPTIONS, styles: modalStylesThemed, layerProps: {
                hostId: props.modalLayerHostId
            }, minDragPosition: props.minDragPosition, maxDragPosition: props.maxDragPosition }, // Only render LocalAndRemotePIP when this component is NOT hidden because VideoGallery needs to have
        // possession of the dominant remote participant video stream
        !props.hidden && localAndRemotePIP));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ParticipantListWithHeading = (props) => {
    const { onFetchAvatarPersonaData, onFetchParticipantMenuItems, title, participantListProps } = props;
    const theme = react.useTheme();
    const subheadingStyleThemed = React.useMemo(() => ({
        root: {
            color: theme.palette.neutralSecondary,
            margin: props.isMobile ? '0.5rem 1rem' : '0.5rem',
            fontSize: theme.fonts.smallPlus.fontSize
        }
    }), [theme.palette.neutralSecondary, theme.fonts.smallPlus.fontSize, props.isMobile]);
    return React__default['default'].createElement(react.Stack, { className: participantListStack },
        React__default['default'].createElement(react.Stack.Item, { styles: subheadingStyleThemed }, title),
        React__default['default'].createElement(react.FocusZone, { className: participantListContainerStyle },
            React__default['default'].createElement(ParticipantList, Object.assign({}, participantListProps, { styles: props.isMobile ? participantListMobileStyle : participantListStyle, onRenderAvatar: (userId, options) => React__default['default'].createElement(React__default['default'].Fragment, null,
                    React__default['default'].createElement(AvatarPersona, Object.assign({ "data-ui-id": "chat-composite-participant-custom-avatar", userId: userId }, options, {
                        hidePersonaDetails: !!(options === null || options === void 0 ? void 0 : options.text)
                    }, { dataProvider: onFetchAvatarPersonaData })),
                    (options === null || options === void 0 ? void 0 : options.text) && React__default['default'].createElement(react.Text, { nowrap: true, styles: displayNameStyles }, options === null || options === void 0 ? void 0 : options.text)), onFetchParticipantMenuItems: onFetchParticipantMenuItems, showParticipantOverflowTooltip: !props.isMobile }))));
};

/**
 * @private
 */
/**
 * @private
 */
const peoplePaneContainerStyle = {
    root: {
        position: 'relative',
        maxHeight: '100%',
        overflow: 'hidden'
    }
};
/**
 * @private
 */
const participantListContainerStyles = {
    root: {
        overflowY: 'scroll'
    }
};
/**
 * @private
 */
const copyLinkButtonContainerStyles = {
    root: {
        width: '100%',
        padding: '0.5rem 1rem'
    }
};
/**
 * @private
 */
const copyLinkButtonStackStyles = {
    root: {
        marginLeft: '0.5rem',
        marginRight: '0.5rem'
    }
};
/**
 * @private
 */
const copyLinkButtonStyles = {
    root: {
        height: '2.5rem',
        width: '100%'
    },
    textContainer: {
        display: 'contents'
    }
};
/**
 * @private
 */
const linkIconStyles = {
    marginRight: '0.5rem'
};
/**
 * @private
 */
const themedCopyLinkButtonStyles = (mobileView, theme) => ({
    root: {
        minHeight: mobileView ? '3rem' : '2.5rem',
        borderRadius: mobileView ? theme.effects.roundedCorner6 : theme.effects.roundedCorner4
    }
});

/**
 * Convert IContextualMenuItem to _DrawerMenuItemProps
 * @param contextualMenu - IContextualMenuItem to convert
 * @param onDrawerMenuItemClick - callback to call when converted DrawerMenuItem is clicked
 * @returns DrawerMenuItem
 * @private
 */
const convertContextualMenuItemToDrawerMenuItem = (contextualMenu, onDrawerMenuItemClick) => {
    return {
        itemKey: contextualMenu.key,
        onItemClick: () => {
            var _a;
            (_a = contextualMenu.onClick) === null || _a === void 0 ? void 0 : _a.call(contextualMenu);
            onDrawerMenuItemClick();
        },
        iconProps: contextualMenu.iconProps,
        text: contextualMenu.text,
        disabled: contextualMenu.disabled
    };
};

// Copyright (c) Microsoft Corporation.
/** @private */
const AddPeopleButton = (props) => {
    const { inviteLink, mobileView, strings, participantList } = props;
    const theme = react.useTheme();
    const copyLinkButtonStylesThemed = React.useMemo(() => react.concatStyleSets(copyLinkButtonStyles, themedCopyLinkButtonStyles(mobileView, theme)), [mobileView, theme]);
    if (mobileView) {
        return React__default['default'].createElement(react.Stack, null, inviteLink && React__default['default'].createElement(react.Stack.Item, { styles: copyLinkButtonContainerStyles },
            React__default['default'].createElement(react.PrimaryButton, { onClick: () => copy__default['default'](inviteLink !== null && inviteLink !== void 0 ? inviteLink : ''), styles: copyLinkButtonStylesThemed, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "Link", style: linkIconStyles }), text: strings.copyInviteLinkButtonLabel })));
    }
    else {
        return React__default['default'].createElement(react.Stack, { tokens: peoplePaneContainerTokens },
            inviteLink && React__default['default'].createElement(react.Stack, { styles: copyLinkButtonStackStyles },
                React__default['default'].createElement(react.DefaultButton, { text: strings.copyInviteLinkButtonLabel, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "Link", style: linkIconStyles }), onClick: () => copy__default['default'](inviteLink !== null && inviteLink !== void 0 ? inviteLink : ''), styles: copyLinkButtonStylesThemed })),
            participantList);
    }
};

var __awaiter$2 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const PeoplePaneContent = (props) => {
    const { inviteLink, onFetchParticipantMenuItems, setDrawerMenuItems, strings, onRemoveParticipant } = props;
    const participantListDefaultProps = usePropsFor$1(ParticipantList);
    const removeButtonAllowed = hasRemoveParticipantsPermissionTrampoline();
    const setDrawerMenuItemsForParticipant = React.useMemo(() => {
        return (participant) => {
            if (participant) {
                let contextualMenuItems = createDefaultContextualMenuItems(participant, strings, participant.isRemovable ? participantListDefaultProps.onRemoveParticipant : undefined, participantListDefaultProps.myUserId);
                if (onFetchParticipantMenuItems) {
                    contextualMenuItems = onFetchParticipantMenuItems(participant.userId, participantListDefaultProps.myUserId, contextualMenuItems);
                }
                const drawerMenuItems = contextualMenuItems.map((contextualMenu) => convertContextualMenuItemToDrawerMenuItem(contextualMenu, () => setDrawerMenuItems([])));
                setDrawerMenuItems(drawerMenuItems);
            }
        };
    }, [strings, participantListDefaultProps.onRemoveParticipant, participantListDefaultProps.myUserId, removeButtonAllowed, onFetchParticipantMenuItems, setDrawerMenuItems]);
    const participantListProps = React.useMemo(() => {
        const onRemoveAParticipant = (participantId) => __awaiter$2(void 0, void 0, void 0, function* () { return onRemoveParticipant(participantId); });
        return Object.assign(Object.assign({}, participantListDefaultProps), { 
            // Passing undefined callback for mobile to avoid context menus for participants in ParticipantList are clicked
            onRemoveParticipant: props.mobileView ? undefined : onRemoveAParticipant, 
            // We want the drawer menu items to appear when participants in ParticipantList are clicked
            onParticipantClick: props.mobileView ? setDrawerMenuItemsForParticipant : undefined });
    }, [participantListDefaultProps, props.mobileView, setDrawerMenuItemsForParticipant, onRemoveParticipant]);
    const participantList = React__default['default'].createElement(ParticipantListWithHeading, { isMobile: props.mobileView, participantListProps: participantListProps, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData, onFetchParticipantMenuItems: props.mobileView ? undefined : props.onFetchParticipantMenuItems, title: props.strings.peoplePaneSubTitle });
    if (props.mobileView) {
        return React__default['default'].createElement(react.Stack, { verticalFill: true, styles: peoplePaneContainerStyle, tokens: peoplePaneContainerTokens },
            React__default['default'].createElement(react.Stack.Item, { grow: true, styles: participantListContainerStyles }, participantList),
            React__default['default'].createElement(AddPeopleButton, { inviteLink: inviteLink, mobileView: props.mobileView, participantList: participantList, strings: strings }));
    }
    return React__default['default'].createElement(AddPeopleButton, { inviteLink: inviteLink, mobileView: props.mobileView, participantList: participantList, strings: strings });
};
/**
 * Create default contextual menu items for particant
 * @param participant - participant to create contextual menu items for
 * @param strings - localized strings for menu item text
 * @param onRemoveParticipant - callback to remove participant
 * @param localParticipantUserId - Local participant user id
 * @returns - IContextualMenuItem[]
 */
const createDefaultContextualMenuItems = (participant, strings, onRemoveParticipant, localParticipantUserId) => {
    const menuItems = [];
    if (onRemoveParticipant && (participant === null || participant === void 0 ? void 0 : participant.userId) !== localParticipantUserId) {
        menuItems.push({
            key: 'remove',
            text: strings.removeMenuLabel,
            onClick: () => {
                if (participant === null || participant === void 0 ? void 0 : participant.userId) {
                    onRemoveParticipant === null || onRemoveParticipant === void 0 ? void 0 : onRemoveParticipant(participant === null || participant === void 0 ? void 0 : participant.userId);
                }
            },
            iconProps: {
                iconName: 'UserRemove'
            }
        });
    }
    return menuItems;
};
/**
 * @private
 */
const hasRemoveParticipantsPermissionTrampoline = () => {
    // Return true if stable.
    return true;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mobilePaneStyle = {
    root: {
        width: '100%',
        height: '100%'
    }
};
/**
 * @private
 */
react.concatStyleSets(mobilePaneStyle, {
    root: {
        display: 'none'
    }
});
/**
 * @private
 */
const mobilePaneControlBarStyle = {
    root: {
        height: '3rem'
    }
};
/**
 * @private
 */
const mobilePaneBackButtonStyles = {
    root: {
        border: 'none',
        minWidth: '2.5rem',
        height: '100%',
        background: 'none',
        padding: '0 1rem'
    },
    rootChecked: {
        background: 'none'
    },
    rootCheckedHovered: {
        background: 'none'
    }
};
/**
 * @private
 */
const mobilePaneHiddenIconStyles = react.concatStyleSets(mobilePaneBackButtonStyles, {
    root: {
        visibility: 'hidden'
    }
});
/**
 * @private
 */
const mobilePaneButtonStyles = {
    root: {
        border: 'none',
        borderBottom: '0.125rem solid transparent',
        width: '8rem',
        height: '100%',
        background: 'none',
        padding: '0'
    },
    rootChecked: {
        background: 'none'
    },
    rootCheckedHovered: {
        background: 'none'
    },
    flexContainer: {
        flexFlow: 'column',
        display: 'contents'
    },
    label: {
        fontSize: '1rem',
        fontWeight: 100,
        lineHeight: '2rem',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
    },
    labelChecked: {
        fontWeight: 600
    }
};
/**
 * @private
 */
const hiddenStyles = {
    root: {
        display: 'none'
    }
};
/**
 * @private
 */
const sidePaneStyles = {
    root: {
        height: '100%',
        padding: '0.5rem 0.25rem',
        maxWidth: '21.5rem'
    }
};
/**
 * @private
 */
const availableSpaceStyles = {
    root: {
        width: '100%',
        height: '100%'
    }
};
/**
 * @private
 */
const sidePaneTokens = {
    childrenGap: '0.5rem'
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const TabHeader = (props) => {
    const { onClose, onChatButtonClicked, onPeopleButtonClicked, activeTab, strings } = props;
    const theme = useTheme();
    const haveMultipleTabs = onChatButtonClicked && onPeopleButtonClicked;
    const mobilePaneButtonStylesThemed = React.useMemo(() => {
        return react.concatStyleSets(mobilePaneButtonStyles, {
            root: {
                width: '100%'
            },
            label: {
                fontSize: theme.fonts.medium.fontSize,
                fontWeight: theme.fonts.medium.fontWeight
            }
        }, haveMultipleTabs ? {
            rootChecked: {
                borderBottom: `0.125rem solid ${theme.palette.themePrimary}`
            }
        } : {});
    }, [theme, haveMultipleTabs]);
    return React__default['default'].createElement(react.Stack, { horizontal: true, grow: true, styles: mobilePaneControlBarStyle },
        React__default['default'].createElement(react.DefaultButton, { ariaLabel: strings.returnToCallButtonAriaLabel, ariaDescription: strings.returnToCallButtonAriaDescription, onClick: onClose, styles: mobilePaneBackButtonStyles, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }), autoFocus: true }),
        React__default['default'].createElement(react.Stack.Item, { grow: true }, onChatButtonClicked && React__default['default'].createElement(react.DefaultButton, { onClick: onChatButtonClicked, styles: mobilePaneButtonStylesThemed, checked: activeTab === 'chat', role: 'tab', disabled: props.disableChatButton }, strings.chatButtonLabel)),
        React__default['default'].createElement(react.Stack.Item, { grow: true }, onPeopleButtonClicked && React__default['default'].createElement(react.DefaultButton, { onClick: onPeopleButtonClicked, styles: mobilePaneButtonStylesThemed, checked: activeTab === 'people', role: 'tab', disabled: props.disablePeopleButton }, strings.peopleButtonLabel)),
        React__default['default'].createElement(react.DefaultButton, { styles: mobilePaneHiddenIconStyles, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }) }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// Use document.getElementById until Fluent's Stack supports componentRef property: https://github.com/microsoft/fluentui/issues/20410
const useMinMaxDragPosition = (modalLayerHostId, rtl) => {
    const modalHostRef = React.useRef(document.getElementById(modalLayerHostId));
    const modalHostWidth = _useContainerWidth(modalHostRef);
    const modalHostHeight = _useContainerHeight(modalHostRef);
    const minDragPosition = React.useMemo(() => modalHostWidth === undefined ? undefined : {
        x: rtl ? -1 * MODAL_PIP_DEFAULT_PX.rightPositionPx : MODAL_PIP_DEFAULT_PX.rightPositionPx - modalHostWidth + MODAL_PIP_DEFAULT_PX.widthPx,
        y: -1 * MODAL_PIP_DEFAULT_PX.topPositionPx
    }, [modalHostWidth, rtl]);
    const maxDragPosition = React.useMemo(() => modalHostWidth === undefined || modalHostHeight === undefined ? undefined : {
        x: rtl ? modalHostWidth - MODAL_PIP_DEFAULT_PX.rightPositionPx - MODAL_PIP_DEFAULT_PX.widthPx : MODAL_PIP_DEFAULT_PX.rightPositionPx,
        y: modalHostHeight - MODAL_PIP_DEFAULT_PX.topPositionPx - MODAL_PIP_DEFAULT_PX.heightPx
    }, [modalHostHeight, modalHostWidth, rtl]);
    return {
        minDragPosition: minDragPosition,
        maxDragPosition: maxDragPosition
    };
};

var __awaiter$1 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Pane that is used to store chat and people for CallWithChat composite
 * @private
 */
const CallWithChatPane = (props) => {
    var _a, _b;
    const [drawerMenuItems, setDrawerMenuItems] = React.useState([]);
    const hidden = props.activePane === 'none';
    const paneStyles = hidden ? hiddenStyles : props.mobileView ? availableSpaceStyles : sidePaneStyles;
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const theme = useTheme();
    const header = props.activePane === 'none' ? null : props.mobileView ? React__default['default'].createElement(TabHeader, Object.assign({}, props, { strings: callWithChatStrings, activeTab: props.activePane, disableChatButton: isDisabled$2((_a = props.callControls) === null || _a === void 0 ? void 0 : _a.chatButton), disablePeopleButton: isDisabled$2((_b = props.callControls) === null || _b === void 0 ? void 0 : _b.peopleButton) })) : React__default['default'].createElement(SidePaneHeader, Object.assign({}, props, { strings: callWithChatStrings, headingText: props.activePane === 'chat' ? callWithChatStrings.chatPaneTitle : props.activePane === 'people' ? callWithChatStrings.peoplePaneTitle : '' }));
    const chatContent = React__default['default'].createElement(ChatComposite, Object.assign({}, props.chatCompositeProps, { adapter: props.chatAdapter, fluentTheme: theme, options: {
            topic: false
        }, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData }));
    /**
     * In a CallWithChat when a participant is removed, we must remove them from both
     * the call and the chat thread.
     */
    const removeParticipantFromCallWithChat = (participantId) => __awaiter$1(void 0, void 0, void 0, function* () {
        yield props.callAdapter.removeParticipant(participantId);
        yield props.chatAdapter.removeParticipant(participantId);
    });
    const peopleContent = React__default['default'].createElement(CallAdapterProvider, { adapter: props.callAdapter },
        React__default['default'].createElement(PeoplePaneContent, Object.assign({}, props, { onRemoveParticipant: removeParticipantFromCallWithChat, setDrawerMenuItems: setDrawerMenuItems, strings: callWithChatStrings })));
    const minMaxDragPosition = useMinMaxDragPosition(props.modalLayerHostId, props.rtl);
    const pipStyles = React.useMemo(() => getPipStyles(theme), [theme]);
    const dataUiId = props.activePane === 'chat' ? 'call-with-chat-composite-chat-pane' : props.activePane === 'people' ? 'call-with-chat-composite-people-pane' : '';
    return React__default['default'].createElement(react.Stack, { verticalFill: true, grow: true, styles: paneStyles, "data-ui-id": dataUiId, tokens: props.mobileView ? {} : sidePaneTokens },
        header,
        React__default['default'].createElement(react.Stack.Item, { verticalFill: true, grow: true, styles: paneBodyContainer },
            React__default['default'].createElement(react.Stack, { horizontal: true, styles: scrollableContainer },
                React__default['default'].createElement(react.Stack.Item, { verticalFill: true, styles: scrollableContainerContents },
                    React__default['default'].createElement(react.Stack, { styles: props.activePane === 'chat' ? availableSpaceStyles : hiddenStyles }, chatContent),
                    React__default['default'].createElement(react.Stack, { styles: props.activePane === 'people' ? availableSpaceStyles : hiddenStyles }, peopleContent)))),
        props.mobileView && React__default['default'].createElement(CallAdapterProvider, { adapter: props.callAdapter },
            React__default['default'].createElement(ModalLocalAndRemotePIP, { modalLayerHostId: props.modalLayerHostId, hidden: hidden, styles: pipStyles, minDragPosition: minMaxDragPosition.minDragPosition, maxDragPosition: minMaxDragPosition.maxDragPosition })),
        drawerMenuItems.length > 0 && React__default['default'].createElement(react.Stack, { styles: drawerContainerStyles },
            React__default['default'].createElement(_DrawerMenu, { onLightDismiss: () => setDrawerMenuItems([]), items: drawerMenuItems })));
};

// Copyright (c) Microsoft Corporation.
const CallWithChatScreen = (props) => {
    const { callWithChatAdapter, fluentTheme, formFactor = 'desktop' } = props;
    const mobileView = formFactor === 'mobile';
    if (!callWithChatAdapter) {
        throw new Error('CallWithChatAdapter is undefined');
    }
    const callAdapter = React.useMemo(() => new CallWithChatBackedCallAdapter(callWithChatAdapter), [callWithChatAdapter]);
    const [currentCallState, setCurrentCallState] = React.useState();
    const [currentPage, setCurrentPage] = React.useState();
    const [activePane, setActivePane] = React.useState('none');
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    React.useEffect(() => {
        const updateCallWithChatPage = (newState) => {
            var _a;
            setCurrentPage(newState.page);
            setCurrentCallState((_a = newState.call) === null || _a === void 0 ? void 0 : _a.state);
        };
        updateCallWithChatPage(callWithChatAdapter.getState());
        callWithChatAdapter.onStateChange(updateCallWithChatPage);
        return () => {
            callWithChatAdapter.offStateChange(updateCallWithChatPage);
        };
    }, [callWithChatAdapter]);
    const closePane = React.useCallback(() => {
        setActivePane('none');
    }, [setActivePane]);
    const chatProps = React.useMemo(() => {
        return {
            adapter: new CallWithChatBackedChatAdapter(callWithChatAdapter)
        };
    }, [callWithChatAdapter]);
    const modalLayerHostId = reactHooks.useId('modalLayerhost');
    const isInLobbyOrConnecting = currentPage === 'lobby';
    const hasJoinedCall = !!(currentPage && hasJoinedCallFn(currentPage, currentCallState !== null && currentCallState !== void 0 ? currentCallState : 'None'));
    const showControlBar = isInLobbyOrConnecting || hasJoinedCall;
    const isMobileWithActivePane = mobileView && hasJoinedCall && activePane !== 'none';
    /** Constant setting of id for the parent stack of the composite */
    const compositeParentDivId = reactHooks.useId('callWithChatCompositeParentDiv-internal');
    const toggleChat = React.useCallback(() => {
        if (activePane === 'chat' || !hasJoinedCall) {
            setActivePane('none');
        }
        else {
            setActivePane('chat'); // timeout is required to give the window time to render the sendbox so we have something to send focus to.
            // TODO: Selecting elements in the DOM via attributes is not stable. We should expose an API from ChatComposite to be able to focus on the sendbox.
            const chatFocusTimeout = setInterval(() => {
                const callWithChatCompositeRootDiv = document.querySelector(`[id="${compositeParentDivId}"]`);
                const sendbox = callWithChatCompositeRootDiv === null || callWithChatCompositeRootDiv === void 0 ? void 0 : callWithChatCompositeRootDiv.querySelector(`[id="sendbox"]`);
                if (sendbox !== null) {
                    sendbox.focus();
                    clearInterval(chatFocusTimeout);
                }
            }, 3);
            setTimeout(() => {
                clearInterval(chatFocusTimeout);
            }, 300);
        }
    }, [activePane, setActivePane, compositeParentDivId, hasJoinedCall]);
    const togglePeople = React.useCallback(() => {
        if (activePane === 'people' || !hasJoinedCall) {
            setActivePane('none');
        }
        else {
            setActivePane('people');
        }
    }, [activePane, setActivePane, hasJoinedCall]);
    const selectChat = React.useCallback(() => {
        if (hasJoinedCall) {
            setActivePane('chat');
        }
    }, [setActivePane, hasJoinedCall]);
    const selectPeople = React.useCallback(() => {
        if (hasJoinedCall) {
            setActivePane('people');
        }
    }, [setActivePane, hasJoinedCall]);
    const [showDrawer, setShowDrawer] = React.useState(false);
    const onMoreButtonClicked = React.useCallback(() => {
        closePane();
        setShowDrawer(true);
    }, [closePane]);
    const closeDrawer = React.useCallback(() => {
        setShowDrawer(false);
    }, []);
    const onMoreDrawerPeopleClicked = React.useCallback(() => {
        setShowDrawer(false);
        togglePeople();
    }, [togglePeople]); // On mobile, when there is an active call and some side pane is active,
    // we hide the call composite via CSS to show only the pane.
    // We only set `display` to `none` instead of unmounting the call composite component tree
    // to avoid the performance cost of rerendering video streams when we later show the composite again.
    const callCompositeContainerCSS = React.useMemo(() => {
        return {
            display: isMobileWithActivePane ? 'none' : 'flex'
        };
    }, [isMobileWithActivePane]);
    return React__default['default'].createElement("div", { ref: containerRef, className: react.mergeStyles(containerDivStyles) },
        React__default['default'].createElement(react.Stack, { verticalFill: true, grow: true, styles: compositeOuterContainerStyles, id: compositeParentDivId },
            React__default['default'].createElement(react.Stack, { horizontal: true, grow: true },
                React__default['default'].createElement(react.Stack.Item, { grow: true, styles: callCompositeContainerStyles, style: callCompositeContainerCSS },
                    React__default['default'].createElement(CallComposite, Object.assign({}, props, { formFactor: formFactor, options: {
                            callControls: false
                        }, adapter: callAdapter, fluentTheme: fluentTheme }))),
                chatProps.adapter && callAdapter && hasJoinedCall && React__default['default'].createElement(CallWithChatPane, { chatCompositeProps: chatProps, inviteLink: props.joinInvitationURL, onClose: closePane, chatAdapter: chatProps.adapter, callAdapter: callAdapter, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData, onFetchParticipantMenuItems: props.onFetchParticipantMenuItems, onChatButtonClicked: showShowChatTabHeaderButton(props.callControls) ? selectChat : undefined, onPeopleButtonClicked: showShowPeopleTabHeaderButton(props.callControls) ? selectPeople : undefined, modalLayerHostId: modalLayerHostId, mobileView: mobileView, activePane: activePane, rtl: props.rtl, callControls: typeof props.callControls !== 'boolean' ? props.callControls : undefined })),
            showControlBar && !isMobileWithActivePane && React__default['default'].createElement(ChatAdapterProvider, { adapter: chatProps.adapter },
                React__default['default'].createElement(react.Stack.Item, { styles: controlBarContainerStyles },
                    React__default['default'].createElement(CallWithChatControlBar, { callAdapter: callAdapter, chatAdapter: chatProps.adapter, chatButtonChecked: activePane === 'chat', onChatButtonClicked: toggleChat, peopleButtonChecked: activePane === 'people', onPeopleButtonClicked: togglePeople, onMoreButtonClicked: onMoreButtonClicked, mobileView: mobileView, disableButtonsForLobbyPage: isInLobbyOrConnecting, callControls: props.callControls, containerHeight: containerHeight, containerWidth: containerWidth }))),
            showControlBar && showDrawer && React__default['default'].createElement(ChatAdapterProvider, { adapter: chatProps.adapter },
                React__default['default'].createElement(CallAdapterProvider, { adapter: callAdapter },
                    React__default['default'].createElement(react.Stack, { styles: drawerContainerStyles },
                        React__default['default'].createElement(PreparedMoreDrawer, { callControls: props.callControls, onLightDismiss: closeDrawer, onPeopleButtonClicked: onMoreDrawerPeopleClicked })))),
            // because when the CallWithChatPane is hidden, ie. style property display is 'none', it takes up no space. This causes problems when dragging
            // the Modal because the draggable bounds thinks it has no space and will always return to its initial position after dragging.
            mobileView && React__default['default'].createElement(react.LayerHost, { id: modalLayerHostId, className: react.mergeStyles(modalLayerHostStyle) })));
};
/**
 * CallWithChatComposite brings together key components to provide a full call with chat experience out of the box.
 *
 * @public
 */
const CallWithChatComposite = (props) => {
    const { adapter, fluentTheme, rtl, formFactor, joinInvitationURL, options } = props;
    return React__default['default'].createElement(BaseProvider, { fluentTheme: fluentTheme, rtl: rtl, locale: props.locale, icons: props.icons },
        React__default['default'].createElement(CallWithChatScreen, Object.assign({}, props, { callWithChatAdapter: adapter, formFactor: formFactor, callControls: options === null || options === void 0 ? void 0 : options.callControls, joinInvitationURL: joinInvitationURL, fluentTheme: fluentTheme })));
};
const hasJoinedCallFn = (page, callStatus) => {
    return page === 'call' && (callStatus === 'Connected' || callStatus === 'Disconnecting');
};
const showShowChatTabHeaderButton = (callControls) => {
    if (callControls === undefined || callControls === true) {
        return true;
    }
    if (callControls === false) {
        return false;
    }
    return callControls.chatButton !== false;
};
const showShowPeopleTabHeaderButton = (callControls) => {
    if (callControls === undefined || callControls === true) {
        return true;
    }
    if (callControls === false) {
        return false;
    }
    return callControls.peopleButton !== false;
};

/**
 * @private
 */
function callWithChatAdapterStateFromBackingStates(callAdapter, chatAdapter) {
    const callAdapterState = callAdapter.getState();
    const chatAdapterState = chatAdapter.getState();
    return {
        call: callAdapterState.call,
        chat: chatAdapterState.thread,
        userId: callAdapterState.userId,
        page: callAdapterState.page,
        displayName: callAdapterState.displayName,
        devices: callAdapterState.devices,
        isLocalPreviewMicrophoneEnabled: callAdapterState.isLocalPreviewMicrophoneEnabled,
        isTeamsCall: callAdapterState.isTeamsCall,
        latestCallErrors: callAdapterState.latestErrors,
        latestChatErrors: chatAdapterState.latestErrors
    };
}
/**
 * @private
 */
function mergeChatAdapterStateIntoCallWithChatAdapterState(existingCallWithChatAdapterState, chatAdapterState) {
    return Object.assign(Object.assign({}, existingCallWithChatAdapterState), { chat: chatAdapterState.thread, latestChatErrors: chatAdapterState.latestErrors });
}
/**
 * @private
 */
function mergeCallAdapterStateIntoCallWithChatAdapterState(existingCallWithChatAdapterState, callAdapterState) {
    return Object.assign(Object.assign({}, existingCallWithChatAdapterState), { userId: callAdapterState.userId, page: callAdapterState.page, displayName: callAdapterState.displayName, devices: callAdapterState.devices, call: callAdapterState.call, isLocalPreviewMicrophoneEnabled: callAdapterState.isLocalPreviewMicrophoneEnabled, isTeamsCall: callAdapterState.isTeamsCall, latestCallErrors: callAdapterState.latestErrors });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Get chat thread from a teams url.
 * As per documented on the Chat SDK: https://docs.microsoft.com/en-us/azure/communication-services/quickstarts/chat/meeting-interop?pivots=platform-web#get-a-teams-meeting-chat-thread-for-a-communication-services-user
 *
 * @private
 */
const getChatThreadFromTeamsLink = (teamsMeetingLink) => {
    // Get the threadId from the url - this also contains the call locator ID that will be removed in the threadId.split
    let threadId = teamsMeetingLink.replace('https://teams.microsoft.com/l/meetup-join/', ''); // Unescape characters that applications like Outlook encode when creating joinable links
    threadId = decodeURIComponent(threadId); // Extract just the chat guid from the link, stripping away the call locator ID
    threadId = threadId.split(/^(.*?@thread\.v2)/gm)[1];
    if (!threadId || threadId.length === 0) {
        throw new Error('Could not get chat thread from teams link');
    }
    return threadId;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/** Context of Call with Chat, which is a centralized context for all state updates */
class CallWithChatContext {
    constructor(clientState) {
        this.emitter = new EventEmitter.EventEmitter();
        this.state = clientState;
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    updateClientState(clientState) {
        this.setState(clientState);
    }
    updateClientStateWithChatState(chatAdapterState) {
        this.updateClientState(mergeChatAdapterStateIntoCallWithChatAdapterState(this.state, chatAdapterState));
    }
    updateClientStateWithCallState(callAdapterState) {
        this.updateClientState(mergeCallAdapterStateIntoCallWithChatAdapterState(this.state, callAdapterState));
    }
}
/**
 * CallWithChat adapter backed by Azure Communication Services.
 * Created for easy use with the {@link CallWithChatComposite}.
 */
class AzureCommunicationCallWithChatAdapter {
    constructor(callAdapter, chatAdapter) {
        this.bindPublicMethods();
        this.callAdapter = callAdapter;
        this.chatAdapter = chatAdapter;
        this.context = new CallWithChatContext(callWithChatAdapterStateFromBackingStates(callAdapter, chatAdapter));
        const onChatStateChange = (newChatAdapterState) => {
            this.context.updateClientStateWithChatState(newChatAdapterState);
        };
        this.chatAdapter.onStateChange(onChatStateChange);
        this.onChatStateChange = onChatStateChange;
        const onCallStateChange = (newCallAdapterState) => {
            this.context.updateClientStateWithCallState(newCallAdapterState);
        };
        this.callAdapter.onStateChange(onCallStateChange);
        this.onCallStateChange = onCallStateChange;
    }
    bindPublicMethods() {
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.startCall.bind(this);
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.fetchInitialData.bind(this);
        this.sendMessage.bind(this);
        this.sendReadReceipt.bind(this);
        this.sendTypingIndicator.bind(this);
        this.loadPreviousChatMessages.bind(this);
        this.updateMessage.bind(this);
        this.deleteMessage.bind(this);
        this.on.bind(this);
        this.off.bind(this);
    }
    /** Join existing Call. */
    joinCall(microphoneOn) {
        return this.callAdapter.joinCall(microphoneOn);
    }
    /** Leave current Call. */
    leaveCall(forEveryone) {
        return __awaiter(this, void 0, void 0, function* () {
            // Only remove self from the GroupCall. Contoso must manage access to Chat.
            yield this.callAdapter.leaveCall(forEveryone);
        });
    }
    /** Start a new Call. */
    startCall(participants, options) {
        let communicationParticipants = participants;
        return this.callAdapter.startCall(communicationParticipants, options);
    }
    /**
     * Subscribe to state change events.
     * @param handler - handler to be called when the state changes. This is passed the new state.
     */
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    /**
     * Unsubscribe to state change events.
     * @param handler - handler to be no longer called when state changes.
     */
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    /** Get current Call and Chat state. */
    getState() {
        return this.context.getState();
    }
    /** Dispose of the current CallWithChatAdapter. */
    dispose() {
        this.chatAdapter.offStateChange(this.onChatStateChange);
        this.callAdapter.offStateChange(this.onCallStateChange);
        this.chatAdapter.dispose();
        this.callAdapter.dispose();
    }
    /** Remove a participant from the Call only. */
    removeParticipant(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            let participant = userId;
            yield this.callAdapter.removeParticipant(participant);
        });
    }
    setCamera(device, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.setCamera(device, options);
        });
    }
    /** Set the microphone to be used in the Call. */
    setMicrophone(device) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.setMicrophone(device);
        });
    }
    /** Set the speaker to be used in the Call. */
    setSpeaker(device) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.setSpeaker(device);
        });
    }
    askDevicePermission(constraints) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.askDevicePermission(constraints);
        });
    }
    /** Query for available cameras. */
    queryCameras() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.queryCameras();
        });
    }
    /** Query for available microphones. */
    queryMicrophones() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.queryMicrophones();
        });
    }
    /** Query for available speakers. */
    querySpeakers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.querySpeakers();
        });
    }
    /** Start the camera for the user in the Call. */
    startCamera(options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.startCamera(options);
        });
    }
    /** Stop the camera for the user in the Call. */
    stopCamera() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.stopCamera();
        });
    }
    /** Mute the user in the Call. */
    mute() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.mute();
        });
    }
    /** Unmute the user in the Call. */
    unmute() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.unmute();
        });
    }
    /** Trigger the user to start screen share. */
    startScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.startScreenShare();
        });
    }
    /** Stop the current active screen share. */
    stopScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.stopScreenShare();
        });
    }
    /** Create a stream view for a remote participants video feed. */
    createStreamView(remoteUserId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.createStreamView(remoteUserId, options);
        });
    }
    /** Dispose of a created stream view of a remote participants video feed. */
    disposeStreamView(remoteUserId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.disposeStreamView(remoteUserId, options);
        });
    }
    /** Fetch initial Call and Chat data such as chat messages. */
    fetchInitialData() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.fetchInitialData();
        });
    }
    /** Send a chat message. */
    sendMessage(content) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendMessage(content);
        });
    }
    /** Send a chat read receipt. */
    sendReadReceipt(chatMessageId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendReadReceipt(chatMessageId);
        });
    }
    /** Send an isTyping indicator. */
    sendTypingIndicator() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendTypingIndicator();
        });
    }
    /** Load previous Chat messages. */
    loadPreviousChatMessages(messagesToLoad) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.chatAdapter.loadPreviousChatMessages(messagesToLoad);
        });
    }
    /** Update an existing message. */
    updateMessage(messageId, content, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.chatAdapter.updateMessage(messageId, content, metadata);
        });
    }
    /** Delete an existing message. */
    deleteMessage(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.chatAdapter.deleteMessage(messageId);
        });
    }
    on(event, listener) {
        switch (event) {
            case 'callParticipantsJoined':
                this.callAdapter.on('participantsJoined', listener);
                break;
            case 'callParticipantsLeft':
                this.callAdapter.on('participantsLeft', listener);
                break;
            case 'callEnded':
                this.callAdapter.on('callEnded', listener);
                break;
            case 'isMutedChanged':
                this.callAdapter.on('isMutedChanged', listener);
                break;
            case 'callIdChanged':
                this.callAdapter.on('callIdChanged', listener);
                break;
            case 'isLocalScreenSharingActiveChanged':
                this.callAdapter.on('isLocalScreenSharingActiveChanged', listener);
                break;
            case 'displayNameChanged':
                this.callAdapter.on('displayNameChanged', listener);
                break;
            case 'isSpeakingChanged':
                this.callAdapter.on('isSpeakingChanged', listener);
                break;
            case 'selectedMicrophoneChanged':
                this.callAdapter.on('selectedMicrophoneChanged', listener);
                break;
            case 'selectedSpeakerChanged':
                this.callAdapter.on('selectedSpeakerChanged', listener);
                break;
            case 'messageReceived':
                this.chatAdapter.on('messageReceived', listener);
                break;
            case 'messageSent':
                this.chatAdapter.on('messageSent', listener);
                break;
            case 'messageRead':
                this.chatAdapter.on('messageRead', listener);
                break;
            case 'chatParticipantsAdded':
                this.chatAdapter.on('participantsAdded', listener);
                break;
            case 'chatParticipantsRemoved':
                this.chatAdapter.on('participantsRemoved', listener);
                break;
            case 'callError':
                this.callAdapter.on('error', listener);
                break;
            case 'chatError':
                this.chatAdapter.on('error', listener);
                break;
            default:
                throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;
        }
    }
    off(event, listener) {
        switch (event) {
            case 'callParticipantsJoined':
                this.callAdapter.off('participantsJoined', listener);
                break;
            case 'callParticipantsLeft':
                this.callAdapter.off('participantsLeft', listener);
                break;
            case 'callEnded':
                this.callAdapter.off('callEnded', listener);
                break;
            case 'isMutedChanged':
                this.callAdapter.off('isMutedChanged', listener);
                break;
            case 'callIdChanged':
                this.callAdapter.off('callIdChanged', listener);
                break;
            case 'isLocalScreenSharingActiveChanged':
                this.callAdapter.off('isLocalScreenSharingActiveChanged', listener);
                break;
            case 'displayNameChanged':
                this.callAdapter.off('displayNameChanged', listener);
                break;
            case 'isSpeakingChanged':
                this.callAdapter.off('isSpeakingChanged', listener);
                break;
            case 'selectedMicrophoneChanged':
                this.callAdapter.off('selectedMicrophoneChanged', listener);
                break;
            case 'selectedSpeakerChanged':
                this.callAdapter.off('selectedSpeakerChanged', listener);
                break;
            case 'messageReceived':
                this.chatAdapter.off('messageReceived', listener);
                break;
            case 'messageSent':
                this.chatAdapter.off('messageSent', listener);
                break;
            case 'messageRead':
                this.chatAdapter.off('messageRead', listener);
                break;
            case 'chatParticipantsAdded':
                this.chatAdapter.off('participantsAdded', listener);
                break;
            case 'chatParticipantsRemoved':
                this.chatAdapter.off('participantsRemoved', listener);
                break;
            case 'callError':
                this.callAdapter.off('error', listener);
                break;
            case 'chatError':
                this.chatAdapter.off('error', listener);
                break;
            default:
                throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;
        }
    }
}
/**
 * Create a CallWithChatAdapter backed by Azure Communication services
 * to plug into the {@link CallWithChatComposite}.
 *
 * @public
 */
const createAzureCommunicationCallWithChatAdapter = ({ userId, displayName, credential, endpoint, locator }) => __awaiter(void 0, void 0, void 0, function* () {
    const callAdapterLocator = isTeamsMeetingLinkLocator(locator) ? locator : locator.callLocator;
    const createCallAdapterPromise = createAzureCommunicationCallAdapter({
        userId,
        displayName,
        credential,
        locator: callAdapterLocator
    });
    const threadId = isTeamsMeetingLinkLocator(locator) ? getChatThreadFromTeamsLink(locator.meetingLink) : locator.chatThreadId;
    const createChatAdapterPromise = createAzureCommunicationChatAdapter({
        endpoint,
        userId,
        displayName,
        credential,
        threadId
    });
    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);
    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);
});
/**
 * A custom React hook to simplify the creation of {@link CallWithChatAdapter}.
 *
 * Similar to {@link createAzureCommunicationCallWithChatAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
const useAzureCommunicationCallWithChatAdapter = (args, afterCreate, beforeDispose) => {
    const { credential, displayName, endpoint, locator, userId } = args; // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = React.useState(undefined); // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = React.useRef(undefined);
    const afterCreateRef = React.useRef(undefined);
    const beforeDisposeRef = React.useRef(undefined); // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    React.useEffect(() => {
        if (!credential || !displayName || !endpoint || !locator || !userId) {
            return;
        }
        (() => __awaiter(void 0, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = yield createAzureCommunicationCallWithChatAdapter({
                credential,
                displayName,
                endpoint,
                locator,
                userId
            });
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            setAdapter(newAdapter);
        }))();
    }, // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, endpoint, locator, userId]); // Dispose any existing adapter when the component unmounts.
    React.useEffect(() => {
        return () => {
            (() => __awaiter(void 0, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
};
/**
 * Create a {@link CallWithChatAdapter} using the provided {@link StatefulChatClient} and {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient} and {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallWithChatAdapter} for a simpler API.
 *
 * @public
 */
const createAzureCommunicationCallWithChatAdapterFromClients = ({ callClient, callAgent, callLocator, chatClient, chatThreadClient }) => __awaiter(void 0, void 0, void 0, function* () {
    const createCallAdapterPromise = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, callLocator);
    const createChatAdapterPromise = createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);
    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);
    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);
});
const isTeamsMeetingLinkLocator = (locator) => {
    return 'meetingLink' in locator;
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector = (selector, selectorProps, type) => {
    // Because of react hooks rules, hooks can't be conditionally called
    // We call both call and chat hooks and detect current context
    // Return undefined and skip execution when not in that context
    const callingMode = !type || type === 'calling';
    const chatMode = !type || type === 'chat';
    const callProps = useSelector$3(callingMode ? selector : undefined, selectorProps);
    const chatProps = useSelector$2(chatMode ? selector : undefined, selectorProps);
    return callProps !== null && callProps !== void 0 ? callProps : chatProps;
};
/**
 * Primary hook to get all hooks necessary for a React Component from this library.
 *
 * To call this hook, the component requires to be wrapped under these providers:
 *
 * 1. For chat components: {@link ChatClientProvider} and {@link ChatThreadClientProvider}.
 *
 * 2. For calling components: {@link CallClientProvider}, {@link CallAgentProvider} and {@link CallAgentProvider}.
 *
 * Most straightforward usage of a components looks like:
 *
 * @example
 * ```
 *     import { ParticipantList, usePropsFor } from '@azure/communication-react';
 *
 *     const App = (): JSX.Element => {
 *         // ... code to setup Providers ...
 *
 *         return <ParticipantList {...usePropsFor(ParticipantList)}/>
 *     }
 * ```
 *
 * @public
 */
const usePropsFor = (component, type) => {
    const callingSelector = type === 'calling' || !type ? getSelector$1(component) : undefined;
    const chatSelector = type === 'chat' || !type ? getSelector(component) : undefined;
    const callProps = useSelector$3(callingSelector);
    const chatProps = useSelector$2(chatSelector);
    const callingHandlers = useHandlers$3();
    const chatHandlers = useHandlers$2();
    if (chatProps) {
        if (!chatHandlers) {
            throw 'Please initialize chatClient and chatThreadClient first!';
        }
        return Object.assign(Object.assign({}, chatProps), chatHandlers);
    }
    if (callProps) {
        if (!callingHandlers) {
            throw 'Please initialize callClient first!';
        }
        return Object.assign(Object.assign({}, callProps), callingHandlers);
    }
    if (!chatSelector && !callingSelector) {
        throw "Can't find corresponding selector for this component. Please check the supported components from Azure Communication UI Feature Component List.";
    }
    else {
        throw 'Could not find props for this component, ensure the component is wrapped by appropriate providers.';
    }
};

exports.COMPONENT_LOCALE_DE_DE = COMPONENT_LOCALE_DE_DE;
exports.COMPONENT_LOCALE_EN_GB = COMPONENT_LOCALE_EN_GB;
exports.COMPONENT_LOCALE_EN_US = COMPONENT_LOCALE_EN_US;
exports.COMPONENT_LOCALE_ES_ES = COMPONENT_LOCALE_ES_ES;
exports.COMPONENT_LOCALE_FR_FR = COMPONENT_LOCALE_FR_FR;
exports.COMPONENT_LOCALE_IT_IT = COMPONENT_LOCALE_IT_IT;
exports.COMPONENT_LOCALE_JA_JP = COMPONENT_LOCALE_JA_JP;
exports.COMPONENT_LOCALE_KO_KR = COMPONENT_LOCALE_KO_KR;
exports.COMPONENT_LOCALE_NL_NL = COMPONENT_LOCALE_NL_NL;
exports.COMPONENT_LOCALE_PT_BR = COMPONENT_LOCALE_PT_BR;
exports.COMPONENT_LOCALE_RU_RU = COMPONENT_LOCALE_RU_RU;
exports.COMPONENT_LOCALE_TR_TR = COMPONENT_LOCALE_TR_TR;
exports.COMPONENT_LOCALE_ZH_CN = COMPONENT_LOCALE_ZH_CN;
exports.COMPONENT_LOCALE_ZH_TW = COMPONENT_LOCALE_ZH_TW;
exports.COMPOSITE_LOCALE_DE_DE = COMPOSITE_LOCALE_DE_DE;
exports.COMPOSITE_LOCALE_EN_GB = COMPOSITE_LOCALE_EN_GB;
exports.COMPOSITE_LOCALE_EN_US = COMPOSITE_LOCALE_EN_US;
exports.COMPOSITE_LOCALE_ES_ES = COMPOSITE_LOCALE_ES_ES;
exports.COMPOSITE_LOCALE_FR_FR = COMPOSITE_LOCALE_FR_FR;
exports.COMPOSITE_LOCALE_IT_IT = COMPOSITE_LOCALE_IT_IT;
exports.COMPOSITE_LOCALE_JA_JP = COMPOSITE_LOCALE_JA_JP;
exports.COMPOSITE_LOCALE_KO_KR = COMPOSITE_LOCALE_KO_KR;
exports.COMPOSITE_LOCALE_NL_NL = COMPOSITE_LOCALE_NL_NL;
exports.COMPOSITE_LOCALE_PT_BR = COMPOSITE_LOCALE_PT_BR;
exports.COMPOSITE_LOCALE_RU_RU = COMPOSITE_LOCALE_RU_RU;
exports.COMPOSITE_LOCALE_TR_TR = COMPOSITE_LOCALE_TR_TR;
exports.COMPOSITE_LOCALE_ZH_CN = COMPOSITE_LOCALE_ZH_CN;
exports.COMPOSITE_LOCALE_ZH_TW = COMPOSITE_LOCALE_ZH_TW;
exports.COMPOSITE_ONLY_ICONS = COMPOSITE_ONLY_ICONS;
exports.CallAgentProvider = CallAgentProvider;
exports.CallClientProvider = CallClientProvider;
exports.CallComposite = CallComposite;
exports.CallProvider = CallProvider;
exports.CallWithChatComposite = CallWithChatComposite;
exports.CameraButton = CameraButton;
exports.ChatClientProvider = ChatClientProvider;
exports.ChatComposite = ChatComposite;
exports.ChatThreadClientProvider = ChatThreadClientProvider;
exports.ControlBar = ControlBar;
exports.ControlBarButton = ControlBarButton;
exports.DEFAULT_COMPONENT_ICONS = DEFAULT_COMPONENT_ICONS;
exports.DEFAULT_COMPOSITE_ICONS = DEFAULT_COMPOSITE_ICONS;
exports.DevicesButton = DevicesButton;
exports.EndCallButton = EndCallButton;
exports.ErrorBar = ErrorBar;
exports.FluentThemeProvider = FluentThemeProvider;
exports.GridLayout = GridLayout;
exports.LocalizationProvider = LocalizationProvider$1;
exports.MessageStatusIndicator = MessageStatusIndicator;
exports.MessageThread = MessageThread;
exports.MicrophoneButton = MicrophoneButton;
exports.ParticipantItem = ParticipantItem;
exports.ParticipantList = ParticipantList;
exports.ParticipantsButton = ParticipantsButton;
exports.ScreenShareButton = ScreenShareButton;
exports.SendBox = SendBox;
exports.StreamMedia = StreamMedia;
exports.TypingIndicator = TypingIndicator;
exports.VideoGallery = VideoGallery;
exports.VideoTile = VideoTile;
exports._IdentifierProvider = _IdentifierProvider;
exports.createAzureCommunicationCallAdapter = createAzureCommunicationCallAdapter;
exports.createAzureCommunicationCallAdapterFromClient = createAzureCommunicationCallAdapterFromClient;
exports.createAzureCommunicationCallWithChatAdapter = createAzureCommunicationCallWithChatAdapter;
exports.createAzureCommunicationCallWithChatAdapterFromClients = createAzureCommunicationCallWithChatAdapterFromClients;
exports.createAzureCommunicationChatAdapter = createAzureCommunicationChatAdapter;
exports.createAzureCommunicationChatAdapterFromClient = createAzureCommunicationChatAdapterFromClient;
exports.createDefaultCallingHandlers = createDefaultCallingHandlers;
exports.createDefaultChatHandlers = createDefaultChatHandlers;
exports.createStatefulCallClient = createStatefulCallClient;
exports.createStatefulChatClient = createStatefulChatClient;
exports.darkTheme = darkTheme;
exports.fromFlatCommunicationIdentifier = fromFlatCommunicationIdentifier;
exports.getCallingSelector = getSelector$1;
exports.getChatSelector = getSelector;
exports.lightTheme = lightTheme;
exports.toFlatCommunicationIdentifier = toFlatCommunicationIdentifier;
exports.useAzureCommunicationCallAdapter = useAzureCommunicationCallAdapter;
exports.useAzureCommunicationCallWithChatAdapter = useAzureCommunicationCallWithChatAdapter;
exports.useAzureCommunicationChatAdapter = useAzureCommunicationChatAdapter;
exports.useCall = useCall;
exports.useCallAgent = useCallAgent;
exports.useCallClient = useCallClient;
exports.useChatClient = useChatClient;
exports.useChatThreadClient = useChatThreadClient;
exports.useDeviceManager = useDeviceManager;
exports.usePropsFor = usePropsFor;
exports.useSelector = useSelector;
exports.useTheme = useTheme;
//# sourceMappingURL=index.js.map
