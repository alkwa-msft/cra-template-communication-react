// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { ContextualMenu, DirectionalHint, Icon, mergeStyles, Persona, PersonaSize, Stack, Text } from '@fluentui/react';
import React, { useMemo, useRef, useState } from 'react';
import { useIdentifiers } from '../identifiers';
import { useLocale } from '../localization';
import { useTheme } from '../theming';
import { iconContainerStyle, iconStyles, meContainerStyle, menuButtonContainerStyle, participantItemContainerStyle, participantStateMaxWidth, participantStateStringStyles } from './styles/ParticipantItem.styles';
import { _preventDismissOnEvent as preventDismissOnEvent } from "../../../acs-ui-common/src";
/**
 * Component to render a calling or chat participant.
 *
 * Displays the participant's avatar, displayName and status as well as optional icons and context menu.
 *
 * @public
 */
export const ParticipantItem = (props) => {
    const { userId, displayName, onRenderAvatar, menuItems, onRenderIcon, presence, styles, me, onClick, showParticipantOverflowTooltip
    /* @conditional-compile-remove(PSTN-calls) */
     } = props;
    const [itemHovered, setItemHovered] = useState(false);
    const [itemFocused, setItemFocused] = useState(false);
    const [menuHidden, setMenuHidden] = useState(true);
    const containerRef = useRef(null);
    const theme = useTheme();
    const localeStrings = useLocale().strings.participantItem;
    const ids = useIdentifiers();
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const avatarOptions = {
        text: displayName,
        size: PersonaSize.size32,
        presence: presence,
        initialsTextColor: 'white',
        showOverflowTooltip: showParticipantOverflowTooltip
    };
    const avatar = onRenderAvatar ? onRenderAvatar(userId !== null && userId !== void 0 ? userId : '', avatarOptions) : React.createElement(Persona, Object.assign({ className: mergeStyles({
            // Prevents persona text from being vertically truncated if a global line height is less than 1.15.
            lineHeight: '1.15rem'
        }, styles === null || styles === void 0 ? void 0 : styles.avatar) }, avatarOptions));
    const meTextStyle = useMemo(() => mergeStyles(meContainerStyle, {
        color: theme.palette.neutralTertiary
    }, styles === null || styles === void 0 ? void 0 : styles.me), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.me]);
    const contextualMenuStyle = useMemo(() => mergeStyles({
        background: theme.palette.neutralLighterAlt
    }, styles === null || styles === void 0 ? void 0 : styles.menu), [theme.palette.neutralLighterAlt, styles === null || styles === void 0 ? void 0 : styles.menu]);
    const infoContainerStyle = useMemo(() => mergeStyles(iconContainerStyle, {
        color: theme.palette.neutralTertiary
    }, styles === null || styles === void 0 ? void 0 : styles.iconContainer), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.iconContainer]);
    const menuButton = useMemo(() => React.createElement(Stack, { horizontal: true, horizontalAlign: "end", className: mergeStyles(menuButtonContainerStyle), title: strings.menuTitle, "data-ui-id": ids.participantItemMenuButton },
        React.createElement(Icon, { iconName: itemHovered || itemFocused || !menuHidden ? 'ParticipantItemOptionsHovered' : 'ParticipantItemOptions', className: iconStyles })), [strings.menuTitle, ids.participantItemMenuButton, itemHovered, itemFocused, menuHidden]);
    const onDismissMenu = () => {
        setItemHovered(false);
        setItemFocused(false);
        setMenuHidden(true);
    };
    const participantStateString = participantStateStringTrampoline(props, strings);
    return React.createElement("div", { ref: containerRef, role: 'menuitem', "data-is-focusable": true, "data-ui-id": "participant-item", className: mergeStyles(participantItemContainerStyle({
            localparticipant: me,
            clickable: !!menuItems
        }), styles === null || styles === void 0 ? void 0 : styles.root), onMouseEnter: () => setItemHovered(true), onMouseLeave: () => setItemHovered(false), onFocus: () => setItemFocused(true), onBlur: () => setItemFocused(false), onClick: () => {
            if (!participantStateString) {
                setItemHovered(true);
                setMenuHidden(false);
                onClick === null || onClick === void 0 ? void 0 : onClick(props);
            }
        }, tabIndex: 0 },
        React.createElement(Stack, { horizontal: true, className: mergeStyles({
                width: `calc(100% - ${!me && participantStateString ? participantStateMaxWidth : menuButtonContainerStyle.width})`,
                alignItems: 'center'
            }) },
            avatar,
            me && React.createElement(Text, { className: meTextStyle }, strings.isMeText),
            React.createElement(Stack, { horizontal: true, className: mergeStyles(infoContainerStyle) }, onRenderIcon && onRenderIcon(props))),
        !me && participantStateString ? React.createElement(Text, { "data-ui-id": "participant-item-state-string", className: mergeStyles(participantStateStringStyles) }, participantStateString) : React.createElement("div", null, menuItems && menuItems.length > 0 && React.createElement(React.Fragment, null,
            menuButton,
            React.createElement(ContextualMenu, { items: menuItems, hidden: menuHidden, target: containerRef, onItemClick: onDismissMenu, onDismiss: onDismissMenu, directionalHint: DirectionalHint.bottomRightEdge, className: contextualMenuStyle, calloutProps: {
                    preventDismissOnEvent
                } }))));
};
const participantStateStringTrampoline = (props, strings) => {
    return undefined;
};
//# sourceMappingURL=ParticipantItem.js.map