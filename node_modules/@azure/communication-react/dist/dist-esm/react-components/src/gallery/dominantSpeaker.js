/**
 * Calculates the participants that should be rendered based on the list of dominant
 * speakers and currently rendered participants in a call.
 * @param args - SmartDominantSpeakerParticipantsArgs
 * @returns VideoGalleryRemoteParticipant[] {@link @azure/communication-react#VideoGalleryRemoteParticipant}
 */
export const smartDominantSpeakerParticipants = (args) => {
    const { participants, dominantSpeakers = [], lastVisibleParticipants = [], maxDominantSpeakers } = args; // Don't apply any logic if total number of video streams is less than max dominant speakers.
    if (participants.length <= maxDominantSpeakers) {
        return participants;
    }
    const participantsMap = participantsById(participants); // Only use the Max allowed dominant speakers that exist in participants
    const dominantSpeakerIds = Array.from(new Set(dominantSpeakers).values()).filter(id => !!participantsMap[id]).slice(0, maxDominantSpeakers);
    const lastVisibleParticipantIds = lastVisibleParticipants.map(p => p.userId);
    const newVisibleParticipantIds = lastVisibleParticipants.map(p => p.userId).slice(0, maxDominantSpeakers);
    const newDominantSpeakerIds = dominantSpeakerIds.filter(id => !newVisibleParticipantIds.includes(id)); // Remove participants that are no longer dominant and replace them with new dominant speakers.
    for (let index = 0; index < maxDominantSpeakers; index++) {
        const newVisibleParticipantId = newVisibleParticipantIds[index];
        if (newVisibleParticipantId === undefined || !dominantSpeakerIds.includes(newVisibleParticipantId)) {
            const replacement = newDominantSpeakerIds.shift();
            if (!replacement) {
                break;
            }
            newVisibleParticipantIds[index] = replacement;
        }
    }
    const removedVisibleParticipantIds = lastVisibleParticipantIds.filter(p => !newVisibleParticipantIds.includes(p));
    removedVisibleParticipantIds.forEach(p => newVisibleParticipantIds.push(p));
    const newVisibleParticipantIdSet = new Set(newVisibleParticipantIds);
    const leftoverParticipants = participants.filter(p => !newVisibleParticipantIdSet.has(p.userId));
    leftoverParticipants.forEach(p => {
        newVisibleParticipantIds.push(p.userId);
    }); // newVisibleParticipantIds can contain identifiers for participants that are no longer in the call. So we ignore those IDs.
    const newVisibleParticipants = newVisibleParticipantIds.map(participantId => participantsMap[participantId]).filter(p => !!p);
    return newVisibleParticipants;
};
const participantsById = (participants) => {
    const response = {};
    participants.forEach(p => response[p.userId] = p);
    return response;
};
//# sourceMappingURL=dominantSpeaker.js.map