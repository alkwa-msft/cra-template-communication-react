(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, (global.Azure = global.Azure || {}, global.Azure.CommmunicationServices = global.Azure.CommmunicationServices || {}, global.Azure.CommmunicationServices.Signaling = factory()));
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var tsregistrar = createCommonjsModule(function (module, exports) {
	!function(t,e){module.exports=e();}(commonjsGlobal,function(){return function(t){function e(n){if(r[n])return r[n].exports;var i=r[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var r={};return e.m=t,e.c=r,e.i=function(t){return t},e.d=function(t,r,n){e.o(t,r)||Object.defineProperty(t,r,{configurable:!1,enumerable:!0,get:n});},e.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(r,"a",r),r},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=1)}([function(t,e,r){function n(t,e){var r,n=new Promise(function(e,n){fetch(t).then(function(t){clearTimeout(r),e(t);}).catch(function(t){clearTimeout(r),n(t);});});if(0!==e){var i=new Promise(function(n,i){r=setTimeout(i,e,new Error("Fetch for '"+t.url+"' timed out"));});return Promise.race([n,i])}return n}function i(t){try{return JSON.stringify(t)}catch(e){return "Unable to serialize object of type "+typeof t}}Object.defineProperty(e,"__esModule",{value:!0}),e.fetchWithTimeout=n,e.toJson=i;var o=function(){function t(){this.start=Date.now();}return Object.defineProperty(t.prototype,"duration",{get:function(){return Date.now()-this.start},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"startTime",{get:function(){return this.start},enumerable:!0,configurable:!0}),t.prototype.reset=function(){this.start=Date.now();},t}();e.Timespan=o;},function(t,e,r){function n(t,e,r){return new l(t,e,r)}var i=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var r in e)e.hasOwnProperty(r)&&(t[r]=e[r]);};return function(e,r){function n(){this.constructor=e;}t(e,r),e.prototype=null===r?Object.create(r):(n.prototype=r.prototype,new n);}}(),o=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))(function(i,o){function s(t){try{c(n.next(t));}catch(t){o(t);}}function a(t){try{c(n.throw(t));}catch(t){o(t);}}function c(t){t.done?i(t.value):new r(function(e){e(t.value);}).then(s,a);}c((n=n.apply(t,e||[])).next());})},s=this&&this.__generator||function(t,e){function r(t){return function(e){return n([t,e])}}function n(r){if(i)throw new TypeError("Generator is already executing.");for(;c;)try{if(i=1,o&&(s=2&r[0]?o.return:r[0]?o.throw||((s=o.return)&&s.call(o),0):o.next)&&!(s=s.call(o,r[1])).done)return s;switch(o=0,s&&(r=[2&r[0],s.value]),r[0]){case 0:case 1:s=r;break;case 4:return c.label++,{value:r[1],done:!1};case 5:c.label++,o=r[1],r=[0];continue;case 7:r=c.ops.pop(),c.trys.pop();continue;default:if(s=c.trys,!(s=s.length>0&&s[s.length-1])&&(6===r[0]||2===r[0])){c=0;continue}if(3===r[0]&&(!s||r[1]>s[0]&&r[1]<s[3])){c.label=r[1];break}if(6===r[0]&&c.label<s[1]){c.label=s[1],s=r;break}if(s&&c.label<s[2]){c.label=s[2],c.ops.push(r);break}s[2]&&c.ops.pop(),c.trys.pop();continue}r=e.call(t,c);}catch(t){r=[6,t],o=0;}finally{i=s=0;}if(5&r[0])throw r[1];return {value:r[0]?r[1]:void 0,done:!0}}var i,o,s,a,c={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:r(0),throw:r(1),return:r(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a};Object.defineProperty(e,"__esModule",{value:!0});var a=r(0),c=function(t){function e(e){var r=t.call(this,e)||this;return r.name="CancelationError",r}return i(e,t),e}(Error),u=function(){function t(e,r,n){this.logger=e,this.maxBackoffInMs=r,this.initialDelay=n,this.backoffCount=0,this.id=++t.idCounter;}return t.prototype.delay=function(t){var e=this;if(void 0!==this.timerHandle)throw new Error("Retry sequence logical failure");if(-1===this.backoffCount)return new Promise(function(t,e){e(new c("Cancelled"));});var r=this.calculateNextBackoffMs();return this.backoffCount++,this.logger.info("[RegistrarClient] Backing off "+t+" for "+r+" milliseconds with ID "+this.id),new Promise(function(n,i){e.cancelFunc=i,e.timerHandle=setTimeout(function(){e.logger.info("[RegistrarClient] Back off for "+t+" with ID "+e.id+" complete"),e.timerHandle=void 0,n();},r);})},t.prototype.cancel=function(){void 0!==this.timerHandle&&(this.logger.debug("Resetting back off"),clearTimeout(this.timerHandle),void 0!==this.cancelFunc&&this.cancelFunc(new c("Cancelled"))),this.backoffCount=-1;},t.prototype.calculateNextBackoffMs=function(){var t=1+.4*(Math.random()-.5),e=this.initialDelay*Math.pow(2,this.backoffCount)*t;return e=Math.round(e),Math.min(this.maxBackoffInMs,e)},t.idCounter=0,t}(),l=function(){function t(t,e,r){this.logger=t,this.skypeTokenProvider=e,this.options=r,this.DEFAULT_MAX_RETRIES_FOR_GET_TOKEN=15,this.DEFAULT_MAX_BACKOFF_TIME_IN_MS=3e5,this.backoffs={},this.maxBackOffTime=this.options.maxRetryDelayMs>0?this.options.maxRetryDelayMs:this.DEFAULT_MAX_BACKOFF_TIME_IN_MS,this.maxRetriesForGetToken=void 0===r.maxRetriesForGetToken||null===r.maxRetriesForGetToken?this.DEFAULT_MAX_RETRIES_FOR_GET_TOKEN:r.maxRetriesForGetToken;}return t.prototype.setTelemetryLogger=function(t){this.eventLogger=t;},t.prototype.register=function(t,e){return o(this,void 0,void 0,function(){return s(this,function(r){switch(r.label){case 0:return [4,this.performRegistration(t,e,"pr_set_registration")];case 1:return r.sent(),this.cachedRegistrationParams=[t,e],[2]}})})},t.prototype.unregister=function(){return o(this,void 0,void 0,function(){var t;return s(this,function(e){switch(e.label){case 0:return this.logger.info("[RegistrarClient] sending unregister request"),t=new Request(this.options.registrarUrl+"/"+this.options.registrationId,{method:"DELETE",mode:"cors",headers:new Headers({accept:"application/json, text/javascript"})}),[4,this.callRegistrar(t,"pr_delete_registration")];case 1:return e.sent(),[2]}})})},t.prototype.cancelPendingRequests=function(){var t=this;Object.keys(this.backoffs).forEach(function(e){t.backoffs[e].cancel();}),this.backoffs={};},t.prototype.resendRegistration=function(){return o(this,void 0,void 0,function(){return s(this,function(t){switch(t.label){case 0:if(!this.cachedRegistrationParams)throw new Error("Re-registration failed because there is no registration parameters cached");return [4,this.performRegistration(this.cachedRegistrationParams[0],this.cachedRegistrationParams[1],"pr_resend_registration")];case 1:return t.sent(),[2]}})})},t.prototype.performRegistration=function(t,e,r){return o(this,void 0,void 0,function(){var n,i;return s(this,function(o){switch(o.label){case 0:return this.logger.info("[RegistrarClient] Sending register request"),n={clientDescription:t,registrationId:this.options.registrationId,nodeId:"",transports:e},i=new Request(this.options.registrarUrl,{method:"POST",mode:"cors",headers:new Headers({"content-type":"application/json",accept:"application/json, text/javascript"}),body:a.toJson(n)}),[4,this.callRegistrar(i,r)];case 1:return o.sent(),[2]}})})},t.prototype.startBackoff=function(){var t=new u(this.logger,this.maxBackOffTime,this.options.initialRetryDelayMs);return this.backoffs[t.id]=t,t},t.prototype.stopBackoff=function(t){t.cancel(),delete this.backoffs[t.id];},t.prototype.getSkypeToken=function(){return o(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return s(this,function(s){switch(s.label){case 0:t=this.startBackoff(),e=0,s.label=1;case 1:return s.trys.push([1,3,,8]),this.logger.info("[RegistrarClient] Asking for a new skypetoken"),[4,this.skypeTokenProvider(!0)];case 2:return r=s.sent(),this.stopBackoff(t),[2,r];case 3:n=s.sent(),s.label=4;case 4:return s.trys.push([4,6,,7]),(e++,i=JSON.stringify(n),e>this.maxRetriesForGetToken)?(o="[RegistrarClient] getSkypeToken retry limit hit. Will not retry now. Error: "+i,this.logger.error(o),this.stopBackoff(t),[2,Promise.reject(o)]):(this.logger.warn("[RegistrarClient] Retrying for a new skype token. Retry Count: "+e+" Error: "+i),[4,t.delay("Fetching a new skypetoken")]);case 5:return s.sent(),[3,8];case 6:throw a=s.sent(),this.stopBackoff(t),a;case 7:return [3,8];case 8:return [3,1];case 9:return [2]}})})},t.prototype.callRegistrar=function(t,e){return o(this,void 0,void 0,function(){var r,n,i,o,c,u,l,f,h,p,d,g,y,k,m,v;return s(this,function(s){switch(s.label){case 0:return r=this.startBackoff(),[4,this.skypeTokenProvider(!1)];case 1:n=s.sent(),this.setSkypeTokenHeader(t,n),i=new a.Timespan,o=0,s.label=2;case 2:c=void 0,s.label=3;case 3:return s.trys.push([3,8,13,14]),u=t.clone(),[4,a.fetchWithTimeout(u,this.options.requestTimeoutMs)];case 4:return c=s.sent(),401!==c.status?[3,6]:++o>this.maxRetriesForGetToken?(l="[RegistrarClient] getSkypeToken retry limit hit. Will not retry now. Request '"+t.url+"' failed with "+c.status+" "+c.statusText,this.logger.error(l),this.stopBackoff(r),[2,Promise.reject(l)]):(this.logger.warn("[RegistrarClient] Retry Count "+o+". Request '"+t.url+"' failed with "+c.status+" "+c.statusText),f=this.setSkypeTokenHeader,h=[t],[4,this.getSkypeToken()]);case 5:return f.apply(this,h.concat([s.sent()])),[3,20];case 6:if(c.status>=500&&c.status<600)throw new Error("Fetch for '"+t.url+"' failed with "+c.status+" "+c.statusText);s.label=7;case 7:return [3,14];case 8:p=s.sent(),this.logger.error("[RegistrarClient] Request failed with "+p),s.label=9;case 9:return s.trys.push([9,11,,12]),[4,r.delay("Registrar call retry")];case 10:return s.sent(),[3,20];case 11:throw d=s.sent(),this.logger.error("[RegistrarClient] Request cancelled"),this.stopBackoff(r),d;case 12:return [3,14];case 13:return this.sendTelemetryEvent(e,t,c,i),[7];case 14:return this.stopBackoff(r),c.ok?[2,c]:[3,15];case 15:g=void 0,s.label=16;case 16:return s.trys.push([16,18,,19]),k=(y=JSON).stringify,[4,c.json()];case 17:return g=k.apply(y,[s.sent()]),[3,19];case 18:return m=s.sent(),g="no details",[3,19];case 19:throw v="Fetch for '"+t.url+"' failed with "+c.status+" "+c.statusText+" ("+g+", MS-CV: "+c.headers.get("MS-CV")+")",this.logger.error("[RegistrarClient] "+v),new Error(v);case 20:return [3,2];case 21:return [2]}})})},t.prototype.setSkypeTokenHeader=function(t,e){t.headers.set("X-Skypetoken",e);},t.prototype.sendTelemetryEvent=function(t,e,r,n){if(void 0!==this.eventLogger){var i={name:t,properties:{url:{value:e.url},result_code:{value:void 0!==r?r.status:0},begin_timestamp:{value:n.startTime},elapsed:{value:n.duration}}};this.eventLogger.logEvent(i);}},t}();e.RegistrarClient=l,e.createRegistrarClient=n;}])});

	});

	unwrapExports(tsregistrar);

	var tstrouter = createCommonjsModule(function (module, exports) {
	!function(t,e){module.exports=e(tsregistrar);}(commonjsGlobal,function(t){return function(t){function e(o){if(n[o])return n[o].exports;var i=n[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,o){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:o});},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=19)}([function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function t(t,e){this.name=t,this.logger=e;}return t.prototype.debug=function(t){this.logger.debug("["+this.name+"] "+t);},t.prototype.info=function(t){this.logger.info("["+this.name+"] "+t);},t.prototype.warn=function(t){this.logger.warn("["+this.name+"] "+t);},t.prototype.error=function(t){this.logger.error("["+this.name+"] "+t);},t}();e.Logger=o;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0}),e.constants={TROUTER_INIT:"trouterinit",TROUTER_READY_EVENT:"trouterReadyEvent",TROUTER_READY_TIMEOUT:"trouterReadyTimeout",TROUTER_TOKEN_REQUEST:"trouterTokenRequest",TROUTER_TOKEN_GET_SUCCEEDED:"trouterTokenGetSucceeded",TROUTER_TOKEN_GET_FAILED:"trouterTokenGetFailed",TROUTER_RECONNECTING:"trouterReconnecting",RENEWAL:"renewal",NEW_CONNECTION:"newConnection",ENDPOINT_REGISTRATION_FAILED:"endpointRegistrationFailed"},e.CLIENT_VERSION="2022.35.01.26",e.HANDLED_MESSAGE_ACK=200,e.UNHANDLED_MESSAGE_ACK=404,e.FAILED_MESSAGE_ACK=500;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});!function(t){t[t.Unknown=0]="Unknown",t[t.Active=1]="Active",t[t.Inactive=2]="Inactive";}(e.UserActivityState||(e.UserActivityState={}));var o=function(){function t(){}return t}();e.HttpHeaders=o;!function(t){t[t.Unknown=0]="Unknown",t[t.Connected=2]="Connected",t[t.Disconnected=3]="Disconnected",t[t.Switching=9]="Switching";}(e.TrouterState||(e.TrouterState={}));},function(t,e,n){function o(t){try{return JSON.stringify(t)}catch(e){return "Unable to serialize object of type "+typeof t}}function i(t){var e=Math.round((new Date).getTime()/1e3);return void 0!==t&&t>e?t-e:0}function r(t){return Math.round((new Date).getTime()/1e3)+t}function s(t,e){return c(this,void 0,void 0,function(){var n,o,i;return a(this,function(r){return o=new Promise(function(e,o){fetch(t).then(function(t){clearTimeout(n),e(t);}).catch(function(t){clearTimeout(n),o(t);});}),0!==e?(i=new Promise(function(o,i){var r=new URL(t.url),s=new Error(t.method+" "+r.origin+r.pathname+" timed out");n=setTimeout(i,e,s);}),[2,Promise.race([o,i])]):[2,o]})})}var c=this&&this.__awaiter||function(t,e,n,o){return new(n||(n=Promise))(function(i,r){function s(t){try{a(o.next(t));}catch(t){r(t);}}function c(t){try{a(o.throw(t));}catch(t){r(t);}}function a(t){t.done?i(t.value):new n(function(e){e(t.value);}).then(s,c);}a((o=o.apply(t,e||[])).next());})},a=this&&this.__generator||function(t,e){function n(t){return function(e){return o([t,e])}}function o(n){if(i)throw new TypeError("Generator is already executing.");for(;a;)try{if(i=1,r&&(s=2&n[0]?r.return:n[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,n[1])).done)return s;switch(r=0,s&&(n=[2&n[0],s.value]),n[0]){case 0:case 1:s=n;break;case 4:return a.label++,{value:n[1],done:!1};case 5:a.label++,r=n[1],n=[0];continue;case 7:n=a.ops.pop(),a.trys.pop();continue;default:if(s=a.trys,!(s=s.length>0&&s[s.length-1])&&(6===n[0]||2===n[0])){a=0;continue}if(3===n[0]&&(!s||n[1]>s[0]&&n[1]<s[3])){a.label=n[1];break}if(6===n[0]&&a.label<s[1]){a.label=s[1],s=n;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(n);break}s[2]&&a.ops.pop(),a.trys.pop();continue}n=e.call(t,a);}catch(t){n=[6,t],r=0;}finally{i=s=0;}if(5&n[0])throw n[1];return {value:n[0]?n[1]:void 0,done:!0}}var i,r,s,c,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return c={next:n(0),throw:n(1),return:n(2)},"function"==typeof Symbol&&(c[Symbol.iterator]=function(){return this}),c};Object.defineProperty(e,"__esModule",{value:!0}),e.toJson=o,e.calculateTtlInSec=i,e.calculateExpireTsInSec=r,e.fetchWithTimeout=s;var h=function(){function t(t){this.base=void 0!==t?t:this.createCorrelationVectorBase(),this.extension=0;}return t.extend=function(e){return new t(e)},t.prototype.increase=function(){this.extension++;},t.prototype.value=function(){return this.base+"."+this.extension},t.prototype.createCorrelationVectorBase=function(){for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0987654321/+",e="AQgw",n="",o=0;o<21;o++)n+=t.charAt(Math.floor(Math.random()*t.length));return n+=e.charAt(Math.floor(Math.random()*e.length))},t}();e.CorrelationVector=h;var u=function(){function t(){this.start=Date.now();}return Object.defineProperty(t.prototype,"duration",{get:function(){return Date.now()-this.start},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"startTime",{get:function(){return this.start},enumerable:!0,configurable:!0}),t.prototype.reset=function(){this.start=Date.now();},t}();e.Timespan=u;},function(t,e){var n;n=function(){return this}();try{n=n||Function("return this")()||(0,eval)("this");}catch(t){"object"==typeof window&&(n=window);}t.exports=n;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(3),i=function(){function t(t,e,n,o,i,r,s){this.connectionId=t,this.connectedClientId=e,this.domId=n,this.unsecureUrl=o,this.url=i,this.c2cUrlBase=r,this.expirationTsSec=s;}return t.prototype.getRemainingTtlInSec=function(){return o.calculateTtlInSec(this.expirationTsSec)},t}();e.ServerState=i;!function(t){t[t.Unknown=0]="Unknown",t[t.Modified=1]="Modified",t[t.Snapshot=2]="Snapshot",t[t.Connected=3]="Connected";}(e.UserActivityEventReason||(e.UserActivityEventReason={}));},function(t,e,n){var o=this&&this.__assign||Object.assign||function(t){for(var e,n=1,o=arguments.length;n<o;n++){e=arguments[n];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);}return t};Object.defineProperty(e,"__esModule",{value:!0});var i,r=n(20),s=n(12),c=n(3),a=n(15),h=n(1),u=n(16),l=n(2),p=n(5),d=n(0),g=n(17),f=n(11),v=function(){function t(){this.cv=h.CLIENT_VERSION,this.ua="",this.hr="",this.v="";}return t}(),m=function(){function t(){this["force new connection"]=!0,this.reconnect=!1,this.query="",this.ackTimeoutMs=5e3;}return t}(),y="MS-CV",T=function(){function t(t){this.cvCounter=0;var e=JSON.parse(t);this.startTS=e.hasOwnProperty("startTS")?e.startTS:0,this.url=e.hasOwnProperty("url")?e.url:"",this.shortUrl=e.hasOwnProperty("shortUrl")?e.shortUrl:"",this.body=e.hasOwnProperty("body")?e.body:"",this.headers=e.hasOwnProperty("headers")?e.headers:{},this.id=e.hasOwnProperty("id")&&"number"==typeof e.id?e.id:-1,this.method=e.hasOwnProperty("method")?e.method:"",this.replied=!1,this.timedout=!1,this.timeoutTimerId=0,this.receivedCv=this.headers[y],this.updateCvHeader();}return Object.defineProperty(t.prototype,"correlationVector",{get:function(){return this.receivedCv?this.receivedCv+"."+this.cvCounter:""},enumerable:!0,configurable:!0}),t.prototype.on=function(t,e){"data"===t?this.dataCallback=e:"end"===t&&("function"==typeof this.dataCallback&&this.dataCallback(this.body),e());},t.prototype.incrementCorrelationVector=function(){++this.cvCounter,this.updateCvHeader();},t.prototype.updateCvHeader=function(){var t=this.correlationVector;t&&(this.headers[y]=t);},t}(),k=function(){function t(t,e,n){this.request=t,this.responseData=e,this.sendResponse=n;}return t.prototype.writeHead=function(t,e){this.responseData.status=t,this.responseData.headers=e;},t.prototype.write=function(t){this.responseData.body+=t;},t.prototype.end=function(t){return t&&(this.responseData.body+=t),this.sendResponse(this.request,this.responseData)},t}(),w=function(){function t(t){this.name=t,this.args={},this.timeoutTimerId=0;}return t}();!function(t){t[t.Configuration=0]="Configuration",t[t.ServerInitiated=1]="ServerInitiated";}(i=e.ReconnectReason||(e.ReconnectReason={}));var S=function(){function t(t,e,n,o,i){var s=this;this.options=e,this.manager=n,this.tokenProvider=o,this.connectionId="",this.inIncallMode=!1,this.connectionAttempt=0,this.connectedClientId="",this.isNavigatorOnline=!0,this.onNavigatorOnlineStatusUpdateBound=this.onNavigatorOnlineStatusUpdate.bind(this),this.c2cUrlBase="",this.allocationErrorsInRow=0,this.unauthorizedErrorCount=0,this.pendingTimers={},this.lastDisconnectReason="",this.UNKNOWN_TRANSPORT="unknown_transport",this.logger=new d.Logger("Connection",t),this.timeoutOptions=this.options.timeoutOptions,this.tokenBackoff=new u.ExponentialBackoff(this.logger,this.timeoutOptions.maxBackoffMs),this.clientID=Date.now(),"undefined"!=typeof window&&window.location&&(this.domId=window.location.hostname),this.clientInfo=new v,this.clientInfo.cv=h.CLIENT_VERSION,this.clientInfo.ua="",this.options&&this.options.clientInfo&&(this.clientInfo.ua=this.safeString(this.options.clientInfo.ua),this.clientInfo.v=this.safeString(this.options.clientInfo.v)),this.connectionTracker=new a.ConnectionTracker(t,this.clientID,this.clientInfo,function(){return s.getServerState()},this.options.endpointId,this.options.clientCorrelationID,this.options.environment),this.applyConnectionTrackerOptions(e);var c=this.options.incallModeTimeoutMs>0;if(this.fsm=new g.TrouterFsm(t,this,c),e.registration){var l={registrarUrl:e.registration.registrarUrl,registrationId:e.registration.registrationId,requestTimeoutMs:e.timeoutOptions.fetchTimeoutMs,initialRetryDelayMs:1e3,maxRetryDelayMs:e.timeoutOptions.maxBackoffMs};this.registrarClient=r.createRegistrarClient(t,this.tokenProvider,l);}this.userActivityState=i;}return t.prototype.start=function(t){this.logger.info("Starting"),this.reconnectParams=t,"undefined"!=typeof window&&window.navigator?(this.isNavigatorOnline=window.navigator.onLine,window.addEventListener("online",this.onNavigatorOnlineStatusUpdateBound),window.addEventListener("offline",this.onNavigatorOnlineStatusUpdateBound),this.logger.debug("Registered for browser online notifications - current state: "+this.isNavigatorOnline)):this.isNavigatorOnline=!0,this.fsm.start();},t.prototype.stop=function(t){this.logger.info("Stopping"),"undefined"!=typeof window&&window.navigator&&(window.removeEventListener("online",this.onNavigatorOnlineStatusUpdateBound),window.removeEventListener("offline",this.onNavigatorOnlineStatusUpdateBound)),this.fsm.stop(t),this.connectionTracker.close();},t.prototype.configure=function(t){var e=this.options.trouterUrl!==t.trouterUrl;this.options=t,this.applyConnectionTrackerOptions(t),e&&(this.logger.info("Configuration changed. Reconnection required."),this.fsm.onReconnectRequired(!1,i.Configuration));},t.prototype.checkConnection=function(t){this.logger.info("checkConnection called with "+t),this.fsm.checkConnection(t),t&&this.connectionTracker.sendTelemetry(a.ClientEventName.CheckConnection,{disconnectDetected:t},[]);},t.prototype.disableRegistrationsAndAutoReconnect=function(){this.stopRegisterTimer(),this.resetRegisterBackoff(),this.fsm.disableAutoReconnect();},t.prototype.getServerState=function(){return new p.ServerState(this.connectionId,this.connectedClientId,this.domId?this.domId:"",this.allocateResult?this.allocateResult.url:"",this.allocateResult?this.allocateResult.surl:"",this.c2cUrlBase,this.connectionExpireTimestampInSecs)},t.prototype.getToken=function(t,e,n){var o=this;void 0===n&&(n=0),this.logger.info("Getting token "+(e?"with backoff":"without backoff"));var i=function(){o.connectionTracker.trackStart("token"),o.tokenProvider(!t).then(function(t){o.logger.debug("token is received"),o.connectionTracker.trackEnd("token"),o.fsm.onTokenReceived(t);}).catch(function(e){var i=c.toJson(e.stack);if(o.logger.error("Getting token failed, will retry after timeout. Error: "+i),o.connectionTracker.trackError("token",i),!o.canRetryTokenFetchRequest(n+o.unauthorizedErrorCount)){return o.connectionTracker.trackError("token","getToken retry limit hit, reached terminal error state"),o.resetTokenBackoff(),void o.fsm.onTerminalError()}o.getToken(t,!0,n+1);});};e?this.tokenBackoff.backoff("getting token",i):(this.resetTokenBackoff(),i());},t.prototype.startConnectionTimer=function(){var t=this;this.stopConnectionTimer(),this.logger.debug("Starting connection timeout for "+this.timeoutOptions.connectionTimeoutMs+" ms"),this.connectionTimeoutId=setTimeout(function(){t.logger.info("Connection timeout is fired"),t.fsm.onConnectingTimeout();},this.timeoutOptions.connectionTimeoutMs);},t.prototype.stopConnectionTimer=function(){this.connectionTimeoutId&&(this.logger.debug("Stopping connection timeout"),clearTimeout(this.connectionTimeoutId),this.connectionTimeoutId=void 0);},t.prototype.startPingTimer=function(){var t=this;"websocket"===this.transportTypeName?(this.logger.debug("Starting ping timeout for "+this.timeoutOptions.pingTimeoutMs+" ms"),this.pingTimerId=setInterval(function(){t.logger.info("Ping interval fired"),t.fsm.onPingInterval();},this.timeoutOptions.pingTimeoutMs)):this.logger.debug("Not starting ping for transport "+this.transportTypeName);},t.prototype.stopPingTimer=function(){this.pingTimerId&&(this.logger.debug("Stopping ping timeout"),this.clearPingResponseTimer(),clearInterval(this.pingTimerId),this.pingTimerId=void 0);},t.prototype.shouldSkipRegistration=function(){return void 0===this.options.registration},t.prototype.hasCustomRegisterTtl=function(){return this.options.registration&&this.options.registration.registrarTtlSec},t.prototype.startRegisterTimer=function(){var t=this;void 0!==this.registrationTimerId&&this.stopRegisterTimer();var e=this.getRegistrationTtl(),n=e[0],o=(e[1],n-30);if(o<=0)return void this.logger.debug("Not starting registration timer, ttl too low("+n+" sec)");this.logger.debug("Starting registration timeout for "+o+" sec"),this.registrationTimerId=setTimeout(function(){t.logger.info("Registration timeout is fired"),t.registrationTimerId=setTimeout(function(){t.registrationTimerId=void 0,t.logger.debug("Re-registration did not happen in time"),t.dispatchUnregistered();},3e4),t.fsm.onRegistrationTimeout();},1e3*o);},t.prototype.stopRegisterTimer=function(){this.registrationTimerId&&(this.logger.debug("Stopping registration timeout"),clearTimeout(this.registrationTimerId),this.registrationTimerId=void 0);},t.prototype.resendRegistration=function(){if(!this.registrarClient)throw new Error("Trouter Client not configured to handle registrations");return this.registrarClient.resendRegistration()},t.prototype.buildSocketIoUrlParams=function(){if(!this.allocateResult)throw new Error("Allocate result is undefined in buildSocketIoUrlParams()");for(var t={},e=this.allocateResult.connectparams,n=0,o=Object.keys(e);n<o.length;n++){var i=o[n];e.hasOwnProperty(i)&&void 0!==e[i]&&(t[i]=e[i]);}return t.v="v4",t.tc=encodeURI(c.toJson(this.clientInfo)),t.timeout=this.timeoutOptions.pingTimeoutMs/1e3,t.auth="true",this.options.endpointId&&(t.epid=this.options.endpointId),this.userActivityState.state!==l.UserActivityState.Unknown&&(t.userActivity=encodeURI(c.toJson(this.userActivityState.toEventObject()))),this.appendConnectedClientIds(this.buildQuery(t),!0)},t.prototype.startSocketIo=function(){var t=this;if(this.logger.info("Starting socket io"),this.connectionTracker.trackStart("connectSocket"),!this.allocateResult)throw new Error("Allocate result is undefined in startSocketIo()");var e=this.options.ioOptions||new m;if(e["force new connection"]=!0,e.reconnect=!1,e.query=this.buildSocketIoUrlParams(),this.logger.info("connecting to "+this.allocateResult.socketio+"?"+e.query),this.stopSocketIo(),this.socket=(this.options.io||f).connect(this.allocateResult.socketio,e),void 0===this.socket)throw new Error("Can't create Socket.io object");this.socket.on("connecting",function(e){t.onSocketConnecting(e);}),this.socket.on("connect",function(){t.onSocketConnect();}),this.socket.on("connect_failed",function(e){t.onSocketConnectFailed(e);}),this.socket.on("disconnect",function(e){t.onSocketDisconnect(e);}),this.socket.on("reconnect",function(){t.onSocketReconnect();}),this.socket.on("reconnect_failed",function(e){t.onSocketReconnectFailed(e);}),this.socket.on("reconnecting",function(){t.onSocketReconnecting();}),this.socket.on("error",function(e){t.onSocketError(e);}),this.socket.on("message",function(e){t.onSocketMessage(e);}),this.socket.on("trouter.connected",function(e){t.onTrouterConnected(e);}),this.socket.on("trouter.reconnect",function(e){t.onTrouterReconnect(e);}),this.socket.on("trouter.message_loss",function(e){t.onTrouterMessageLoss(e);});},t.prototype.stopSocketIo=function(){if(this.socket){this.logger.info("clearing socket.io");try{for(var t=0,e=["connecting","connect","connect_failed","disconnect","reconnect","reconnect_failed","reconnecting","error","message","trouter.connected","trouter.reconnect","trouter.message_loss"];t<e.length;t++){var n=e[t];this.socket.removeAllListeners(n);}this.socket.disconnect(),this.logger.debug("cleared socket"),this.socket=void 0;}catch(t){this.logger.error("exception in disconnecting previous socket. Error: "+c.toJson(t.stack));}}},t.prototype.dispatchConnected=function(){this.logger.info("dispatching connected"),this.manager.onConnected(this);},t.prototype.dispatchRegistered=function(){this.logger.info("dispatching registered"),this.manager.onRegistered(this);},t.prototype.dispatchUnregistered=function(){this.logger.info("dispatching unregistered"),this.manager.onUnregistered(this);},t.prototype.dispatchDownstreamRequest=function(t){var e=this;this.logger.info("dispatching downstream request");try{var n=new k(t,new a.ResponseData(t.id),function(t,n){return e.logger.info("sending response to downstream"),e.sendResponse(t,n)});this.manager.onDownstreamRequest(this,t,n);}catch(t){this.logger.error("exception in socket.on message. Error : "+c.toJson(t.stack));}},t.prototype.dispatchReconnecting=function(){this.logger.info("dispatching reconnecting"),this.manager.onReconnecting(this);},t.prototype.dispatchReconnectIsRequired=function(t,e){this.logger.info("dispatching reconnect is required by server"),this.manager.onReconnectIsRequired(this,t,e);},t.prototype.dispatchDisconnected=function(){this.logger.info("dispatching disconnected"),this.manager.onDisconnected(this);},t.prototype.dispatchTrouterMessageLost=function(t){this.logger.info("dispatching trouter lost message"),this.manager.onTrouterMessageLost(t);},t.prototype.sendProcessedDroppedIndicators=function(t){var e=this;try{this.logger.info("emitting processed flow tags to the server");var n=new w("trouter.processed_message_loss");n.args={droppedIndicators:t},this.sendDownstreamEvent(n,function(){e.logger.info("emitted processed flow tags to the server");});}catch(t){var o=c.toJson(t.stack);this.logger.error("unable to send processed message loss event. Error: "+o),this.connectionTracker.trackError("trouter.processed_message_loss",o,!1);}},t.prototype.sendAllocateRequest=function(t){var e=this;this.connectionAttempt++,this.connectionTracker.trackNewConnection();var n,i=this.options.trouterUrl,r=i,s=this.reconnectParams;s&&s.se&&parseInt(s.se,10)<=Date.now()+36e5&&(this.logger.warn("Dropping expired cached connection parameters: "+new Date(parseInt(s.se,10))),this.reconnectParams=s=void 0),s&&s.serviceUrl!==r&&(this.logger.warn("Dropping cached connection parameters for a different environment ("+s.serviceUrl+", now "+r+")"),this.reconnectParams=s=void 0),s&&s.reconnectUrl&&(r=s.reconnectUrl),n=s?o({},s,{serviceUrl:void 0,reconnectUrl:void 0}):null,r=this.appendCorrelationIds(r,!1),r=this.appendEndpointId(r,!1),n&&(r+="&"+this.buildQuery(n),n.v||(r+="&v=v4"));var a=new Request(r,{method:"POST",mode:"cors",headers:new Headers({"X-Skypetoken":t,"Content-Type":"text/plain"})});this.logger.info("sendAllocateRequest: POST "+r),this.connectionTracker.trackStart("allocation");var h=Date.now(),u=-1;c.fetchWithTimeout(a,this.timeoutOptions.fetchTimeoutMs).then(function(t){if(u=t.status,!t.ok)throw new Error(t.statusText);var n=t.headers.get("content-type");if(!n||"application/json"!==n&&"application/json;"!==n.substring(0,17))throw new Error("Content-type '"+n+"' is unexpected");return e.connectionTracker.trackEnd("allocation"),t.json()}).then(function(t){e.allocationErrorsInRow=0,e.unauthorizedErrorCount=0,e.onAllocationResponse(t,i);}).catch(function(t){e.allocationErrorsInRow++;var n=t+", status code "+u;if(e.logger.error(e.allocationErrorsInRow+" failed allocation attempt(s) in a row. Error: "+n),e.connectionTracker.trackError("allocation",n),401===u&&e.unauthorizedErrorCount++,!e.canRetryTokenFetchRequest(e.unauthorizedErrorCount)){return e.connectionTracker.trackError("allocation","getToken retry limit hit, reached terminal error state"),void e.fsm.onTerminalError()}if(-1!==u||e.isNavigatorOnline){if(e.reconnectParams&&e.allocationErrorsInRow>=3)if(u>=400&&u<=599)e.logger.warn(e.allocationErrorsInRow+" connection attempts, server-side failure: erasing cached connection parameters"),e.reconnectParams=void 0;else if(e.reconnectParams.reconnectUrl&&e.allocationErrorsInRow%3==0){e.logger.warn(e.allocationErrorsInRow+" connection attempts, testing nominal service URL");var o=Math.min(e.timeoutOptions.connectionTimeoutMs-(Date.now()-h)-500,e.timeoutOptions.fetchTimeoutMs);return void e.testNominalUrlConnectivity(o).then(function(t){e.connectionTracker.trackProgress("nomcheck",t?"ok":"failed"),t?(e.logger.warn("Nominal service URL is reachable, erasing cached reconnect URL"),e.reconnectParams&&delete e.reconnectParams.reconnectUrl):e.logger.warn("Nominal service URL is not reachable either, keeping cached reconnect URL"),e.fsm.onAllocationFailed(!1);},function(t){e.fsm.onAllocationFailed(!1);})}}else e.logger.info("Expected failure, the browser says it is not online at the moment");e.fsm.onAllocationFailed(401===u);});},t.prototype.testNominalUrlConnectivity=function(t){var e=this;if(t<1e3)return this.logger.warn("There is no time left to reasonably perform the nominal service URL connectivity check ("+t+" ms), falling back to assuming that the connectivity is fine"),s.Promise.resolve(!0);var n;try{var o=new URL(this.options.trouterUrl);o.pathname="/",o.search="?"+this.buildQuery({check:Date.now(),cor_id:encodeURIComponent(this.options.clientCorrelationID),epid:encodeURIComponent(this.options.endpointId?this.options.endpointId:""),tc:encodeURIComponent(c.toJson(this.clientInfo))}),n=new Request(o.toString(),{method:"GET",headers:{Accept:"text/plain"}});}catch(t){return this.logger.warn("Nominal service URL connectivity test request could not be created ("+t+"), falling back to assuming that the connectivity is fine"),s.Promise.resolve(!0)}return c.fetchWithTimeout(n,t).then(function(t){if(200!==t.status)throw new Error("Not 200 OK: "+t.status+" "+t.statusText);return t.text()}).then(function(t){if("Trouter"!==t)throw new Error('Not "Trouter": '+t.substring(0,16)+(t.length>16?"...":""));return !0}).catch(function(t){return e.logger.error("Nominal service URL connectivity test failed: "+t),!1})},t.prototype.sendPingRequest=function(){var t=this;if(this.socket&&void 0===this.pingResponseTimerId)try{this.logger.info("emitting ping event");var e=!1;this.socket.emit("ping",function(){!0!==e&&t.onPingResponse();}),this.pingResponseTimerId=setTimeout(function(){t.logger.error("Ping response timeout is fired"),e=!0,t.clearPingResponseTimer(),t.fsm.onPingResponseTimeout();},this.timeoutOptions.pongTimeoutMs);}catch(t){var n=c.toJson(t.stack);this.logger.error("unable to send ping. Error: "+n),this.connectionTracker.trackError("ping",n,!1);}},t.prototype.setUserActivityState=function(t){var e=t.state!==this.userActivityState.state;this.userActivityState=t,this.fsm.onSetUserActivityState(t,e);},t.prototype.sendUserActivityState=function(t,e){this.userActivityState.state!==l.UserActivityState.Unknown&&("websocket"===this.transportTypeName&&e?t===p.UserActivityEventReason.Connected?this.sendUserActivityStateMultiple(2):this.sendUserActivityStateMultiple(1):"xhr-polling"===this.transportTypeName&&t===p.UserActivityEventReason.Modified&&this.fsm.forceReconnect("user activity/force reconnect"));},t.prototype.sendRegisterRequest=function(){var t=this;if(!this.options.registration||!this.registrarClient)throw new Error("Internal error - options.registration is undefined");if(!this.allocateResult)throw new Error("Allocate result is undefined in sendRegisterRequest()");this.logger.info("sending register request");var e=new c.Timespan;this.connectionTracker.trackStart("registration");var n=this.getRegistrationTtl(),o=n[0],i=n[1];this.registrarClient.register({appId:this.options.registration.pnhAppId,aesKey:"",languageId:"en-US",platform:this.options.registration.platform,templateKey:this.options.registration.pnhTemplateKey,platformUIVersion:this.options.registration.platformUIVersion,productContext:this.options.registration.productContext},{TROUTER:[{context:this.options.registration.context,path:this.allocateResult.surl,ttl:o}]}).then(function(){t.logger.info("Register request successful"),t.connectionTracker.trackEnd("registration"),t.fsm.onRegistrationSucceed(i),t.connectionTracker.sendTelemetry(a.ClientEventName.Registration,{duration:e.duration},[]);}).catch(function(n){t.logger.error("Register request failed. Error: "+n),t.connectionTracker.trackError("registration",n.message),t.fsm.onRegistrationFailed(!1),t.connectionTracker.sendTelemetry(a.ClientEventName.Registration,{duration:e.duration},[]);});},t.prototype.sendUnregisterRequest=function(){var t=this;this.logger.info("sending unregister request");var e=new c.Timespan;if(!this.options.registration||!this.registrarClient)throw new Error("Internal error - options.registration is undefined");this.connectionTracker.trackStart("unregistration"),this.registrarClient.unregister().then(function(){t.logger.info("Unregister request successful"),t.connectionTracker.trackEnd("unregistration"),t.fsm.onUnregistrationSucceed(),t.connectionTracker.sendTelemetry(a.ClientEventName.Unregistration,{duration:e.duration},[]);}).catch(function(n){t.logger.error("Unregister request failed. Error: "+n),t.connectionTracker.trackError("unregistration",n.message),t.fsm.onUnregistrationFailed(!1),t.connectionTracker.sendTelemetry(a.ClientEventName.Unregistration,{duration:e.duration},[]);});},t.prototype.resetTokenBackoff=function(){this.tokenBackoff.reset();},t.prototype.resetRegisterBackoff=function(){this.registrarClient&&this.registrarClient.cancelPendingRequests();},t.prototype.clearTimers=function(){this.logger.debug("Clearing all pending downstream events related timers");for(var t=0,e=Object.keys(this.pendingTimers);t<e.length;t++){var n=e[t];this.clearTimer(Number(n));}},t.prototype.restartIncallModeTimer=function(){var t=this;this.clearIncallModeTimerId(),this.logger.debug("Restarting incall mode timer"),this.incallModeTimerId=setTimeout(function(){t.logger.info("Call mode timer fired"),t.fsm.onIncallModeTimer();},this.options.incallModeTimeoutMs);},t.prototype.enterIncallMode=function(){this.logger.info("Entering incall mode"),this.timeoutOptions=this.options.incallTimeoutOptions,this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs),this.inIncallMode=!0;},t.prototype.exitIncallMode=function(){this.logger.info("Exiting incall mode"),this.clearIncallModeTimerId(),this.timeoutOptions=this.options.timeoutOptions,this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs),this.inIncallMode=!1;},t.prototype.isIncallMode=function(){return this.inIncallMode},t.prototype.sendDisconnectTelemetryEvent=function(t){var e={reason:t,serverClosed:!this.fsm.isActive()};this.connectionTracker.trackDisconnected(e),this.connectionTracker.clearConnectedInfo();},t.prototype.onSocketConnecting=function(t){this.logger.info("onSocketConnecting("+t+")"),this.transportTypeName=t,this.connectionTracker.trackProgress("connecting",this.transportTypeName),this.fsm.onConnecting();},t.prototype.onSocketConnect=function(){this.logger.info("onSocketConnect");},t.prototype.onSocketConnectFailed=function(t){this.logger.error("onSocketConnectFailed"),this.connectionTracker.trackError("connect_failed",t,!0,this.transportTypeName?this.transportTypeName:this.UNKNOWN_TRANSPORT),this.fsm.onConnectingFailed();},t.prototype.onSocketDisconnect=function(t){this.logger.error("onSocketDisconnect, reason: "+t);var e=this.connectionTracker.getSessionLength()||0;"dup"===t&&"dup"===this.lastDisconnectReason&&e<this.options.duplicateDisconnectThresholdMs&&(this.logger.warn("Socket was closed by server as Duplicate for the second time in a row after "+e+" ms which is below the threshold of "+this.options.duplicateDisconnectThresholdMs+" ms. Resetting cached connection parameters and making a new allocation."),this.reconnectParams=void 0),this.lastDisconnectReason=t,this.fsm.onSocketDisconnect(t),this.connectionExpireTimestampInSecs=void 0;},t.prototype.onSocketReconnect=function(){this.logger.error("onSocketReconnect"),this.fsm.onTrouterConnected();},t.prototype.onSocketReconnectFailed=function(t){this.logger.error("onSocketReconnectFailed with '"+t+"'"),this.fsm.onSocketDisconnect("string"==typeof t?t:void 0);},t.prototype.onSocketReconnecting=function(){this.logger.error("onSocketReconnecting");},t.prototype.onSocketError=function(t){this.logger.error("onSocketError with '"+c.toJson(t)+"'"),this.connectionTracker.trackError("connectSocket",t),this.fsm.onSocketDisconnect("string"==typeof t?t:void 0);},t.prototype.onSocketMessage=function(t){var e=this;this.logger.info("onSocketMessage");var n;try{n=new T(t);var o=n.headers&&n.headers["X-Microsoft-Skype-Chain-ID"],i=o?" Chain-Id "+o:"";this.logger.info("Received request N "+n.id+i+" CV "+n.correlationVector+" to '"+n.url+"'"),n.startTS=Date.now(),n.url&&this.urlPath&&0===n.url.indexOf(this.urlPath)&&(n.shortUrl=n.url.substring(this.urlPath.length));}catch(t){var r=c.toJson(t.stack);return this.logger.error("unable to parse request. Error: "+r),this.connectionTracker.trackRequest(void 0,r),void this.connectionTracker.sendResponseError("unable to parse request, error: "+t)}n.timeoutTimerId=setTimeout(function(){if(!n.replied){e.logger.error("Request "+n.id+" timed out");var t=new a.ResponseData(n.id);t.status=504,t.headers={"Trouter-Responder":"ClientLib"},e.sendResponse(n,t),n.timedout=!0;}},this.timeoutOptions.requestTimeoutMs);try{this.connectionTracker.trackRequest(n),this.fsm.onDownstreamRequest(n);}catch(t){this.logger.error("exception in socket.on message. Error: "+c.toJson(t.stack)),this.connectionTracker.sendResponseError(t.message,n,void 0);}},t.prototype.onTrouterConnected=function(t){if(!this.allocateResult)return void this.logger.error("Invalid internal state - received onTrouterConnected while allocateResult is not set");this.logger.info("onTrouterConnected: "+this.allocateResult.url),this.socket&&this.socket.socket&&this.socket.socket.options&&this.socket.socket.options.query&&(this.socket.socket.options.query+="&connected=true"),this.urlPath=this.allocateResult.url.replace(/https?:\/\/([A-z0-9\:\$\-\_\.\+\!\*\"\(\)\,]*)\//,"/");var e=this.connectedUrl!==this.allocateResult.url;this.connectedUrl=this.allocateResult.url,this.connectionExpireTimestampInSecs=c.calculateExpireTsInSec(t.ttl),this.connectionTracker.trackEnd("connectSocket"),this.connectionTracker.trackConnected(e,this.transportTypeName?this.transportTypeName:this.UNKNOWN_TRANSPORT),this.fsm.onTrouterConnected();},t.prototype.onTrouterReconnect=function(t){var e=t.target;this.logger.info("onTrouterReconnect target: "+e),"self"===e?this.fsm.onReconnectRequired(!0,i.ServerInitiated):this.fsm.onReconnectRequired(!1,i.ServerInitiated);},t.prototype.onTrouterMessageLoss=function(t){this.logger.info("onTrouterMessageLoss"),this.fsm.onTrouterMessageLost(t.droppedIndicators);},t.prototype.onNavigatorOnlineStatusUpdate=function(t){var e=window.navigator.onLine;this.logger.debug("Browser online status update - new state: "+e+", previously: "+this.isNavigatorOnline),e&&!this.isNavigatorOnline?(this.isNavigatorOnline=!0,this.tokenBackoff.expediteIfPending(),this.connectionTracker.trackProgress("browserNet","online")):!e&&this.isNavigatorOnline&&(this.isNavigatorOnline=!1,this.connectionTracker.trackProgress("browserNet","offline"));},t.prototype.onAllocationResponse=function(t,e){this.logger.info("Received allocation response "+JSON.stringify(t)),this.allocateResult=t,this.reconnectParams=o({serviceUrl:e,reconnectUrl:this.allocateResult.socketio+"v4/a"},t.connectparams);var n=+t.ttl;if(this.connectionExpireTimestampInSecs=c.calculateExpireTsInSec(n),this.connectionId=this.allocateResult.id||"",this.connectedClientId=this.allocateResult.ccid,this.logger.info("connected client id set {connectedClientId:"+this.connectedClientId+"}"),this.c2cUrlBase=t.curlb||"",""===this.c2cUrlBase){var i=t.surl.indexOf("://");i>=0&&(i=t.surl.indexOf("/",i+3))>=5&&":3443"===t.surl.substr(i-5,5)&&(this.c2cUrlBase=t.surl.substr(0,i-5));}this.manager.onConnectionParametersUpdated(this.reconnectParams),this.fsm.onAllocationSucceed();},t.prototype.onPingResponse=function(){this.logger.info("onPingResponse"),this.connectionTracker.increasePingResponseCount(),this.clearPingResponseTimer(),this.fsm.onPingResponse();},t.prototype.clearPingResponseTimer=function(){void 0!==this.pingResponseTimerId&&(clearTimeout(this.pingResponseTimerId),this.pingResponseTimerId=void 0);},t.prototype.buildQuery=function(t){for(var e=[],n=0,o=Object.keys(t);n<o.length;n++){var i=o[n];t.hasOwnProperty(i)&&void 0!==t[i]&&e.push(i+"="+t[i]);}return e.join("&")},t.prototype.appendConnectedClientIds=function(t,e){var n="";t.indexOf("ccid=")<0&&(n="ccid="+this.connectedClientId+"&"),this.domId&&(n+="dom="+this.domId+"&"),n.length>0&&(n=n.slice(0,-1));var o=e||-1!==t.indexOf("?")?"&":"?";return this.appendCorrelationIds(t+o+n,e)},t.prototype.appendEndpointId=function(t,e){var n=e||-1!==t.indexOf("?")?"&":"?";return t.indexOf("epid")<0&&this.options.endpointId?""+t+n+"epid="+this.options.endpointId:t},t.prototype.appendCorrelationIds=function(t,e){var n=e||-1!==t.indexOf("?")?"&":"?";return t.indexOf("cor_id")<0?""+t+n+"cor_id="+this.options.clientCorrelationID+"&con_num="+this.clientID+"_"+this.connectionAttempt:t},t.prototype.safeString=function(t){return "string"==typeof t?t:""},t.prototype.sendResponse=function(t,e){if(t.timedout)return this.logger.error("Request "+t.id+" already timed out"),1;if(t.replied)return this.logger.error("Response for request "+t.id+" already sent"),2;clearTimeout(t.timeoutTimerId),t.timeoutTimerId=0,t.replied=!0,e.headers=e.headers||{};var n=t.correlationVector;this.logger.info("Sending response for request N "+t.id+" CV "+n+" with status "+e.status),n&&(e.headers[y]=n),t.headers&&t.headers["trouter-request"]&&!e.headers["trouter-request"]&&(e.headers["trouter-request"]=t.headers["trouter-request"]);var o=Date.now()-t.startTS;if(e.headers["trouter-client"]=c.toJson({cd:o}),this.logger.debug("response: "+c.toJson(e)),!this.socket)return this.connectionTracker.sendResponseError("no socket",t,e),4;try{return this.socket.send(c.toJson(e)),e.sentTS=Date.now(),t.incrementCorrelationVector(),this.connectionTracker.trackResponse(t,o,e),"websocket"===this.transportTypeName&&this.sendPingRequest(),0}catch(n){var i="unable to send data on response.end. Error: "+c.toJson(n.stack);return this.logger.error(i),this.connectionTracker.sendResponseError(i,t,e),4}},t.prototype.sendUserActivityStateMultiple=function(t){var e=this,n=new w("user.activity"),o=this.userActivityState.toEventObject();n.args=o,this.userActivityState.correlationVector.increase(),this.logger.debug("Sending user activity '"+this.userActivityState.toEventJSON()+"', remaining "+(t-1));var i=!1;this.sendDownstreamEvent(n,function(){if(!0!==i&&(e.logger.info("User activity state: "+o.state+", cv: "+o.cv+" accepted"),e.manager.onUserActivityStateAccepted&&e.manager.onUserActivityStateAccepted(o.cv),e.clearTimer(n.timeoutTimerId),t>1)){var r=setTimeout(function(){e.clearTimer(r),e.sendUserActivityStateMultiple(t-1);},e.options.userActivitySecondResendDelayMs);e.registerTimer(r,"user.activity/resend");}}),n.timeoutTimerId=setTimeout(function(){e.logger.error("Activity state response timeout is fired"),i=!0,e.fsm.onActivityStateResponseTimeout(),e.clearTimer(n.timeoutTimerId);},this.timeoutOptions.userActivityResponseTimeoutMs),this.registerTimer(n.timeoutTimerId,"user.activity/response");},t.prototype.sendDownstreamEvent=function(t,e){this.logger.info("Sending downstream event "+t.name),this.socket&&this.socket.emit(t.name,t.args,e);},t.prototype.registerTimer=function(t,e){this.logger.debug("registering timer "+t+" -> "+e),this.pendingTimers[t]=e;},t.prototype.clearTimer=function(t){var e=this.pendingTimers[t];this.logger.debug("clearing timer "+t+" -> "+e),delete this.pendingTimers[t],clearTimeout(t);},t.prototype.getRegistrationTtl=function(){var t=c.calculateTtlInSec(this.connectionExpireTimestampInSecs);if(this.logger.debug("Current connectionID will expire in "+t+" seconds"),this.options.registration&&this.options.registration.registrarTtlSec&&t>0){var e=this.options.registration.registrarTtlSec<t;return [Math.min(this.options.registration.registrarTtlSec,t),e]}return this.options.registration&&this.options.registration.registrarTtlSec?[this.options.registration.registrarTtlSec,!1]:t>0?[t,!1]:[3600,!1]},t.prototype.clearIncallModeTimerId=function(){void 0!==this.incallModeTimerId&&(this.logger.debug("Clearing in-call mode timer"),clearTimeout(this.incallModeTimerId),this.incallModeTimerId=void 0);},t.prototype.applyConnectionTrackerOptions=function(t){try{t.eventLogger&&"function"==typeof t.eventLogger.logEvent?(this.connectionTracker.mergeSettings(t.telemetrySettings),this.connectionTracker.enable(t.eventLogger)):this.logger.warn("Trouter client event logging disabled due to invalid configuration.");}catch(t){this.logger.warn("Trouter client event logging disabled. Error: "+c.toJson(t.stack)),this.connectionTracker.disable();}},t.prototype.canRetryTokenFetchRequest=function(t){var e=this.options.retryLimitOnTokenFetch;return null===e||void 0===e||(t<e||(this.logger.warn("Reached limit on maximum number of token fetch request. Current count: "+t+", retry limit: "+e),!1))},t}();e.TrouterConnection=S;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),i=function(){function t(t){this.logger=t,this.messageHandlers=[];}return t.prototype.register=function(t){if(this.messageHandlers.some(function(e){return e===t}))throw new Error("Registering the same handler twice is not allowed");this.messageHandlers.push(t);},t.prototype.clear=function(){this.logger.debug("Clearing message handlers"),this.messageHandlers=[];},t.prototype.active=function(){return this.messageHandlers.length>0},t.prototype.handleMessage=function(t){for(var e={resultCode:o.UNHANDLED_MESSAGE_ACK,isHandled:!1},n=0,i=this.messageHandlers;n<i.length;n++){var r=i[n],s=this.safeExecuteHandle(r,t);if(void 0!==s&&(void 0===s.isHandled||s.isHandled))return void 0===s.resultCode&&(s.resultCode=o.HANDLED_MESSAGE_ACK),s}return e},t.prototype.safeExecuteHandle=function(t,e){try{return t.handleMessage(e)}catch(t){return void this.logger.warn("A trouter message handler is throwing exceptions. exception: "+t)}},t}();e.MessageHandlerRegistry=i;},function(t,e,n){function o(t){var e,n=this;return function(o){return i(n,void 0,void 0,function(){return r(this,function(n){return o&&(e=void 0),[2,new Promise(function(n,i){t(o).then(function(t){e=t,n(t);}).catch(function(t){void 0!==e&&e.length>0&&n(e),i(t);});})]})})}}var i=this&&this.__awaiter||function(t,e,n,o){return new(n||(n=Promise))(function(i,r){function s(t){try{a(o.next(t));}catch(t){r(t);}}function c(t){try{a(o.throw(t));}catch(t){r(t);}}function a(t){t.done?i(t.value):new n(function(e){e(t.value);}).then(s,c);}a((o=o.apply(t,e||[])).next());})},r=this&&this.__generator||function(t,e){function n(t){return function(e){return o([t,e])}}function o(n){if(i)throw new TypeError("Generator is already executing.");for(;a;)try{if(i=1,r&&(s=2&n[0]?r.return:n[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,n[1])).done)return s;switch(r=0,s&&(n=[2&n[0],s.value]),n[0]){case 0:case 1:s=n;break;case 4:return a.label++,{value:n[1],done:!1};case 5:a.label++,r=n[1],n=[0];continue;case 7:n=a.ops.pop(),a.trys.pop();continue;default:if(s=a.trys,!(s=s.length>0&&s[s.length-1])&&(6===n[0]||2===n[0])){a=0;continue}if(3===n[0]&&(!s||n[1]>s[0]&&n[1]<s[3])){a.label=n[1];break}if(6===n[0]&&a.label<s[1]){a.label=s[1],s=n;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(n);break}s[2]&&a.ops.pop(),a.trys.pop();continue}n=e.call(t,a);}catch(t){n=[6,t],r=0;}finally{i=s=0;}if(5&n[0])throw n[1];return {value:n[0]?n[1]:void 0,done:!0}}var i,r,s,c,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return c={next:n(0),throw:n(1),return:n(2)},"function"==typeof Symbol&&(c[Symbol.iterator]=function(){return this}),c};Object.defineProperty(e,"__esModule",{value:!0}),e.addCacheAsBackupTo=o;},function(t,e,n){var o=this&&this.__awaiter||function(t,e,n,o){return new(n||(n=Promise))(function(i,r){function s(t){try{a(o.next(t));}catch(t){r(t);}}function c(t){try{a(o.throw(t));}catch(t){r(t);}}function a(t){t.done?i(t.value):new n(function(e){e(t.value);}).then(s,c);}a((o=o.apply(t,e||[])).next());})},i=this&&this.__generator||function(t,e){function n(t){return function(e){return o([t,e])}}function o(n){if(i)throw new TypeError("Generator is already executing.");for(;a;)try{if(i=1,r&&(s=2&n[0]?r.return:n[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,n[1])).done)return s;switch(r=0,s&&(n=[2&n[0],s.value]),n[0]){case 0:case 1:s=n;break;case 4:return a.label++,{value:n[1],done:!1};case 5:a.label++,r=n[1],n=[0];continue;case 7:n=a.ops.pop(),a.trys.pop();continue;default:if(s=a.trys,!(s=s.length>0&&s[s.length-1])&&(6===n[0]||2===n[0])){a=0;continue}if(3===n[0]&&(!s||n[1]>s[0]&&n[1]<s[3])){a.label=n[1];break}if(6===n[0]&&a.label<s[1]){a.label=s[1],s=n;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(n);break}s[2]&&a.ops.pop(),a.trys.pop();continue}n=e.call(t,a);}catch(t){n=[6,t],r=0;}finally{i=s=0;}if(5&n[0])throw n[1];return {value:n[0]?n[1]:void 0,done:!0}}var i,r,s,c,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return c={next:n(0),throw:n(1),return:n(2)},"function"==typeof Symbol&&(c[Symbol.iterator]=function(){return this}),c};Object.defineProperty(e,"__esModule",{value:!0});var r=n(3),s=n(2),c=n(0),a=n(6),h=n(18),u=function(){function t(t,e){this.state=t,this.correlationVector=void 0!==e?e:r.CorrelationVector.extend();}return t.prototype.getStateString=function(){switch(this.state){case s.UserActivityState.Active:return "active";case s.UserActivityState.Inactive:return "inactive";case s.UserActivityState.Unknown:return "unknown";default:return "undefined"}},t.prototype.toEventObject=function(){return {state:this.getStateString(),cv:this.correlationVector.value()}},t.prototype.toEventJSON=function(){return r.toJson(this.toEventObject())},t}();e.UserActivityObject=u;var l=function(){function t(t,e,n,o){this.logFunc=t,this.options=e,this.tokenProvider=n,this.listener=o,this.logger=new c.Logger("Manager",t),this.logger.info("Created TrouterManager with options "+r.toJson(this.options)),this.fsm=new h.TrouterManagerFsm(t,this),this.baseEndpointUrl="",this.processedMessageLoss={},this.userActivityObject=new u(s.UserActivityState.Unknown);}return t.prototype.start=function(){this.fsm.start();},t.prototype.stop=function(t){this.fsm.stop(t);},t.prototype.configure=function(t){this.options=t,void 0!==this.firstConnection&&this.firstConnection.configure(t),void 0!==this.secondConnection&&this.secondConnection.configure(t),this.logger.info("Reconfigured TrouterManager with options "+r.toJson(this.options));},t.prototype.checkConnection=function(t){void 0!==this.firstConnection&&this.firstConnection.checkConnection(t),void 0!==this.secondConnection&&this.secondConnection.checkConnection(t);},t.prototype.resendRegistration=function(){return o(this,void 0,void 0,function(){return i(this,function(t){return void 0!==this.secondConnection?(this.logger.info("Resending registration on the second/new connection"),[2,this.secondConnection.resendRegistration()]):void 0!==this.firstConnection?(this.logger.info("Resending registration on the first/current connection"),[2,this.firstConnection.resendRegistration()]):(this.logger.info("No connection to resend registration on, will be done upon (re)connect"),[2])})})},t.prototype.getServerState=function(){if(void 0!==this.firstConnection)return this.firstConnection.getServerState()},t.prototype.getState=function(){return this.fsm.getState()},t.prototype.startFirstConnection=function(){var t=new a.TrouterConnection(this.logFunc,this.options,this,this.tokenProvider,this.userActivityObject);this.firstConnection=t,this.getConnectionCache().then(function(e){t.start(e);}).catch();},t.prototype.startSecondConnection=function(t){var e=new a.TrouterConnection(this.logFunc,this.options,this,this.tokenProvider,this.userActivityObject);this.secondConnection=e,void 0!==this.firstConnection&&this.firstConnection.disableRegistrationsAndAutoReconnect(),t?this.getConnectionCache().then(function(t){e.start(t);}).catch():e.start();},t.prototype.stopFirstConnection=function(t){void 0!==this.firstConnection&&(this.storedFirstConnection=this.firstConnection,this.firstConnection.stop(t),this.firstConnection=void 0);},t.prototype.stopSecondConnection=function(t){void 0!==this.secondConnection&&(this.secondConnection.stop(t),this.secondConnection=void 0);},t.prototype.stopSecondConnectionDelayed=function(){if(void 0!==this.secondConnection){var t=this.secondConnection;this.secondConnection=void 0,this.logger.info("Closing an inactive connection in "+Math.round(this.options.lingeringConnectionDelayMs/1e3)+"s"),setTimeout(function(){t.stop(!0);},this.options.lingeringConnectionDelayMs);}},t.prototype.forceStopLingeringConnection=function(){this.storedFirstConnection&&(this.storedFirstConnection.stop(!1),this.storedFirstConnection=void 0);},t.prototype.switchConnections=function(){var t=this.firstConnection;this.firstConnection=this.secondConnection,this.secondConnection=t;},t.prototype.doesSecondConnectionExist=function(){return void 0!==this.secondConnection},t.prototype.dispatchConnected=function(){if(void 0!==this.firstConnection){var t=this.firstConnection.getServerState(),e="/"===t.url.slice(-1)?t.url.slice(0,-1):t.url,n={baseEndpointUrl:e,newEndpointUrl:e!==this.baseEndpointUrl,c2cUrlBase:t.c2cUrlBase,clientId:t.connectedClientId,connectionId:t.connectionId,connectionTtlSec:t.getRemainingTtlInSec()};this.baseEndpointUrl=e,this.listener.onTrouterConnected(t.url,n);}},t.prototype.dispatchReconnecting=function(){this.listener.onTrouterDisconnected&&this.listener.onTrouterDisconnected();},t.prototype.dispatchStopped=function(){this.listener.onTrouterDisconnected&&this.listener.onTrouterDisconnected();},t.prototype.dispatchRegistrationState=function(t){this.options.registrationStateCallback&&this.options.registrationStateCallback(t);},t.prototype.onDownstreamRequest=function(t,e,n){var o={id:e.id,method:e.method,path:"/"+e.shortUrl,body:e.body,headers:e.headers},i={id:e.id,status:0,headers:{},body:"",send:function(){return i.status<=100||i.status>=999?3:(n.writeHead(i.status,i.headers),n.end(i.body))}};this.listener.onTrouterRequest(o,i);},t.prototype.onConnected=function(t){this.fsm.onConnected(t===this.firstConnection);},t.prototype.onRegistered=function(t){this.fsm.onRegistered(t===this.firstConnection);},t.prototype.onUnregistered=function(t){this.fsm.onUnregistered(t===this.firstConnection||t===this.storedFirstConnection);},t.prototype.onReconnecting=function(t){this.fsm.onReconnecting(t===this.firstConnection);},t.prototype.onReconnectIsRequired=function(t,e,n){this.fsm.onReconnectionRequired(t===this.firstConnection,e,n);},t.prototype.onDisconnected=function(t){this.fsm.onDisconnected(t===this.storedFirstConnection),this.storedFirstConnection=void 0;},t.prototype.onUserActivityStateAccepted=function(t){this.listener.onTrouterUserActivityStateAccepted&&this.listener.onTrouterUserActivityStateAccepted(t);},t.prototype.onConnectionParametersUpdated=function(t){this.setConnectionCache(t);},t.prototype.setUserActivityState=function(t,e){return this.userActivityObject=new u(t,r.CorrelationVector.extend(e)),void 0!==this.secondConnection?(this.logger.info("Setting user activity "+this.userActivityObject.toEventJSON()+" on the second/new connection"),void this.secondConnection.setUserActivityState(this.userActivityObject)):void 0!==this.firstConnection?(this.logger.info("Setting user activity "+this.userActivityObject.toEventJSON()+" on the first/current connection"),void this.firstConnection.setUserActivityState(this.userActivityObject)):void 0},t.prototype.onTrouterMessageLost=function(t){var e=this;if(this.listener.onTrouterMessageLoss)if(t&&t.length){var n=t.filter(function(t){return void 0!==e.processedMessageLoss[t.tag+"-"+t.etag]});if(n.length&&(this.logger.warn("onTrouterMessageLoss - removing duplicates and sending event to server"),this.sendProcessedDroppedIndicators(n),t=t.filter(function(t){return void 0===e.processedMessageLoss[t.tag+"-"+t.etag]}),!t.length))return void this.logger.warn("onTrouterMessageLoss - All the data are duplicated");var o=this.listener.onTrouterMessageLoss(t.map(function(t){return t.tag}));if(!o)return void this.logger.warn("onTrouterMessageLoss - flow tags have not been processed by listeners");t.forEach(function(t){e.processedMessageLoss[t.tag+"-"+t.etag]="";}),this.sendProcessedDroppedIndicators(t);}else this.logger.warn("onTrouterMessageLoss - no flow tags have been provided");},t.prototype.getConnectionCache=function(){var t=this;return this.options.connectionCache?(this.logger.debug("Querying host's connection cache"),this.options.connectionCache.onGetTrouterConnectionCache().then(function(t){return t?JSON.parse(t):void 0}).catch(function(e){return t.logger.warn("Invalid connection cache content provided: "+e),t.connectionCache})):Promise.resolve(this.connectionCache)},t.prototype.setConnectionCache=function(t){if(this.connectionCache=t,this.options.connectionCache)try{this.options.connectionCache.onSetTrouterConnectionCache(JSON.stringify(t));}catch(t){this.logger.warn("Error setting external connection cache: "+t);}},t.prototype.sendProcessedDroppedIndicators=function(t){return void 0!==this.firstConnection?void this.firstConnection.sendProcessedDroppedIndicators(t):void 0!==this.secondConnection?void this.secondConnection.sendProcessedDroppedIndicators(t):void 0},t}();e.TrouterManager=l;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function t(t){this.logger=t;}return t.prototype.getPromise=function(){var t=this;return void 0!==this.url?(this.logger.debug("[TrouterUrlPromise] returning previously resolved url: "+this.url),Promise.resolve(this.url)):(void 0===this.pendingPromise?(this.logger.debug("[TrouterUrlPromise] creating and returning promise"),this.pendingPromise=new Promise(function(e,n){t.pendingPromiseResolveRef=e,t.pendingPromiseRejectRef=n;})):this.logger.debug("[TrouterUrlPromise] returning existing promise"),this.pendingPromise)},t.prototype.resolveUrl=function(t){this.url=t,this.logger.debug("[TrouterUrlPromise] got url: "+this.url);var e=this.pendingPromiseResolveRef;this.pendingPromise=void 0,this.pendingPromiseResolveRef=void 0,this.pendingPromiseRejectRef=void 0,void 0!==e&&(this.logger.debug("[TrouterUrlPromise] resolving promise"),e(t));},t.prototype.rejectUrl=function(t){this.logger.debug("[TrouterUrlPromise] aborting");var e=this.pendingPromiseRejectRef;this.url=void 0,this.pendingPromise=void 0,this.pendingPromiseResolveRef=void 0,this.pendingPromiseRejectRef=void 0,void 0!==e&&(this.logger.debug("[TrouterUrlPromise] rejecting promise"),e(t));},t.prototype.resetUrl=function(){this.logger.debug("[TrouterUrlPromise] resetting url"),this.url=void 0;},t}();e.TrouterUrlPromise=o;},function(t,e,n){(function(t,n){!function(t,e){var n=t;n.version="0.9.6",n.protocol=1,n.transports=[],n.j=[],n.sockets={},n.connect=function(t,o){var i,r,s=n.util.parseUri(t);e&&e.location&&(s.protocol=s.protocol||e.location.protocol.slice(0,-1),s.host=s.host||(e.document?e.document.domain:e.location.hostname),s.port=s.port||e.location.port),i=n.util.uniqueUri(s);var c={host:s.host,secure:"https"==s.protocol,port:s.port||("https"==s.protocol?443:80),query:s.query||""};return n.util.merge(c,o),!c["force new connection"]&&n.sockets[i]||(r=new n.Socket(c)),!c["force new connection"]&&r&&(n.sockets[i]=r),r=r||n.sockets[i],r.of(s.path.length>1?s.path:"")};}(n.exports,void 0===t?window:t);var o=n.exports;!function(t,e){var n=t.util={},o=/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,i=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];n.parseUri=function(t){for(var e=o.exec(t||""),n={},r=14;r--;)n[i[r]]=e[r]||"";return n},n.uniqueUri=function(t){var n=t.protocol,o=t.host,i=t.port;return "document"in e?(o=o||document.domain,i=i||("https"==n&&"https:"!==document.location.protocol?443:document.location.port)):(o=o||"localhost",i||"https"!=n||(i=443)),(n||"http")+"://"+o+":"+(i||80)},n.query=function(t,e){var o=n.chunkQuery(t||""),i=[];n.merge(o,n.chunkQuery(e||""));for(var r in o)o.hasOwnProperty(r)&&i.push(r+"="+o[r]);return i.length?"?"+i.join("&"):""},n.chunkQuery=function(t){for(var e,n={},o=t.split("&"),i=0,r=o.length;i<r;++i)e=o[i].split("="),e[0]&&(n[e[0]]=e[1]);return n};var r=!1;n.load=function(t){if("document"in e&&"complete"===document.readyState||r)return t();n.on(e,"load",t,!1);},n.on=function(t,e,n,o){t.attachEvent?t.attachEvent("on"+e,n):t.addEventListener&&t.addEventListener(e,n,o);},n.request=function(t){if(t&&"undefined"!=typeof XDomainRequest)return new XDomainRequest;if("undefined"!=typeof XMLHttpRequest&&(!t||n.ua.hasCORS))return new XMLHttpRequest;if(!t)try{return new(window[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}return null},"undefined"!=typeof window&&n.load(function(){r=!0;}),n.defer=function(t){if(!n.ua.webkit||"undefined"!=typeof importScripts)return t();n.load(function(){setTimeout(t,100);});},n.merge=function(t,e,o,i){var r,s=i||[],c=void 0===o?2:o;for(r in e)e.hasOwnProperty(r)&&n.indexOf(s,r)<0&&("object"==typeof t[r]&&c?n.merge(t[r],e[r],c-1,s):(t[r]=e[r],s.push(e[r])));return t},n.mixin=function(t,e){n.merge(t.prototype,e.prototype);},n.inherit=function(t,e){function n(){}n.prototype=e.prototype,t.prototype=new n;},n.isArray=Array.isArray||function(t){return "[object Array]"===Object.prototype.toString.call(t)},n.intersect=function(t,e){for(var o=[],i=t.length>e.length?t:e,r=t.length>e.length?e:t,s=0,c=r.length;s<c;s++)~n.indexOf(i,r[s])&&o.push(r[s]);return o},n.indexOf=function(t,e,n){for(var o=t.length,n=n<0?n+o<0?0:n+o:n||0;n<o&&t[n]!==e;n++);return o<=n?-1:n},n.toArray=function(t){for(var e=[],n=0,o=t.length;n<o;n++)e.push(t[n]);return e},n.ua={},n.ua.hasCORS="undefined"!=typeof XMLHttpRequest&&function(){try{var t=new XMLHttpRequest;}catch(t){return !1}return void 0!=t.withCredentials}(),n.ua.webkit="undefined"!=typeof navigator&&/webkit/i.test(navigator.userAgent);}(void 0!==o?o:n.exports,void 0===t?window:t),function(t,e){function n(){}t.EventEmitter=n,n.prototype.on=function(t,n){return this.$events||(this.$events={}),this.$events[t]?e.util.isArray(this.$events[t])?this.$events[t].push(n):this.$events[t]=[this.$events[t],n]:this.$events[t]=n,this},n.prototype.addListener=n.prototype.on,n.prototype.once=function(t,e){function n(){o.removeListener(t,n),e.apply(this,arguments);}var o=this;return n.listener=e,this.on(t,n),this},n.prototype.removeListener=function(t,n){if(this.$events&&this.$events[t]){var o=this.$events[t];if(e.util.isArray(o)){for(var i=-1,r=0,s=o.length;r<s;r++)if(o[r]===n||o[r].listener&&o[r].listener===n){i=r;break}if(i<0)return this;o.splice(i,1),o.length||delete this.$events[t];}else (o===n||o.listener&&o.listener===n)&&delete this.$events[t];}return this},n.prototype.removeAllListeners=function(t){return this.$events&&this.$events[t]&&(this.$events[t]=null),this},n.prototype.listeners=function(t){return this.$events||(this.$events={}),this.$events[t]||(this.$events[t]=[]),e.util.isArray(this.$events[t])||(this.$events[t]=[this.$events[t]]),this.$events[t]},n.prototype.emit=function(t){if(!this.$events)return !1;var n=this.$events[t];if(!n)return !1;var o=Array.prototype.slice.call(arguments,1);if("function"==typeof n)n.apply(this,o);else {if(!e.util.isArray(n))return !1;for(var i=n.slice(),r=0,s=i.length;r<s;r++)i[r].apply(this,o);}return !0};}(void 0!==o?o:n.exports,void 0!==o?o:n.parent.exports),function(t,e){if(e&&e.parse)return t.JSON={parse:e.parse,stringify:e.stringify};throw new Error("JSON not available")}(void 0!==o?o:n.exports,"undefined"!=typeof JSON?JSON:void 0),function(t,e){var n=t.parser={},o=n.packets=["disconnect","connect","heartbeat","message","json","event","ack","error","noop"],i=n.reasons=["transport not supported","client not handshaken","unauthorized"],r=n.advice=["reconnect"],s=e.JSON,c=e.util.indexOf;n.encodePacket=function(t){var e=c(o,t.type),n=t.id||"",a=t.endpoint||"",h=t.ack,u=null;switch(t.type){case"error":var l=t.reason?c(i,t.reason):"",p=t.advice?c(r,t.advice):"";""===l&&""===p||(u=l+(""!==p?"+"+p:""));break;case"message":""!==t.data&&(u=t.data);break;case"event":var d={name:t.name};t.args&&t.args.length&&(d.args=t.args),u=s.stringify(d);break;case"json":u=s.stringify(t.data);break;case"connect":t.qs&&(u=t.qs);break;case"ack":u=t.ackId+(t.args&&t.args.length?"+"+s.stringify(t.args):"");}var g=[e,n+("data"==h?"+":""),a];return null!==u&&void 0!==u&&g.push(u),g.join(":")},n.encodePayload=function(t){var e="";if(1==t.length)return t[0];for(var n=0,o=t.length;n<o;n++){e+=""+t[n].length+""+t[n];}return e};var a=/([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;n.decodePacket=function(t){var e=t.match(a);if(!e)return {};var n=e[2]||"",t=e[5]||"",c={type:o[e[1]],endpoint:e[4]||""};switch(n&&(c.id=n,e[3]?c.ack="data":c.ack=!0),c.type){case"error":var e=t.split("+");c.reason=i[e[0]]||"",c.advice=r[e[1]]||"";break;case"message":c.data=t||"";break;case"event":try{var h=s.parse(t);c.name=h.name,c.args=h.args;}catch(t){}c.args=c.args||[];break;case"json":try{c.data=s.parse(t);}catch(t){}break;case"connect":c.qs=t||"";break;case"ack":var e=t.match(/^([0-9]+)(\+)?(.*)/);if(e&&(c.ackId=e[1],c.args=[],e[3]))try{c.args=e[3]?s.parse(e[3]):[];}catch(t){}break;case"disconnect":c.reason=t;}return c},n.decodePayload=function(t){if(""==t.charAt(0)){for(var e=[],o=1,i="";o<t.length;o++)""==t.charAt(o)?(e.push(n.decodePacket(t.substr(o+1).substr(0,i))),o+=Number(i)+1,i=""):i+=t.charAt(o);return e}return [n.decodePacket(t)]};}(void 0!==o?o:n.exports,void 0!==o?o:n.parent.exports),function(t,e){function n(t,e){this.socket=t,this.sessid=e,this.connectErrorCallback=void 0,this.isOpened=!1;}t.Transport=n,e.util.mixin(n,e.EventEmitter),n.prototype.onData=function(t){if(this.clearCloseTimeout(),(this.socket.connected||this.socket.connecting||this.socket.reconnecting)&&this.setCloseTimeout(),""!==t){var n=e.parser.decodePayload(t);if(n&&n.length)for(var o=0,i=n.length;o<i;o++)this.onPacket(n[o]);}return this},n.prototype.onPacket=function(t){return this.socket.setHeartbeatTimeout(),"heartbeat"==t.type?this.onHeartbeat():("connect"==t.type&&""==t.endpoint&&this.onConnect(),"error"==t.type&&"reconnect"==t.advice&&(this.isOpened=!1),this.socket.onPacket(t),this)},n.prototype.setCloseTimeout=function(){if(!this.closeTimeout){var t=this;this.closeTimeout=setTimeout(function(){t.onDisconnect();},this.socket.closeTimeout);}},n.prototype.onDisconnect=function(){return this.close&&this.isOpened&&this.close(),this.clearTimeouts(),this.socket.onDisconnect(),this},n.prototype.onConnect=function(){return this.socket.onConnect(),this.connectErrorCallback=void 0,this},n.prototype.clearCloseTimeout=function(){this.closeTimeout&&(clearTimeout(this.closeTimeout),this.closeTimeout=null);},n.prototype.clearTimeouts=function(){this.clearCloseTimeout(),this.reopenTimeout&&clearTimeout(this.reopenTimeout);},n.prototype.packet=function(t){this.send(e.parser.encodePacket(t));},n.prototype.onHeartbeat=function(t){this.packet({type:"heartbeat"});},n.prototype.onOpen=function(){this.isOpened=!0,this.clearCloseTimeout(),this.socket.onOpen();},n.prototype.onClose=function(){this.isOpened=!1,this.socket.onClose(),this.onDisconnect();},n.prototype.prepareUrl=function(){var t=this.socket.options;return this.scheme()+"://"+t.host+":"+t.port+"/"+t.resource+"/"+e.protocol+"/"+this.name+"/"+this.sessid},n.prototype.ready=function(t,e){e.call(this);},n.prototype.clearEventHandlers=function(){return this};}(void 0!==o?o:n.exports,void 0!==o?o:n.parent.exports),function(t,e,n){function o(t){if(this.options={port:80,secure:!1,document:"document"in n&&document,resource:"socket.io",transports:e.transports.slice(),"connect timeout":1e4,"try multiple transports":!0,reconnect:!0,"reconnection delay":500,"reconnection limit":1/0,"reopen delay":3e3,"max reconnection attempts":10,"sync disconnect on unload":!0,"auto connect":!0,"flash policy port":10843},e.util.merge(this.options,t),this.connected=!1,this.open=!1,this.connecting=!1,this.reconnecting=!1,this.namespaces={},this.buffer=[],this.doBuffer=!1,this.disconnected=!1,this.options["sync disconnect on unload"]&&(!this.isXDomain()||e.util.ua.hasCORS)){var o=this;e.util.on(n,"unload",function(){o.disconnectSync();},!1);}this.options["auto connect"]&&this.connect();}function i(){}t.Socket=o,e.util.mixin(o,e.EventEmitter),o.prototype.of=function(t){return this.namespaces[t]||(this.namespaces[t]=new e.SocketNamespace(this,t),""!==t&&this.namespaces[t].packet({type:"connect"})),this.namespaces[t]},o.prototype.publish=function(){this.emit.apply(this,arguments);var t;for(var e in this.namespaces)this.namespaces.hasOwnProperty(e)&&(t=this.of(e),t.$emit.apply(t,arguments));},o.prototype.handshake=function(t){function n(e){e instanceof Error?o.onError(e.message):t.apply(null,e.split(":"));}var o=this,r=this.options;if(!o.disconnected){var s=["http"+(r.secure?"s":"")+":/",r.host+":"+r.port,r.resource,e.protocol,e.util.query(this.options.query,"t="+ +new Date)].join("/");if(this.isXDomain()&&!e.util.ua.hasCORS){var c=document.getElementsByTagName("script")[0],a=document.createElement("script");a.src=s+"&jsonp="+e.j.length,c.parentNode.insertBefore(a,c),e.j.push(function(t){n(t),a.parentNode.removeChild(a);});}else {var h=e.util.request();h.open("GET",s,!0),h.onreadystatechange=function(){4==h.readyState&&(h.onreadystatechange=i,200==h.status?n(h.responseText):!o.reconnecting&&o.onError(h.responseText));},h.send(null);}}},o.prototype.getTransport=function(t){for(var n,o=t||this.transports,i=0;n=o[i];i++)if(e.Transport[n]&&e.Transport[n].check(this)&&(!this.isXDomain()||e.Transport[n].xdomainCheck()))return new e.Transport[n](this,this.sessionid);return null},o.prototype.connect=function(t){if(this.connecting||this.disconnected)return this;var n=this;return this.handshake(function(o,i,r,s){function c(){if(!n.connected&&!n.disconnected)if(n.connecting=!1,clearTimeout(n.connectTimeoutTimer),n.options["try multiple transports"]){for(;n.remainingTransports.length>0&&n.remainingTransports.splice(0,1)[0]!=n.transport.name;);n.remainingTransports.length?a(n.remainingTransports):n.publish("connect_failed");}else n.publish("connect_failed");}function a(t){if(n.transport&&(n.transport.clearTimeouts(),n.transport.clearEventHandlers()),n.transport=n.getTransport(t),!n.transport||n.disconnected)return n.publish("connect_failed");n.transport.ready(n,function(){n.connecting=!0,n.publish("connecting",n.transport.name),n.transport.open(c),n.options["connect timeout"]&&(n.connectTimeoutTimer=setTimeout(function(){c();},n.options["connect timeout"]));});}n.sessionid=o,n.closeTimeout=1e3*r+2e3,n.heartbeatTimeout=1e3*i+2e3,n.transports=s?e.util.intersect(s.split(","),n.options.transports):n.options.transports,n.setHeartbeatTimeout(),n.remainingTransports=n.transports.slice(0),a(n.transports),n.once("connect",function(){clearTimeout(n.connectTimeoutTimer),t&&"function"==typeof t&&t();});}),this},o.prototype.setHeartbeatTimeout=function(){clearTimeout(this.heartbeatTimeoutTimer);var t=this;this.heartbeatTimeoutTimer=setTimeout(function(){t.transport.onClose();},this.heartbeatTimeout);},o.prototype.packet=function(t){return this.connected&&!this.doBuffer?this.transport.packet(t):this.buffer.push(t),this},o.prototype.setBuffer=function(t){this.doBuffer=t,!t&&this.connected&&this.buffer.length&&(this.transport.payload(this.buffer),this.buffer=[]);},o.prototype.disconnect=function(){return (this.connected||this.connecting)&&(this.open&&this.of("").packet({type:"disconnect"}),this.onDisconnect("booted")),this.disconnected=!0,this},o.prototype.disconnectSync=function(){var t=e.util.request(),n=this.resource+"/"+e.protocol+"/"+this.sessionid;t.open("GET",n,!0),this.onDisconnect("booted");},o.prototype.isXDomain=function(){var t=n.location.port||("https:"==n.location.protocol?443:80);return this.options.host!==n.location.hostname||this.options.port!=t},o.prototype.onConnect=function(){this.connected||(this.connected=!0,this.connecting=!1,this.doBuffer||this.setBuffer(!1),this.emit("connect"));},o.prototype.onOpen=function(){this.open=!0;},o.prototype.onClose=function(){this.open=!1,clearTimeout(this.heartbeatTimeoutTimer);},o.prototype.onPacket=function(t){this.of(t.endpoint).onPacket(t);},o.prototype.onError=function(t){t&&t.advice&&"reconnect"===t.advice&&(this.connected||this.connecting)&&(this.disconnect(),this.options.reconnect&&this.reconnect()),this.publish("error",t&&t.reason?t.reason:t);},o.prototype.onDisconnect=function(t){var e=this.connected,n=this.connecting;this.connected=!1,this.connecting=!1,this.open=!1,(e||n)&&(this.transport.close(),this.transport.clearTimeouts(),e&&(this.publish("disconnect",t),"booted"!=t&&this.options.reconnect&&!this.reconnecting&&this.reconnect()));},o.prototype.reconnect=function(){function t(){if(n.connected){for(var t in n.namespaces)n.namespaces.hasOwnProperty(t)&&""!==t&&n.namespaces[t].packet({type:"connect"});n.publish("reconnect",n.transport.name,n.reconnectionAttempts);}clearTimeout(n.reconnectionTimer),n.removeListener("connect_failed",e),n.removeListener("connect",e),n.reconnecting=!1,delete n.reconnectionAttempts,delete n.reconnectionDelay,delete n.reconnectionTimer,delete n.redoTransports,n.options["try multiple transports"]=i;}function e(){if(n.reconnecting)return n.connected?t():n.connecting&&n.reconnecting?n.reconnectionTimer=setTimeout(e,1e3):void(n.reconnectionAttempts++>=o?n.redoTransports?(n.publish("reconnect_failed"),t()):(n.on("connect_failed",e),n.options["try multiple transports"]=!0,n.transport=n.getTransport(),n.redoTransports=!0,n.connect()):(n.reconnectionDelay<r&&(n.reconnectionDelay*=2),n.connect(),n.publish("reconnecting",n.reconnectionDelay,n.reconnectionAttempts),n.reconnectionTimer=setTimeout(e,n.reconnectionDelay)))}this.reconnecting=!0,this.reconnectionAttempts=0,this.reconnectionDelay=this.options["reconnection delay"];var n=this,o=this.options["max reconnection attempts"],i=this.options["try multiple transports"],r=this.options["reconnection limit"];this.options["try multiple transports"]=!1,this.reconnectionTimer=setTimeout(e,this.reconnectionDelay),this.on("connect",e);};}(void 0!==o?o:n.exports,void 0!==o?o:n.parent.exports,void 0===t?window:t),function(t,e){function n(t,e){this.socket=t,this.name=e||"",this.flags={},this.json=new o(this,"json"),this.ackPackets=0,this.acks={};}function o(t,e){this.namespace=t,this.name=e;}t.SocketNamespace=n,e.util.mixin(n,e.EventEmitter),n.prototype.$emit=e.EventEmitter.prototype.emit,n.prototype.of=function(){return this.socket.of.apply(this.socket,arguments)},n.prototype.packet=function(t){return t.endpoint=this.name,this.socket.packet(t),this.flags={},this},n.prototype.send=function(t,e){var n={type:this.flags.json?"json":"message",data:t};return "function"==typeof e&&(n.id=++this.ackPackets,n.ack=!0,this.acks[n.id]=e),this.packet(n)},n.prototype.emit=function(t){var e=Array.prototype.slice.call(arguments,1),n=e[e.length-1],o={type:"event",name:t};return "function"==typeof n&&(o.id=++this.ackPackets,o.ack="data",this.acks[o.id]=n,e=e.slice(0,e.length-1)),o.args=e,this.packet(o)},n.prototype.disconnect=function(){return ""===this.name?this.socket.disconnect():(this.packet({type:"disconnect"}),this.$emit("disconnect")),this},n.prototype.onPacket=function(t){function n(){o.packet({type:"ack",args:e.util.toArray(arguments),ackId:t.id});}var o=this;switch(t.type){case"connect":this.$emit("connect");break;case"disconnect":""===this.name?this.socket.onDisconnect(t.reason||"booted"):this.$emit("disconnect",t.reason||"");break;case"message":case"json":var i=["message",t.data];"data"==t.ack?i.push(n):t.ack&&this.packet({type:"ack",ackId:t.id}),this.$emit.apply(this,i);break;case"event":var i=[t.name].concat(t.args);"data"==t.ack&&i.push(n),this.$emit.apply(this,i);break;case"ack":this.acks[t.ackId]&&(this.acks[t.ackId].apply(this,t.args),delete this.acks[t.ackId]);break;case"error":t.advice?this.socket.onError(t):"unauthorized"==t.reason?this.$emit("connect_failed",t.reason):this.$emit("error",t.reason);}},o.prototype.send=function(){this.namespace.flags[this.name]=!0,this.namespace.send.apply(this.namespace,arguments);},o.prototype.emit=function(){this.namespace.flags[this.name]=!0,this.namespace.emit.apply(this.namespace,arguments);};}(void 0!==o?o:n.exports,void 0!==o?o:n.parent.exports),function(t,e,n){function o(t){e.Transport.apply(this,arguments);}function i(){}t.websocket=o,e.util.inherit(o,e.Transport),o.prototype.name="websocket",o.prototype.open=function(t){var o,i=e.util.query(this.socket.options.query),r=this;return this.connectErrorCallback=t,o||(o=n.MozWebSocket||n.WebSocket),this.websocket=new o(this.prepareUrl()+i),this.websocket.onopen=function(){r.onOpen(),r.socket.setBuffer(!1);},this.websocket.onmessage=function(t){r.onData(t.data);},this.websocket.onclose=function(){r.onClose(),r.socket.setBuffer(!0);},this.websocket.onerror=function(t){r.onError(t);},this},o.prototype.send=function(t){return this.websocket.send(t),this},o.prototype.payload=function(t){for(var e=0,n=t.length;e<n;e++)this.packet(t[e]);return this},o.prototype.close=function(){return this.websocket.close(),this},o.prototype.onError=function(t){void 0!==this.connectErrorCallback&&(this.connectErrorCallback(),this.connectErrorCallback=void 0),this.socket.onError(t);},o.prototype.scheme=function(){return this.socket.options.secure?"wss":"ws"},o.check=function(){return "WebSocket"in n&&!("__addTask"in WebSocket)||"MozWebSocket"in n},o.xdomainCheck=function(){return !0},o.prototype.clearEventHandlers=function(){return this.websocket&&(this.websocket.onopen=this.websocket.onmessage=this.websocket.onclose=this.websocket.onerror=i),this},e.transports.push("websocket");}(void 0!==o?o.Transport:n.exports,void 0!==o?o:n.parent.exports,void 0===t?window:t),function(t,e,n){function o(t){t&&(e.Transport.apply(this,arguments),this.sendBuffer=[]);}function i(){}t.XHR=o,e.util.inherit(o,e.Transport),o.prototype.open=function(){return this.socket.setBuffer(!1),this.onOpen(),this.get(),this.setCloseTimeout(),this},o.prototype.payload=function(t){for(var n=[],o=0,i=t.length;o<i;o++)n.push(e.parser.encodePacket(t[o]));this.send(e.parser.encodePayload(n));},o.prototype.send=function(t){return this.post(t),this},o.prototype.post=function(t){function e(){4==this.readyState&&(this.onreadystatechange=i,r.posting=!1,200==this.status?(r.socket.setBuffer(!1),clearTimeout(r.sendXHR.ackTimeoutTimer)):r.onClose());}function o(){this.onload=i,r.socket.setBuffer(!1);}var r=this;this.socket.setBuffer(!0),this.sendXHR=this.request("POST"),n.XDomainRequest&&this.sendXHR instanceof XDomainRequest?this.sendXHR.onload=this.sendXHR.onerror=o:this.sendXHR.onreadystatechange=e,this.sendXHR.send(t),r.sendXHR.ackTimeoutTimer=setTimeout(function(){r.onClose();},r.socket.options.ackTimeoutMs);},o.prototype.close=function(){return this.onClose(),this},o.prototype.request=function(t){var n=e.util.request(this.socket.isXDomain()),o=e.util.query(this.socket.options.query,"t="+ +new Date);if(n.open(t||"GET",this.prepareUrl()+o,!0),"POST"==t)try{n.setRequestHeader?n.setRequestHeader("Content-type","text/plain;charset=UTF-8"):n.contentType="text/plain";}catch(t){}return n},o.prototype.scheme=function(){return this.socket.options.secure?"https":"http"},o.check=function(t,o){try{var i=e.util.request(o),r=n.XDomainRequest&&i instanceof XDomainRequest,s=t&&t.options&&t.options.secure?"https:":"http:",c=s!=n.location.protocol;if(i&&(!r||!c))return !0}catch(t){}return !1},o.xdomainCheck=function(){return o.check(null,!0)},o.prototype.clearEventHandlers=function(){return this.sendXHR&&(this.sendXHR.onreadystatechange=this.sendXHR.onload=i),this};}(void 0!==o?o.Transport:n.exports,void 0!==o?o:n.parent.exports,void 0===t?window:t),function(t,e,n){function o(){e.Transport.XHR.apply(this,arguments);}function i(){}t["xhr-polling"]=o,e.util.inherit(o,e.Transport.XHR),e.util.merge(o,e.Transport.XHR),o.prototype.name="xhr-polling",o.prototype.open=function(t){var n=this;return n.connectErrorCallback=t,e.Transport.XHR.prototype.open.call(n),!1},o.prototype.get=function(){function t(){4==this.readyState&&(this.onreadystatechange=i,200==this.status?(r.connectErrorCallback=void 0,r.onData(this.responseText),r.get()):(r.onClose(),void 0!==r.connectErrorCallback&&(r.connectErrorCallback(),r.connectErrorCallback=void 0)));}function e(){r.connectErrorCallback=void 0,this.onload=i,this.onerror=i,r.onData(this.responseText),r.get();}function o(){r.onClose(),void 0!==r.connectErrorCallback&&(r.connectErrorCallback(),r.connectErrorCallback=void 0);}if(this.isOpened){var r=this;this.xhr=this.request(),n.XDomainRequest&&this.xhr instanceof XDomainRequest?(this.xhr.onload=e,this.xhr.onerror=o):this.xhr.onreadystatechange=t,this.xhr.send(null);}},o.prototype.onClose=function(){if(e.Transport.XHR.prototype.onClose.call(this),this.xhr){this.xhr.onreadystatechange=this.xhr.onload=this.xhr.onerror=i;try{this.xhr.abort();}catch(t){}this.xhr=null;}},o.prototype.ready=function(t,n){var o=this;e.util.defer(function(){n.call(o);});},o.prototype.clearEventHandlers=function(){return e.Transport.XHR.prototype.clearEventHandlers.call(this),this.xhr&&(this.xhr.onreadystatechange=this.xhr.onload=this.xhr.onerror=i),this},e.transports.push("xhr-polling");}(void 0!==o?o.Transport:n.exports,void 0!==o?o:n.parent.exports,void 0===t?window:t),e.io=o;}).call(e,n(4),n(14)(t));},function(t,e,n){(function(e,o){/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */
	!function(e,n){t.exports=n();}(0,function(){function t(t){return "function"==typeof t||"object"==typeof t&&null!==t}function i(t){return "function"==typeof t}function r(t){$=t;}function s(t){V=t;}function c(){return void 0!==X?function(){X(h);}:a()}function a(){var t=setTimeout;return function(){return t(h,1)}}function h(){for(var t=0;t<J;t+=2){(0, Y[t])(Y[t+1]),Y[t]=void 0,Y[t+1]=void 0;}J=0;}function u(t,e){var n=arguments,o=this,i=new this.constructor(p);void 0===i[tt]&&O(i);var r=o._state;return r?function(){var t=n[r-1];V(function(){return P(r,i,t,o._result)});}():b(o,i,t,e),i}function l(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return k(n,t),n}function p(){}function d(){return new TypeError("You cannot resolve a promise with itself")}function g(){return new TypeError("A promises callback cannot return that same promise.")}function f(t){try{return t.then}catch(t){return it.error=t,it}}function v(t,e,n,o){try{t.call(e,n,o);}catch(t){return t}}function m(t,e,n){V(function(t){var o=!1,i=v(n,e,function(n){o||(o=!0,e!==n?k(t,n):S(t,n));},function(e){o||(o=!0,C(t,e));},"Settle: "+(t._label||" unknown promise"));!o&&i&&(o=!0,C(t,i));},t);}function y(t,e){e._state===nt?S(t,e._result):e._state===ot?C(t,e._result):b(e,void 0,function(e){return k(t,e)},function(e){return C(t,e)});}function T(t,e,n){e.constructor===t.constructor&&n===u&&e.constructor.resolve===l?y(t,e):n===it?C(t,it.error):void 0===n?S(t,e):i(n)?m(t,e,n):S(t,e);}function k(e,n){e===n?C(e,d()):t(n)?T(e,n,f(n)):S(e,n);}function w(t){t._onerror&&t._onerror(t._result),R(t);}function S(t,e){t._state===et&&(t._result=e,t._state=nt,0!==t._subscribers.length&&V(R,t));}function C(t,e){t._state===et&&(t._state=ot,t._result=e,V(w,t));}function b(t,e,n,o){var i=t._subscribers,r=i.length;t._onerror=null,i[r]=e,i[r+nt]=n,i[r+ot]=o,0===r&&t._state&&V(R,t);}function R(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var o=void 0,i=void 0,r=t._result,s=0;s<e.length;s+=3)o=e[s],i=e[s+n],o?P(n,o,i,r):i(r);t._subscribers.length=0;}}function I(){this.error=null;}function E(t,e){try{return t(e)}catch(t){return rt.error=t,rt}}function P(t,e,n,o){var r=i(n),s=void 0,c=void 0,a=void 0,h=void 0;if(r){if(s=E(n,o),s===rt?(h=!0,c=s.error,s=null):a=!0,e===s)return void C(e,g())}else s=o,a=!0;e._state!==et||(r&&a?k(e,s):h?C(e,c):t===nt?S(e,s):t===ot&&C(e,s));}function U(t,e){try{e(function(e){k(t,e);},function(e){C(t,e);});}catch(e){C(t,e);}}function _(){return st++}function O(t){t[tt]=st++,t._state=void 0,t._result=void 0,t._subscribers=[];}function M(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[tt]||O(this.promise),F(e)?(this._input=e,this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(),0===this._remaining&&S(this.promise,this._result))):C(this.promise,A());}function A(){return new Error("Array Methods must be provided an Array")}function x(t){return new M(this,t).promise}function D(t){var e=this;return new e(F(t)?function(n,o){for(var i=t.length,r=0;r<i;r++)e.resolve(t[r]).then(n,o);}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function L(t){var e=this,n=new e(p);return C(n,t),n}function N(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function q(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function j(t){this[tt]=_(),this._result=this._state=void 0,this._subscribers=[],p!==t&&("function"!=typeof t&&N(),this instanceof j?U(this,t):q());}function H(){var t=void 0;if(void 0!==o)t=o;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")();}catch(t){throw new Error("polyfill failed because global object is unavailable in this environment")}var e=t.Promise;if(e){var n=null;try{n=Object.prototype.toString.call(e.resolve());}catch(t){}if("[object Promise]"===n&&!e.cast)return}t.Promise=j;}var B=void 0;B=Array.isArray?Array.isArray:function(t){return "[object Array]"===Object.prototype.toString.call(t)};var F=B,J=0,X=void 0,$=void 0,V=function(t,e){Y[J]=t,Y[J+1]=e,2===(J+=2)&&($?$(h):Z());},G="undefined"!=typeof window?window:void 0,K=G||{},W=K.MutationObserver||K.WebKitMutationObserver,z="undefined"==typeof self&&void 0!==e&&"[object process]"==={}.toString.call(e),Q="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,Y=new Array(1e3),Z=void 0;Z=z?function(){return function(){return e.nextTick(h)}}():W?function(){var t=0,e=new W(h),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2;}}():Q?function(){var t=new MessageChannel;return t.port1.onmessage=h,function(){return t.port2.postMessage(0)}}():void 0===G?function(){try{var t=n(21);return X=t.runOnLoop||t.runOnContext,c()}catch(t){return a()}}():a();var tt=Math.random().toString(36).substring(16),et=void 0,nt=1,ot=2,it=new I,rt=new I,st=0;return M.prototype._enumerate=function(){for(var t=this.length,e=this._input,n=0;this._state===et&&n<t;n++)this._eachEntry(e[n],n);},M.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,o=n.resolve;if(o===l){var i=f(t);if(i===u&&t._state!==et)this._settledAt(t._state,e,t._result);else if("function"!=typeof i)this._remaining--,this._result[e]=t;else if(n===j){var r=new n(p);T(r,t,i),this._willSettleAt(r,e);}else this._willSettleAt(new n(function(e){return e(t)}),e);}else this._willSettleAt(o(t),e);},M.prototype._settledAt=function(t,e,n){var o=this.promise;o._state===et&&(this._remaining--,t===ot?C(o,n):this._result[e]=n),0===this._remaining&&S(o,this._result);},M.prototype._willSettleAt=function(t,e){var n=this;b(t,void 0,function(t){return n._settledAt(nt,e,t)},function(t){return n._settledAt(ot,e,t)});},j.all=x,j.race=D,j.resolve=l,j.reject=L,j._setScheduler=r,j._setAsap=s,j._asap=V,j.prototype={constructor:j,then:u,catch:function(t){return this.then(null,t)}},j.polyfill=H,j.Promise=j,j});}).call(e,n(13),n(4));},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function i(t){if(u===setTimeout)return setTimeout(t,0);if((u===n||!u)&&setTimeout)return u=setTimeout,setTimeout(t,0);try{return u(t,0)}catch(e){try{return u.call(null,t,0)}catch(e){return u.call(this,t,0)}}}function r(t){if(l===clearTimeout)return clearTimeout(t);if((l===o||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(e){try{return l.call(null,t)}catch(e){return l.call(this,t)}}}function s(){f&&d&&(f=!1,d.length?g=d.concat(g):v=-1,g.length&&c());}function c(){if(!f){var t=i(s);f=!0;for(var e=g.length;e;){for(d=g,g=[];++v<e;)d&&d[v].run();v=-1,e=g.length;}d=null,f=!1,r(t);}}function a(t,e){this.fun=t,this.array=e;}function h(){}var u,l,p=t.exports={};!function(){try{u="function"==typeof setTimeout?setTimeout:n;}catch(t){u=n;}try{l="function"==typeof clearTimeout?clearTimeout:o;}catch(t){l=o;}}();var d,g=[],f=!1,v=-1;p.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];g.push(new a(t,e)),1!==g.length||f||i(c);},a.prototype.run=function(){this.fun.apply(null,this.array);},p.title="browser",p.browser=!0,p.env={},p.argv=[],p.version="",p.versions={},p.on=h,p.addListener=h,p.once=h,p.off=h,p.removeListener=h,p.removeAllListeners=h,p.emit=h,p.prependListener=h,p.prependOnceListener=h,p.listeners=function(t){return []},p.binding=function(t){throw new Error("process.binding is not supported")},p.cwd=function(){return "/"},p.chdir=function(t){throw new Error("process.chdir is not supported")},p.umask=function(){return 0};},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t};},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(3),i=n(1),r=n(0),s=function(){function t(t){this.id=t,this.status=200,this.headers={},this.body="";}return t}();e.ResponseData=s;var c;!function(t){t.Connected="trouter_js_client_connected",t.Disconnected="trouter_js_client_disconnected",t.Error="trouter_js_client_error",t.Progress="trouter_js_client_progress",t.Response="trouter_js_client_response",t.Request="trouter_js_client_request",t.CheckConnection="trouter_js_client_check_connection",t.Registration="trouter_js_client_registration",t.Unregistration="trouter_js_client_unregistration";}(c=e.ClientEventName||(e.ClientEventName={}));var a=function(){function t(t,e,n,o,i){this.stepName=t,this.operation=e,this.delta=n,this.ts=o,this.error=i;}return t}();e.TrackerStep=a;var h=function(){function t(){}return t}();e.Properties=h;var u=function(){function t(){this.numberOfPingReplies=0,this.connectedTimestamp=0,this.isNewUrl=!1,this.transportType="",this.connectionNumber=0;}return t}(),l=function(){function t(){this.enabled=!1,this.numberOfStepsToMaintain=40,this.logHealthCheckError=!1,this.sendProgressTimeoutSecs=55,this.logSendPingError=!1,this.maxBackoffInMs=12e4,this.trouter_js_client_connected=!1,this.trouter_js_client_disconnected=!1,this.trouter_js_client_error=!1,this.trouter_js_client_progress=!1,this.trouter_js_client_response=!1,this.trouter_js_client_request=!1,this.trouter_js_client_registration=!1,this.trouter_js_client_unregistration=!1,this.trouter_js_client_check_connection=!0;}return t}(),p=function(){function t(t,e,n,i,s,c,a){this.clientId=e,this.clientInfo=n,this.getServerState=i,this.endpointId=s,this.clientCorrelationID=c,this.environment=a,this.logger=new r.Logger("ConnectionTracker",t),this.clientCorrelationID=void 0!==c?c:"",this.steps=[],this.connectionAttempt=0,this.totalStepCount=0,this.beginTimestamp=new o.Timespan,this.eventLogSettings=new l,this.connectedInfo=new u;}return t.prototype.enable=function(t){this.eventLogSettings.enabled=!0,this.eventLogger=t;},t.prototype.disable=function(){this.eventLogSettings.enabled=!1;},t.prototype.sendProgress=function(t){this.steps.length>0&&this.sendTelemetry(c.Progress,t,this.steps);},t.prototype.cancelProgressTimer=function(){void 0!==this.progressTimeout&&(clearTimeout(this.progressTimeout),this.progressTimeout=void 0);},t.prototype.resetProgressSendTimer=function(){var t=this;this.cancelProgressTimer(),void 0!==this.eventLogSettings.sendProgressTimeoutSecs&&this.eventLogSettings.sendProgressTimeoutSecs>0&&(this.progressTimeout=setTimeout(function(){t.sendProgress({reason:"timeout",timeoutSecs:t.eventLogSettings.sendProgressTimeoutSecs});},1e3*this.eventLogSettings.sendProgressTimeoutSecs));},t.prototype.setConnectedInfo=function(t,e){this.connectedInfo.numberOfPingReplies=0,this.connectedInfo.connectedTimestamp=Date.now(),this.connectedInfo.isNewUrl=t,this.connectedInfo.transportType=e,++this.connectedInfo.connectionNumber;},t.prototype.clearConnectedInfo=function(){this.connectedInfo.numberOfPingReplies=0,this.connectedInfo.connectedTimestamp=0,this.connectedInfo.isNewUrl=!0,this.connectedInfo.transportType="";},t.prototype.copyProperties=function(t,e){for(var n=0,o=Object.keys(e);n<o.length;n++){var i=o[n];e.hasOwnProperty(i)&&void 0!==e[i]&&(t[i.replace(/-/g,"_")]={value:e[i]});}},t.prototype.increasePingResponseCount=function(){++this.connectedInfo.numberOfPingReplies;},t.prototype.sendTelemetry=function(t,e,n){try{if(!0===this.eventLogSettings.enabled&&!0===this.eventLogSettings[t]&&void 0!==this.eventLogger){var r=this.getServerState(),s={name:t,properties:{connectionAttempt:{value:this.connectionAttempt},epid:{value:this.endpointId},clientCorrelationID:{value:this.clientCorrelationID},steps:{value:o.toJson(n)},clientID:{value:this.clientId},eventVersion:{value:3},environment:{value:this.environment},cv:{value:i.CLIENT_VERSION},ua:{value:this.clientInfo.ua},connectionId:{value:r.connectionId},connectedClientId:{value:r.connectedClientId},domId:{value:r.domId},url:{value:r.unsecureUrl},surl:{value:r.url},ttlInSecs:{value:r.getRemainingTtlInSec()},numberOfPingReplies:{value:this.connectedInfo.numberOfPingReplies},connectedTimestamp:{value:this.connectedInfo.connectedTimestamp},isNewUrl:{value:this.connectedInfo.isNewUrl},transportType:{value:this.connectedInfo.transportType},connectionNumber:{value:this.connectedInfo.connectionNumber}}};this.copyProperties(s.properties,e),this.eventLogger.logEvent(s);}}catch(e){this.logger.warn("error in sending event "+t+": "+o.toJson(e));}},t.prototype.createStep=function(t,e,n){return new a(t,e,this.beginTimestamp.duration,Date.now(),n)},t.prototype.addStep=function(t,e,n){if(!1!==this.eventLogSettings.enabled&&(0===this.steps.length&&this.beginTimestamp.reset(),this.steps.push(this.createStep(t,e,n)),++this.totalStepCount,void 0!==this.eventLogSettings.numberOfStepsToMaintain&&this.steps.length>this.eventLogSettings.numberOfStepsToMaintain)){var o=this.steps.slice(0);this.steps.length=0,this.sendTelemetry(c.Progress,{reason:"flush"},o);}},t.prototype.trackStart=function(t){this.addStep(t,"start");},t.prototype.trackEnd=function(t){this.addStep(t,"end");},t.prototype.trackError=function(t,e,n,o){void 0===n&&(n=!0),"health"===t&&!0!==this.eventLogSettings.logHealthCheckError||"ping"===t&&!1===this.eventLogSettings.logSendPingError||(void 0===o&&(o="error"),!0===n&&this.addStep(t,o,e),this.sendTelemetry(c.Error,{},[this.createStep(t,o,e)]));},t.prototype.trackProgress=function(t,e){this.addStep(t,e);},t.prototype.trackConnected=function(t,e){this.setConnectedInfo(t,e);var n=this.steps.slice(0),o=this.totalStepCount,i=this.beginTimestamp.duration;this.steps.length=0,this.totalStepCount=0,this.sendTelemetry(c.Connected,{stepCount:n.length,totalStepCount:o,connectionEstablishmentMs_Total:i},n),this.cancelProgressTimer();},t.prototype.getSessionLength=function(){return Date.now()-this.connectedInfo.connectedTimestamp},t.prototype.trackDisconnected=function(t){t.sessionLengthMS=this.getSessionLength(),this.sendTelemetry(c.Disconnected,t,[]),this.resetProgressSendTimer();},t.prototype.trackNewConnection=function(){++this.connectionAttempt;},t.prototype.trackRequest=function(t,e){var n={};void 0!==e&&(n.hasError=!0,n.error=e);try{if(t){n.requestID=t.id,n.httpMethod=t.method,n.url=t.url,n.bodyLength=t.body.length,n.shortUrl=t.shortUrl,n.requestTimeStamp=t.startTS,n.correlationVector=t.correlationVector;for(var i=t.headers,r=0,s=Object.keys(i);r<s.length;r++){var a=s[r];i.hasOwnProperty(a)&&(n[a]=i[a]);}}}catch(t){n.hasError=!0,n.error=n.error+" error creating request context "+o.toJson(t);}this.sendTelemetry(c.Request,n,[]);},t.prototype.trackResponse=function(t,e,n,i){var r={};void 0!==i&&(r.hasError=!0,r.error=i);try{if(r.responseTimestamp=void 0!==n?n.sentTS:Date.now(),t){r.requestID=t.id,r.httpMethod=t.method,r.shortUrl=t.shortUrl,r.correlationVector=t.correlationVector;for(var s=t.headers,a=0,h=Object.keys(s);a<h.length;a++){var u=h[a];s.hasOwnProperty(u)&&(r[u]=s[u]);}}n&&(r.latencyMS=e,r.responseCode=n.status,r.responseLength=n.body.length);}catch(t){r.hasError=!0,r.error=r.error+" error creating response context "+o.toJson(t);}this.sendTelemetry(c.Response,r,[]);},t.prototype.sendResponseError=function(t,e,n){this.trackResponse(e,void 0,n,t);},t.prototype.close=function(){this.sendProgress({reason:"closed"}),this.steps.length=0,this.cancelProgressTimer();},t.prototype.mergeSettings=function(t){if(t){this.eventLogSettings.numberOfStepsToMaintain=Math.min(40,Math.max(10,void 0!==t.numberOfStepsToMaintain?t.numberOfStepsToMaintain:0));var e=Math.min(3600,Math.max(55,void 0!==t.sendProgressTimeoutSecs?t.sendProgressTimeoutSecs:0));this.eventLogSettings.logHealthCheckError=t.logHealthCheckError,this.eventLogSettings.logSendPingError=t.logSendPingError;for(var n=0,o=Object.keys(c).map(function(t){return c[t]});n<o.length;n++){var i=o[n];t.hasOwnProperty(i)&&void 0!==t[i]&&(this.eventLogSettings[i]=t[i]);}this.eventLogSettings.sendProgressTimeoutSecs!==e&&(this.eventLogSettings.sendProgressTimeoutSecs=e,this.resetProgressSendTimer());}},t}();e.ConnectionTracker=p;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function t(t,e){this.logger=t,this.maxBackoffInMs=e,this.backoffId=0,this.backoffCount=0;}return t.calculateNextBackoffMs=function(t,e){var n=1+.4*(Math.random()-.5),o=1e3*Math.pow(2,t)*n;return o=Math.round(o),Math.min(e,o)},t.prototype.setMaxBackoffMs=function(t){this.maxBackoffInMs=t;},t.prototype.backoff=function(e,n){var o=this;void 0!==this.timerHandle&&(this.logger.debug("Clearing current back off"),clearTimeout(this.timerHandle),this.timerHandle=void 0);var i=t.calculateNextBackoffMs(this.backoffCount,this.maxBackoffInMs);this.backoffId++,this.backoffCount++,this.logger.info("Backing off "+e+" for "+i+" milliseconds with ID "+this.backoffId),this.callback=function(){o.logger.info("Back off for "+e+" with ID "+o.backoffId+" complete, invoking handler"),o.timerHandle=void 0,o.callback=void 0,n();},this.timerHandle=setTimeout(this.callback,i);},t.prototype.reset=function(){void 0!==this.timerHandle&&(this.logger.debug("Resetting back off with ID "+this.backoffId),clearTimeout(this.timerHandle),this.timerHandle=void 0,this.callback=void 0),this.backoffCount=0;},t.prototype.expediteIfPending=function(){if(this.backoffCount=0,void 0!==this.timerHandle){this.logger.debug("Expediting back off with ID "+this.backoffId),clearTimeout(this.timerHandle),this.timerHandle=void 0;var t=this.callback;this.callback=void 0,t&&t();}},t}();e.ExponentialBackoff=o;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o,i=n(5),r=n(0);!function(t){t[t.Initial=0]="Initial",t[t.RetrievingToken=1]="RetrievingToken",t[t.Allocating=2]="Allocating",t[t.Handshaking=3]="Handshaking",t[t.Connecting=4]="Connecting",t[t.Connected=5]="Connected",t[t.UnregisteringRetrievingToken=6]="UnregisteringRetrievingToken",t[t.Unregistering=7]="Unregistering",t[t.TerminalError=8]="TerminalError";}(o=e.State||(e.State={}));var s;!function(t){t[t.Initial=0]="Initial",t[t.RetrievingToken=1]="RetrievingToken",t[t.Registering=2]="Registering",t[t.Registered=3]="Registered",t[t.NotRegistered=4]="NotRegistered";}(s||(s={}));var c=function(){function t(t,e,n){this.worker=e,this.incallModeEnabled=n,this.state=o.Initial,this.autoReconnect=!0,this.logger=new r.Logger("ConnectionFsm",t),this.connectedSubstate=s.Initial;}return t.prototype.getState=function(){return this.state},t.prototype.isActive=function(){return this.state===o.Allocating||this.state===o.Connected||this.state===o.Handshaking||this.state===o.Connecting||this.state===o.RetrievingToken},t.prototype.start=function(){return this.state===o.Initial?(this.setState(o.RetrievingToken),this.worker.getToken(!0,!1),!0):(this.showIgnored("start"),!1)},t.prototype.stop=function(t){t&&(this.connectedSubstate=s.Initial),this.worker.isIncallMode()&&this.worker.exitIncallMode(),this.worker.resetTokenBackoff(),this.worker.resetRegisterBackoff(),this.worker.stopConnectionTimer(),this.worker.stopPingTimer(),this.worker.clearTimers(),this.worker.stopRegisterTimer(),this.state!==o.Connecting&&this.state!==o.Handshaking&&this.state!==o.Connected||(this.worker.stopSocketIo(),this.state===o.Connected&&this.worker.sendDisconnectTelemetryEvent("connection stopped")),this.isRegistered()&&this.state!==o.UnregisteringRetrievingToken&&this.state!==o.Unregistering?(this.setState(o.UnregisteringRetrievingToken),this.worker.getToken(!0,!1)):(this.setState(o.Initial),this.worker.dispatchDisconnected());},t.prototype.onTokenReceived=function(t){this.state===o.RetrievingToken?(this.setState(o.Allocating),this.worker.startConnectionTimer(),this.worker.sendAllocateRequest(t)):this.state===o.Connected&&this.connectedSubstate===s.RetrievingToken?(this.connectedSubstate=s.Registering,this.worker.sendRegisterRequest()):this.state===o.UnregisteringRetrievingToken?(this.setState(o.Unregistering),this.worker.sendUnregisterRequest()):this.showIgnored("onTokenReceived");},t.prototype.checkConnection=function(t){t&&this.onPingInterval();},t.prototype.onAllocationSucceed=function(){return this.state===o.Allocating?(this.setState(o.Handshaking),this.connectedSubstate===s.Registered&&this.worker.dispatchUnregistered(),this.connectedSubstate=s.Initial,this.worker.startSocketIo(),!0):(this.showIgnored("onAllocationSucceed"),!1)},t.prototype.onAllocationFailed=function(t){this.state===o.Allocating?(this.setState(o.RetrievingToken),this.worker.stopConnectionTimer(),this.worker.getToken(!t,!0)):this.showIgnored("onAllocationFailed");},t.prototype.onConnectingTimeout=function(){this.state===o.Allocating||this.state===o.Connecting||this.state===o.Handshaking?(this.setState(o.RetrievingToken),this.worker.stopSocketIo(),this.worker.getToken(!0,!1)):this.showIgnored("onConnectingTimeout");},t.prototype.onConnecting=function(){this.state===o.Handshaking?this.setState(o.Connecting):this.showIgnored("onConnecting");},t.prototype.onConnectingFailed=function(){this.state===o.Connecting?this.onConnectingTimeout():this.state===o.Handshaking?(this.logger.error("Unexpected error in Socket.io - no valid transports"),this.onConnectingTimeout()):this.showIgnored("onConnectingFailed");},t.prototype.onSocketDisconnect=function(t){this.state===o.Handshaking||this.state===o.Connected?(this.worker.stopSocketIo(),this.worker.stopPingTimer(),this.worker.clearTimers(),this.worker.stopConnectionTimer(),this.state===o.Connected&&this.worker.sendDisconnectTelemetryEvent(t),this.autoReconnect?(this.setState(o.RetrievingToken),this.worker.resetRegisterBackoff(),this.worker.dispatchReconnecting(),this.worker.getToken(!0,!1)):(this.logger.debug("Socket error/disconnect occurred and automatic reconnect is disabled. Connection will stop."),this.stop(!0))):this.showIgnored("onSocketDisconnect");},t.prototype.onTrouterConnected=function(){this.state===o.Connecting?(this.setState(o.Connected),this.worker.resetTokenBackoff(),this.worker.stopConnectionTimer(),this.worker.sendUserActivityState(i.UserActivityEventReason.Connected,!0),this.worker.startPingTimer(),this.worker.dispatchConnected(),this.worker.shouldSkipRegistration()?(this.connectedSubstate=s.NotRegistered,this.worker.dispatchRegistered()):(this.connectedSubstate=s.RetrievingToken,this.worker.getToken(!0,!1))):this.showIgnored("onTrouterConnected");},t.prototype.onReconnectRequired=function(t,e){this.worker.dispatchReconnectIsRequired(t,e);},t.prototype.disableAutoReconnect=function(){this.autoReconnect=!1;},t.prototype.onDownstreamRequest=function(t){this.state===o.Connected?(this.switchToIncallModeIfEnabled(),this.worker.dispatchDownstreamRequest(t)):this.showIgnored("onDownstreamRequest");},t.prototype.onTrouterMessageLost=function(t){this.state===o.Connected?this.worker.dispatchTrouterMessageLost(t):this.showIgnored("onTrouterMessageLost");},t.prototype.onPingInterval=function(){this.state===o.Connected?this.worker.sendPingRequest():this.showIgnored("onPingInterval");},t.prototype.onPingResponseTimeout=function(){this.onMissedResponse("onPingResponseTimeout");},t.prototype.onPingResponse=function(){this.state===o.Connected||this.showIgnored("onPingResponse");},t.prototype.onRegistrationFailed=function(t){this.state===o.Connected&&this.connectedSubstate===s.Registering?(this.connectedSubstate=s.RetrievingToken,this.worker.getToken(!t,!0)):this.showIgnored("onRegistrationFailed");},t.prototype.onRegistrationSucceed=function(t){this.state===o.Connected?(this.connectedSubstate===s.Registering&&(this.connectedSubstate=s.Registered,this.worker.dispatchRegistered()),t&&this.worker.startRegisterTimer()):this.showIgnored("onRegistrationSucceed");},t.prototype.onRegistrationTimeout=function(){this.state===o.Connected&&this.connectedSubstate!==s.NotRegistered?(this.connectedSubstate=s.RetrievingToken,this.worker.getToken(!0,!1)):this.showIgnored("onRegistrationTimeout");},t.prototype.onUnregistrationFailed=function(t){this.state===o.Unregistering?(this.setState(o.UnregisteringRetrievingToken),this.worker.getToken(!t,!t)):this.showIgnored("onUnregistrationFailed");},t.prototype.onUnregistrationSucceed=function(){this.state===o.Unregistering?(this.setState(o.Initial),this.worker.dispatchUnregistered(),this.worker.dispatchDisconnected()):this.showIgnored("onUnregistrationSucceed");},t.prototype.onIncallModeTimer=function(){this.worker.exitIncallMode(),this.state===o.Connected?(this.worker.stopPingTimer(),this.worker.startPingTimer()):this.showIgnored("onIncallModeTimer");},t.prototype.onSetUserActivityState=function(t,e){e?(this.logger.info("Changing user activity state to '"+t.toEventJSON()+"'"),this.worker.sendUserActivityState(i.UserActivityEventReason.Modified,this.state===o.Connected)):this.logger.debug("Not changing the same user activity state '"+t.toEventJSON()+"'");},t.prototype.onActivityStateResponseTimeout=function(){this.onMissedResponse("onActivityStateResponseTimeout");},t.prototype.forceReconnect=function(t){this.state===o.Connected&&this.worker.sendDisconnectTelemetryEvent(t),this.setState(o.RetrievingToken),this.worker.resetTokenBackoff(),this.worker.stopConnectionTimer(),this.worker.resetRegisterBackoff(),this.worker.stopPingTimer(),this.worker.clearTimers(),this.worker.stopSocketIo(),this.worker.dispatchReconnecting(),this.worker.getToken(!0,!1);},t.prototype.onTerminalError=function(){this.logger.error("Cannot proceed, reached terminal state. Switching from state '"+o[this.state]+"' to "+o[o.TerminalError]),this.setState(o.TerminalError);},t.prototype.onMissedResponse=function(t){this.state===o.Connected?(this.setState(o.RetrievingToken),this.worker.resetRegisterBackoff(),this.worker.stopPingTimer(),this.worker.clearTimers(),this.worker.stopSocketIo(),this.worker.sendDisconnectTelemetryEvent(t),this.worker.dispatchReconnecting(),this.worker.getToken(!0,!1)):this.showIgnored(t);},t.prototype.showIgnored=function(t){this.logger.debug("Ignoring event '"+t+"' in state '"+o[this.state]+"'");},t.prototype.setState=function(t){if(this.logger.info("Switching from state '"+o[this.state]+"' to state '"+o[t]+"'"),this.state===t)return void this.logger.error("Attempt to switching into the current state '"+o[t]+"'");this.state=t;},t.prototype.isRegistered=function(){return this.connectedSubstate===s.Registered||this.connectedSubstate===s.Registering},t.prototype.switchToIncallModeIfEnabled=function(){this.incallModeEnabled&&(this.worker.isIncallMode()||(this.worker.enterIncallMode(),this.worker.stopPingTimer(),this.worker.startPingTimer()),this.worker.restartIncallModeTimer());},t}();e.TrouterFsm=c;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(2),i=n(0),r=n(6),s=function(){function t(t,e){this.worker=e,this.state=o.TrouterState.Unknown,this.logger=new i.Logger("ManagerFsm",t);}return t.prototype.start=function(){this.state===o.TrouterState.Unknown?(this.setState(o.TrouterState.Disconnected),this.worker.forceStopLingeringConnection(),this.worker.startFirstConnection()):this.showIgnored("start");},t.prototype.stop=function(t){this.state!==o.TrouterState.Unknown?(this.setState(o.TrouterState.Unknown),this.worker.stopFirstConnection(!0===t),this.worker.stopSecondConnection(!0===t)):this.showIgnored("stop");},t.prototype.getState=function(){return this.state},t.prototype.onConnected=function(t){this.state===o.TrouterState.Disconnected&&t?this.worker.doesSecondConnectionExist()?this.setState(o.TrouterState.Switching):(this.setState(o.TrouterState.Connected),this.worker.dispatchConnected()):this.showIgnored("onConnected("+t+")");},t.prototype.onRegistered=function(t){this.state!==o.TrouterState.Disconnected||t?this.state!==o.TrouterState.Switching||t||(this.setState(o.TrouterState.Connected),this.worker.switchConnections(),this.worker.stopSecondConnectionDelayed(),this.worker.dispatchConnected()):(this.setState(o.TrouterState.Connected),this.worker.switchConnections(),this.worker.stopSecondConnection(!0),this.worker.dispatchConnected()),this.worker.dispatchRegistrationState(!0);},t.prototype.onUnregistered=function(t){t&&this.worker.dispatchRegistrationState(!1);},t.prototype.onReconnecting=function(t){this.state===o.TrouterState.Connected&&t?(this.setState(o.TrouterState.Disconnected),this.worker.dispatchReconnecting()):this.state===o.TrouterState.Switching&&t?(this.setState(o.TrouterState.Disconnected),this.worker.dispatchReconnecting()):this.showIgnored("onReconnecting("+t+")");},t.prototype.onReconnectionRequired=function(t,e,n){this.state===o.TrouterState.Connected&&t?(this.setState(o.TrouterState.Switching),this.worker.startSecondConnection(e)):this.state===o.TrouterState.Disconnected&&t?this.worker.startSecondConnection(e):this.state===o.TrouterState.Switching&&t&&n===r.ReconnectReason.Configuration?(this.logger.debug("onReconnectionRequired: switch requested while already in Switching state"),this.worker.stopSecondConnection(!0),this.worker.startSecondConnection(e)):this.showIgnored("onReconnectionRequired("+t+")");},t.prototype.onDisconnected=function(t){this.state===o.TrouterState.Unknown&&t?this.worker.dispatchStopped():this.showIgnored("onDisconnected("+t+")");},t.prototype.showIgnored=function(t){this.logger.info("Ignoring event '"+t+"' in state '"+o.TrouterState[this.state]+"'");},t.prototype.setState=function(t){if(this.logger.info("Switching from state '"+o.TrouterState[this.state]+"' to state '"+o.TrouterState[t]+"'"),this.state===t)return void this.logger.error("Attempt to switching into the current state '"+o.TrouterState[t]+"'");this.state=t;},t}();e.TrouterManagerFsm=s;},function(t,e,n){function o(t,e){if(!e)return t;var n=a({},t,{enabled:e.TelemetryEnabled});return void 0!==e.ClientTelemetryEventEnabled&&(n=a({},n,e.ClientTelemetryEventEnabled)),n}function i(t,e){return {clientInfo:{ua:t.trouterSettings.productName,v:t.trouterSettings.version},ioOptions:{ackTimeoutMs:5e3},clientCorrelationID:t.trouterSettings.sessionId,environment:t.trouterSettings.environment,telemetrySettings:o(t.telemetryConfig.settings,e),eventLogger:t.telemetryConfig.eventLogger,endpointId:t.trouterSettings.registrationId,trouterUrl:e&&e.TrouterConnectionUrl||t.trouterSettings.trouterServiceUrl,registration:t.trouterSettings.registrarServiceUrl?{registrarUrl:t.trouterSettings.registrarServiceUrl,registrationId:t.trouterSettings.registrationId||"",pnhAppId:t.trouterSettings.pnhAppId||"",platform:t.trouterSettings.platform||"",pnhTemplateKey:t.trouterSettings.pnhTemplate||"",platformUIVersion:t.trouterSettings.platformUIVersion||"",productContext:t.trouterSettings.pnhProductContext||void 0,context:t.trouterSettings.pnhContext||"",registrarTtlSec:(t.trouterSettings.maxRegistrationTimeInMs||0)/1e3}:void 0,timeoutOptions:a({connectionTimeoutMs:t.trouterSettings.trouterConnectTimeoutInMs||3e4,fetchTimeoutMs:1e4,pingTimeoutMs:4e4,pongTimeoutMs:5e3,maxBackoffMs:"TeamsCDL"===t.trouterSettings.productName?3e5:3e4,requestTimeoutMs:5e3,userActivityResponseTimeoutMs:1e4},t.trouterSettings.timeoutOptions),incallTimeoutOptions:a({connectionTimeoutMs:1e4,fetchTimeoutMs:5e3,pingTimeoutMs:5e3,pongTimeoutMs:2e3,maxBackoffMs:"TeamsCDL"===t.trouterSettings.productName?3e5:1e4,requestTimeoutMs:5e3,userActivityResponseTimeoutMs:1e4},t.trouterSettings.incallTimeoutOptions),incallModeTimeoutMs:t.trouterSettings.incallModeTimeoutMs||0,lingeringConnectionDelayMs:6e4,userActivitySecondResendDelayMs:t.trouterSettings.userActivitySecondResendDelayMs||1e4,duplicateDisconnectThresholdMs:1e4,connectionCache:t.connectionCache,registrationStateCallback:t.registrationStateCallbackForAcsDoNotUse,retryLimitOnTokenFetch:"TeamsCDL"===t.trouterSettings.productName?15:t.trouterSettings.retryLimitOnTokenFetch}}function r(t){return new y(t)}function s(){return l.CLIENT_VERSION}function c(t,e){var n=t.indexOf("://");if(n>=0){var o=t.indexOf("/",n+3);if(o>=0)return e+t.substr(o)}return ""}var a=this&&this.__assign||Object.assign||function(t){for(var e,n=1,o=arguments.length;n<o;n++){e=arguments[n];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);}return t},h=this&&this.__awaiter||function(t,e,n,o){return new(n||(n=Promise))(function(i,r){function s(t){try{a(o.next(t));}catch(t){r(t);}}function c(t){try{a(o.throw(t));}catch(t){r(t);}}function a(t){t.done?i(t.value):new n(function(e){e(t.value);}).then(s,c);}a((o=o.apply(t,e||[])).next());})},u=this&&this.__generator||function(t,e){function n(t){return function(e){return o([t,e])}}function o(n){if(i)throw new TypeError("Generator is already executing.");for(;a;)try{if(i=1,r&&(s=2&n[0]?r.return:n[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,n[1])).done)return s;switch(r=0,s&&(n=[2&n[0],s.value]),n[0]){case 0:case 1:s=n;break;case 4:return a.label++,{value:n[1],done:!1};case 5:a.label++,r=n[1],n=[0];continue;case 7:n=a.ops.pop(),a.trys.pop();continue;default:if(s=a.trys,!(s=s.length>0&&s[s.length-1])&&(6===n[0]||2===n[0])){a=0;continue}if(3===n[0]&&(!s||n[1]>s[0]&&n[1]<s[3])){a.label=n[1];break}if(6===n[0]&&a.label<s[1]){a.label=s[1],s=n;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(n);break}s[2]&&a.ops.pop(),a.trys.pop();continue}n=e.call(t,a);}catch(t){n=[6,t],r=0;}finally{i=s=0;}if(5&n[0])throw n[1];return {value:n[0]?n[1]:void 0,done:!0}}var i,r,s,c,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return c={next:n(0),throw:n(1),return:n(2)},"function"==typeof Symbol&&(c[Symbol.iterator]=function(){return this}),c};Object.defineProperty(e,"__esModule",{value:!0});var l=n(1),p=n(2);e.TrouterState=p.TrouterState,e.UserActivityState=p.UserActivityState;var d=n(0),g=n(7),f=n(8),v=n(9),m=n(10),y=function(){function t(t){this.logProvider=t,this.stateChangedListeners=[],this.logger=new d.Logger("Trouter",t),this.trouterUrlPromise=new m.TrouterUrlPromise(t),this.messageHandlers=new g.MessageHandlerRegistry(t),this.listeners={},this.connectionInfo=null,this.logger.info("Created TrouterService version "+l.CLIENT_VERSION);}return t.prototype.start=function(t){if(this.logger.info("Start"),!t.trouterSettings.disableInternalSkypeTokenCache){var e=t.skypeTokenProvider;t.skypeTokenProvider=f.addCacheAsBackupTo(e);}this.trouterCfg=t;var n=i(t,this.ecsCfg);void 0===this.trouterServer&&(this.trouterServer=new v.TrouterManager(this.logProvider,n,t.skypeTokenProvider,this)),this.trouterServer.start();},t.prototype.stop=function(t){this.logger.info("close connection"),this.trouterUrlPromise.rejectUrl(new Error("TrouterService is stopped")),void 0!==this.trouterServer&&this.trouterServer.stop(t);},t.prototype.setEcsConfig=function(t){return h(this,void 0,void 0,function(){var e=this;return u(this,function(n){return [2,new Promise(function(n,o){if(e.ecsCfg=t.TrouterJScriptClient,e.logger.info("Setting ECS configuration to "+JSON.stringify(e.ecsCfg)),void 0!==e.trouterServer&&void 0!==e.trouterCfg){var r=i(e.trouterCfg,e.ecsCfg);e.trouterServer.configure(r);}n();})]})})},t.prototype.checkConnection=function(t){void 0!==this.trouterServer&&this.trouterServer.checkConnection(t||!1);},t.prototype.resendRegistration=function(){return h(this,void 0,void 0,function(){return u(this,function(t){if(!this.trouterServer)throw new Error("resendRegistration called too early");return [2,this.trouterServer.resendRegistration()]})})},t.prototype.registerListener=function(t,e){return ""===e||"/"!==e[0]||e.indexOf("?")>=0||e.indexOf("#")>=0?(this.logger.error("Listener path '"+e+"' is not valid"),!1):this.listeners[e]?(this.logger.error("Another listener is already registered for path '"+e+"'"),!1):(this.listeners[e]=t,this.logger.debug("Listener for path '"+e+"' registered"),this.connectionInfo&&t.onTrouterConnected(this.connectionInfo.baseEndpointUrl+e,this.connectionInfo),!0)},t.prototype.unregisterListener=function(t){for(var e=[],n=0,o=Object.keys(this.listeners);n<o.length;n++){var i=o[n];this.listeners[i]===t&&e.push(i);}if(0===e.length)return !1;for(var r=0,s=e;r<s.length;r++){var i=s[r];delete this.listeners[i];}return this.logger.debug("Listener for path(s) '"+e.join("', '")+"' unregistered"),!0},t.prototype.onTrouterConnected=function(t,e){this.logger.debug("Trouter is now connected");for(var n=0,o=Object.keys(this.listeners);n<o.length;n++){var i=o[n];try{this.listeners[i].onTrouterConnected(e.baseEndpointUrl+i,e);}catch(t){this.logger.error("Listener '"+i+"' threw an exception from onTrouterConnected(): "+t);}}this.connectionInfo=e,this.trouterUrlPromise.resolveUrl(t),this.notifyStateChanged(p.TrouterState.Connected,{url:t,getRemainingTtlInSec:function(){return e.connectionTtlSec}});},t.prototype.onTrouterDisconnected=function(){this.logger.debug("Trouter is now disconnected"),this.connectionInfo=null;for(var t=0,e=Object.keys(this.listeners);t<e.length;t++){var n=e[t],o=this.listeners[n];if(o.onTrouterDisconnected)try{o.onTrouterDisconnected();}catch(t){this.logger.error("Listener '"+n+"' threw an exception from onTrouterDisconnected(): "+t);}}this.notifyStateChanged(p.TrouterState.Disconnected);},t.prototype.onTrouterRequest=function(t,e){for(var n="",o=0,i=Object.keys(this.listeners);o<i.length;o++){var r=i[o];t.path.substring(0,r.length)===r&&r.length>n.length&&(n=r);}if(""===n)this.tryMessageHandlers(t,e)||(e.status=404,e.headers={"Trouter-Responder":"ClientLib"},e.send());else try{this.listeners[n].onTrouterRequest(t,e);}catch(t){this.logger.error("Listener '"+n+"' threw an exception from onTrouterRequest(): "+t),e.status=500,e.headers={"Trouter-Responder":"ClientLib"},e.send();}},t.prototype.onTrouterMessageLoss=function(t){this.logger.info("onTrouterMessageLoss called with value "+t);for(var e=!0,n=0,o=Object.keys(this.listeners);n<o.length;n++){var i=o[n],r=this.listeners[i];if(r.onTrouterMessageLoss)try{e=r.onTrouterMessageLoss(t)&&e,void 0===e&&(this.logger.error("Listener '"+i+"' did not response with boolean value onTrouterMessageLoss()"),e=!1);}catch(t){this.logger.error("Listener '"+i+"' threw an exception from onTrouterMessageLoss(): "+t),e=!1;}}return e},t.prototype.onTrouterUserActivityStateAccepted=function(t){this.logger.debug("onTrouterUserActivityStateAccepted cv: "+t);for(var e=0,n=Object.keys(this.listeners);e<n.length;e++){var o=n[e],i=this.listeners[o];if(i.onTrouterUserActivityStateAccepted)try{i.onTrouterUserActivityStateAccepted(t);}catch(t){this.logger.error("Listener '"+o+"' threw an exception from onTrouterUserActivityStateAccepted(): "+t);}}},t.prototype.setUserActivityState=function(t,e){if(t!==p.UserActivityState.Active&&t!==p.UserActivityState.Inactive)throw new Error("setUserActivityState called with unsupported value "+t);if(this.logger.info("setUserActivityState called with value "+p.UserActivityState[t]),!this.trouterServer||this.state()===p.TrouterState.Unknown)throw new Error("setUserActivityState called too early");this.trouterServer.setUserActivityState(t,e);},t.prototype.state=function(){return void 0!==this.trouterServer?this.trouterServer.getState():p.TrouterState.Unknown},t.prototype.getServerState=function(){if(void 0!==this.trouterServer)return this.trouterServer.getServerState()},t.prototype.getTrouterUrlAsync=function(){return void 0!==this.trouterServer?this.trouterUrlPromise.getPromise():Promise.reject(new Error("TrouterService has not been started"))},t.prototype.onStateChanged=function(t){if(this.logger.info("onStateChanged called"),void 0===t)this.stateChangedListeners=this.stateChangedListeners.filter(function(t){return void 0===t.wrappedCallback});else {this.offStateChanged(t);var e=function(e,n){t(e,n?n.url:"");};e.wrappedCallback=t,this.stateChangedListeners.push(e);}},t.prototype.offStateChanged=function(t){this.logger.info("offStateChanged called");var e=this.stateChangedListeners.length;return this.stateChangedListeners=this.stateChangedListeners.filter(function(e){return e.wrappedCallback!==t}),e>this.stateChangedListeners.length},t.prototype.addCallback=function(t){this.logger.info("addListener called"),-1===this.stateChangedListeners.indexOf(t,0)&&void 0!==t&&this.stateChangedListeners.push(t);},t.prototype.removeCallback=function(t){this.logger.info("removeListener called");var e=this.stateChangedListeners.indexOf(t,0);return e>-1&&(this.stateChangedListeners.splice(e,1),!0)},t.prototype.registerMessageHandler=function(t){this.logger.info("registerMessageHandler is called"),this.messageHandlers.register(t);},t.prototype.clearMessageHandlers=function(){this.logger.info("clearMessageHandlers is called"),this.messageHandlers.clear();},t.prototype.notifyStateChanged=function(t,e){var n=this;this.logger.info("notifyStateChanged called, will forward to "+this.stateChangedListeners.length+" listeners"),this.stateChangedListeners.forEach(function(o){try{o(t,e);}catch(t){n.logger.error("Error in callback "+t);}});},t.prototype.tryMessageHandlers=function(t,e){if(!this.messageHandlers.active())return !1;var n,o=null;try{n=JSON.parse(t.body),o=n&&(n.evt||n.eventId)||null;}catch(t){}var i={eventId:o,url:(this.connectionInfo?this.connectionInfo.baseEndpointUrl:"")+t.path,body:n,rawBody:t.body,headers:t.headers},r=this.messageHandlers.handleMessage(i);return !!r.isHandled&&(e.status=r.resultCode,r.responseHeaders&&(e.headers=r.responseHeaders),r.responseBody&&(e.body=r.responseBody),e.send(),!0)},t}();e.TrouterService=y,e.createTrouterService=r,e.getTrouterServiceVersion=s,e.replaceTrouterUrlBase=c;},function(e,n){e.exports=t;},function(t,e){}])});

	});

	unwrapExports(tstrouter);

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * A collection of HttpHeaders that can be sent with a HTTP request.
	 */
	function getHeaderKey(headerName) {
	    return headerName.toLowerCase();
	}
	function isHttpHeadersLike(object) {
	    if (object && typeof object === "object") {
	        const castObject = object;
	        if (typeof castObject.rawHeaders === "function" &&
	            typeof castObject.clone === "function" &&
	            typeof castObject.get === "function" &&
	            typeof castObject.set === "function" &&
	            typeof castObject.contains === "function" &&
	            typeof castObject.remove === "function" &&
	            typeof castObject.headersArray === "function" &&
	            typeof castObject.headerValues === "function" &&
	            typeof castObject.headerNames === "function" &&
	            typeof castObject.toJson === "function") {
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * A collection of HTTP header key/value pairs.
	 */
	class HttpHeaders {
	    constructor(rawHeaders) {
	        this._headersMap = {};
	        if (rawHeaders) {
	            for (const headerName in rawHeaders) {
	                this.set(headerName, rawHeaders[headerName]);
	            }
	        }
	    }
	    /**
	     * Set a header in this collection with the provided name and value. The name is
	     * case-insensitive.
	     * @param headerName - The name of the header to set. This value is case-insensitive.
	     * @param headerValue - The value of the header to set.
	     */
	    set(headerName, headerValue) {
	        this._headersMap[getHeaderKey(headerName)] = {
	            name: headerName,
	            value: headerValue.toString()
	        };
	    }
	    /**
	     * Get the header value for the provided header name, or undefined if no header exists in this
	     * collection with the provided name.
	     * @param headerName - The name of the header.
	     */
	    get(headerName) {
	        const header = this._headersMap[getHeaderKey(headerName)];
	        return !header ? undefined : header.value;
	    }
	    /**
	     * Get whether or not this header collection contains a header entry for the provided header name.
	     */
	    contains(headerName) {
	        return !!this._headersMap[getHeaderKey(headerName)];
	    }
	    /**
	     * Remove the header with the provided headerName. Return whether or not the header existed and
	     * was removed.
	     * @param headerName - The name of the header to remove.
	     */
	    remove(headerName) {
	        const result = this.contains(headerName);
	        delete this._headersMap[getHeaderKey(headerName)];
	        return result;
	    }
	    /**
	     * Get the headers that are contained this collection as an object.
	     */
	    rawHeaders() {
	        const result = {};
	        for (const headerKey in this._headersMap) {
	            const header = this._headersMap[headerKey];
	            result[header.name.toLowerCase()] = header.value;
	        }
	        return result;
	    }
	    /**
	     * Get the headers that are contained in this collection as an array.
	     */
	    headersArray() {
	        const headers = [];
	        for (const headerKey in this._headersMap) {
	            headers.push(this._headersMap[headerKey]);
	        }
	        return headers;
	    }
	    /**
	     * Get the header names that are contained in this collection.
	     */
	    headerNames() {
	        const headerNames = [];
	        const headers = this.headersArray();
	        for (let i = 0; i < headers.length; ++i) {
	            headerNames.push(headers[i].name);
	        }
	        return headerNames;
	    }
	    /**
	     * Get the header values that are contained in this collection.
	     */
	    headerValues() {
	        const headerValues = [];
	        const headers = this.headersArray();
	        for (let i = 0; i < headers.length; ++i) {
	            headerValues.push(headers[i].value);
	        }
	        return headerValues;
	    }
	    /**
	     * Get the JSON object representation of this HTTP header collection.
	     */
	    toJson() {
	        return this.rawHeaders();
	    }
	    /**
	     * Get the string representation of this HTTP header collection.
	     */
	    toString() {
	        return JSON.stringify(this.toJson());
	    }
	    /**
	     * Create a deep clone/copy of this HttpHeaders collection.
	     */
	    clone() {
	        return new HttpHeaders(this.rawHeaders());
	    }
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * Encodes a string in base64 format.
	 * @param value - The string to encode
	 */
	function encodeString(value) {
	    return btoa(value);
	}
	/**
	 * Encodes a byte array in base64 format.
	 * @param value - The Uint8Aray to encode
	 */
	function encodeByteArray(value) {
	    let str = "";
	    for (let i = 0; i < value.length; i++) {
	        str += String.fromCharCode(value[i]);
	    }
	    return btoa(str);
	}
	/**
	 * Decodes a base64 string into a byte array.
	 * @param value - The base64 string to decode
	 */
	function decodeString(value) {
	    const byteString = atob(value);
	    const arr = new Uint8Array(byteString.length);
	    for (let i = 0; i < byteString.length; i++) {
	        arr[i] = byteString.charCodeAt(i);
	    }
	    return arr;
	}

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
	// find the complete implementation of crypto (msCrypto) on IE11.
	var getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
	var rnds8 = new Uint8Array(16);
	function rng() {
	  if (!getRandomValues) {
	    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	  }

	  return getRandomValues(rnds8);
	}

	var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

	function validate(uuid) {
	  return typeof uuid === 'string' && REGEX.test(uuid);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	var byteToHex = [];

	for (var i = 0; i < 256; ++i) {
	  byteToHex.push((i + 0x100).toString(16).substr(1));
	}

	function stringify(arr) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
	  // of the following:
	  // - One or more input array values don't map to a hex octet (leading to
	  // "undefined" in the uuid)
	  // - Invalid input values for the RFC `version` or `variant` fields

	  if (!validate(uuid)) {
	    throw TypeError('Stringified UUID is invalid');
	  }

	  return uuid;
	}

	function v4(options, buf, offset) {
	  options = options || {};
	  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  if (buf) {
	    offset = offset || 0;

	    for (var i = 0; i < 16; ++i) {
	      buf[offset + i] = rnds[i];
	    }

	    return buf;
	  }

	  return stringify(rnds);
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	const Constants = {
	    /**
	     * The core-http version
	     */
	    coreHttpVersion: "2.2.0",
	    /**
	     * Specifies HTTP.
	     */
	    HTTP: "http:",
	    /**
	     * Specifies HTTPS.
	     */
	    HTTPS: "https:",
	    /**
	     * Specifies HTTP Proxy.
	     */
	    HTTP_PROXY: "HTTP_PROXY",
	    /**
	     * Specifies HTTPS Proxy.
	     */
	    HTTPS_PROXY: "HTTPS_PROXY",
	    /**
	     * Specifies NO Proxy.
	     */
	    NO_PROXY: "NO_PROXY",
	    /**
	     * Specifies ALL Proxy.
	     */
	    ALL_PROXY: "ALL_PROXY",
	    HttpConstants: {
	        /**
	         * Http Verbs
	         */
	        HttpVerbs: {
	            PUT: "PUT",
	            GET: "GET",
	            DELETE: "DELETE",
	            POST: "POST",
	            MERGE: "MERGE",
	            HEAD: "HEAD",
	            PATCH: "PATCH"
	        },
	        StatusCodes: {
	            TooManyRequests: 429,
	            ServiceUnavailable: 503
	        }
	    },
	    /**
	     * Defines constants for use with HTTP headers.
	     */
	    HeaderConstants: {
	        /**
	         * The Authorization header.
	         */
	        AUTHORIZATION: "authorization",
	        AUTHORIZATION_SCHEME: "Bearer",
	        /**
	         * The Retry-After response-header field can be used with a 503 (Service
	         * Unavailable) or 349 (Too Many Requests) responses to indicate how long
	         * the service is expected to be unavailable to the requesting client.
	         */
	        RETRY_AFTER: "Retry-After",
	        /**
	         * The UserAgent header.
	         */
	        USER_AGENT: "User-Agent"
	    }
	};

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * Default key used to access the XML attributes.
	 */
	const XML_ATTRKEY = "$";
	/**
	 * Default key used to access the XML value content.
	 */
	const XML_CHARKEY = "_";

	// Copyright (c) Microsoft Corporation.
	const validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
	/**
	 * A constant that indicates whether the environment is node.js or browser based.
	 */
	const isNode = typeof process !== "undefined" &&
	    !!process.version &&
	    !!process.versions &&
	    !!process.versions.node;
	/**
	 * Encodes an URI.
	 *
	 * @param uri - The URI to be encoded.
	 * @returns The encoded URI.
	 */
	function encodeUri(uri) {
	    return encodeURIComponent(uri)
	        .replace(/!/g, "%21")
	        .replace(/"/g, "%27")
	        .replace(/\(/g, "%28")
	        .replace(/\)/g, "%29")
	        .replace(/\*/g, "%2A");
	}
	/**
	 * Returns a stripped version of the Http Response which only contains body,
	 * headers and the status.
	 *
	 * @param response - The Http Response
	 * @returns The stripped version of Http Response.
	 */
	function stripResponse(response) {
	    const strippedResponse = {};
	    strippedResponse.body = response.bodyAsText;
	    strippedResponse.headers = response.headers;
	    strippedResponse.status = response.status;
	    return strippedResponse;
	}
	/**
	 * Returns a stripped version of the Http Request that does not contain the
	 * Authorization header.
	 *
	 * @param request - The Http Request object
	 * @returns The stripped version of Http Request.
	 */
	function stripRequest(request) {
	    const strippedRequest = request.clone();
	    if (strippedRequest.headers) {
	        strippedRequest.headers.remove("authorization");
	    }
	    return strippedRequest;
	}
	/**
	 * Validates the given uuid as a string
	 *
	 * @param uuid - The uuid as a string that needs to be validated
	 * @returns True if the uuid is valid; false otherwise.
	 */
	function isValidUuid(uuid) {
	    return validUuidRegex.test(uuid);
	}
	/**
	 * Generated UUID
	 *
	 * @returns RFC4122 v4 UUID.
	 */
	function generateUuid() {
	    return v4();
	}
	/**
	 * Executes an array of promises sequentially. Inspiration of this method is here:
	 * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!
	 *
	 * @param promiseFactories - An array of promise factories(A function that return a promise)
	 * @param kickstart - Input to the first promise that is used to kickstart the promise chain.
	 * If not provided then the promise chain starts with undefined.
	 * @returns A chain of resolved or rejected promises
	 */
	function executePromisesSequentially(promiseFactories, kickstart) {
	    let result = Promise.resolve(kickstart);
	    promiseFactories.forEach((promiseFactory) => {
	        result = result.then(promiseFactory);
	    });
	    return result;
	}
	/**
	 * Converts a Promise to a callback.
	 * @param promise - The Promise to be converted to a callback
	 * @returns A function that takes the callback `(cb: Function) => void`
	 * @deprecated generated code should instead depend on responseToBody
	 */
	// eslint-disable-next-line @typescript-eslint/ban-types
	function promiseToCallback(promise) {
	    if (typeof promise.then !== "function") {
	        throw new Error("The provided input is not a Promise.");
	    }
	    // eslint-disable-next-line @typescript-eslint/ban-types
	    return (cb) => {
	        promise
	            .then((data) => {
	            // eslint-disable-next-line promise/no-callback-in-promise
	            return cb(undefined, data);
	        })
	            .catch((err) => {
	            // eslint-disable-next-line promise/no-callback-in-promise
	            cb(err);
	        });
	    };
	}
	/**
	 * Converts a Promise to a service callback.
	 * @param promise - The Promise of HttpOperationResponse to be converted to a service callback
	 * @returns A function that takes the service callback (cb: ServiceCallback<T>): void
	 */
	function promiseToServiceCallback(promise) {
	    if (typeof promise.then !== "function") {
	        throw new Error("The provided input is not a Promise.");
	    }
	    return (cb) => {
	        promise
	            .then((data) => {
	            return process.nextTick(cb, undefined, data.parsedBody, data.request, data);
	        })
	            .catch((err) => {
	            process.nextTick(cb, err);
	        });
	    };
	}
	function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
	    if (!Array.isArray(obj)) {
	        obj = [obj];
	    }
	    if (!xmlNamespaceKey || !xmlNamespace) {
	        return { [elementName]: obj };
	    }
	    const result = { [elementName]: obj };
	    result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
	    return result;
	}
	/**
	 * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor
	 * @param targetCtor - The target object on which the properties need to be applied.
	 * @param sourceCtors - An array of source objects from which the properties need to be taken.
	 */
	function applyMixins(targetCtorParam, sourceCtors) {
	    const castTargetCtorParam = targetCtorParam;
	    sourceCtors.forEach((sourceCtor) => {
	        Object.getOwnPropertyNames(sourceCtor.prototype).forEach((name) => {
	            castTargetCtorParam.prototype[name] = sourceCtor.prototype[name];
	        });
	    });
	}
	const validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
	/**
	 * Indicates whether the given string is in ISO 8601 format.
	 * @param value - The value to be validated for ISO 8601 duration format.
	 * @returns `true` if valid, `false` otherwise.
	 */
	function isDuration(value) {
	    return validateISODuration.test(value);
	}
	/**
	 * Replace all of the instances of searchValue in value with the provided replaceValue.
	 * @param value - The value to search and replace in.
	 * @param searchValue - The value to search for in the value argument.
	 * @param replaceValue - The value to replace searchValue with in the value argument.
	 * @returns The value where each instance of searchValue was replaced with replacedValue.
	 */
	function replaceAll(value, searchValue, replaceValue) {
	    return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
	}
	/**
	 * Determines whether the given entity is a basic/primitive type
	 * (string, number, boolean, null, undefined).
	 * @param value - Any entity
	 * @returns true is it is primitive type, false otherwise.
	 */
	function isPrimitiveType(value) {
	    return (typeof value !== "object" && typeof value !== "function") || value === null;
	}
	/**
	 * @internal
	 * @returns true when input is an object type that is not null, Array, RegExp, or Date.
	 */
	function isObject(input) {
	    return (typeof input === "object" &&
	        input !== null &&
	        !Array.isArray(input) &&
	        !(input instanceof RegExp) &&
	        !(input instanceof Date));
	}

	// Copyright (c) Microsoft Corporation.
	class Serializer {
	    constructor(modelMappers = {}, isXML) {
	        this.modelMappers = modelMappers;
	        this.isXML = isXML;
	    }
	    validateConstraints(mapper, value, objectName) {
	        const failValidation = (constraintName, constraintValue) => {
	            throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
	        };
	        if (mapper.constraints && value != undefined) {
	            const valueAsNumber = value;
	            const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
	            if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) {
	                failValidation("ExclusiveMaximum", ExclusiveMaximum);
	            }
	            if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) {
	                failValidation("ExclusiveMinimum", ExclusiveMinimum);
	            }
	            if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) {
	                failValidation("InclusiveMaximum", InclusiveMaximum);
	            }
	            if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) {
	                failValidation("InclusiveMinimum", InclusiveMinimum);
	            }
	            const valueAsArray = value;
	            if (MaxItems != undefined && valueAsArray.length > MaxItems) {
	                failValidation("MaxItems", MaxItems);
	            }
	            if (MaxLength != undefined && valueAsArray.length > MaxLength) {
	                failValidation("MaxLength", MaxLength);
	            }
	            if (MinItems != undefined && valueAsArray.length < MinItems) {
	                failValidation("MinItems", MinItems);
	            }
	            if (MinLength != undefined && valueAsArray.length < MinLength) {
	                failValidation("MinLength", MinLength);
	            }
	            if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) {
	                failValidation("MultipleOf", MultipleOf);
	            }
	            if (Pattern) {
	                const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
	                if (typeof value !== "string" || value.match(pattern) === null) {
	                    failValidation("Pattern", Pattern);
	                }
	            }
	            if (UniqueItems &&
	                valueAsArray.some((item, i, ar) => ar.indexOf(item) !== i)) {
	                failValidation("UniqueItems", UniqueItems);
	            }
	        }
	    }
	    /**
	     * Serialize the given object based on its metadata defined in the mapper
	     *
	     * @param mapper - The mapper which defines the metadata of the serializable object
	     * @param object - A valid Javascript object to be serialized
	     * @param objectName - Name of the serialized object
	     * @param options - additional options to deserialization
	     * @returns A valid serialized Javascript object
	     */
	    serialize(mapper, object, objectName, options = {}) {
	        var _a, _b, _c;
	        const updatedOptions = {
	            rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
	            includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
	            xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
	        };
	        let payload = {};
	        const mapperType = mapper.type.name;
	        if (!objectName) {
	            objectName = mapper.serializedName;
	        }
	        if (mapperType.match(/^Sequence$/i) !== null) {
	            payload = [];
	        }
	        if (mapper.isConstant) {
	            object = mapper.defaultValue;
	        }
	        // This table of allowed values should help explain
	        // the mapper.required and mapper.nullable properties.
	        // X means "neither undefined or null are allowed".
	        //           || required
	        //           || true      | false
	        //  nullable || ==========================
	        //      true || null      | undefined/null
	        //     false || X         | undefined
	        // undefined || X         | undefined/null
	        const { required, nullable } = mapper;
	        if (required && nullable && object === undefined) {
	            throw new Error(`${objectName} cannot be undefined.`);
	        }
	        if (required && !nullable && object == undefined) {
	            throw new Error(`${objectName} cannot be null or undefined.`);
	        }
	        if (!required && nullable === false && object === null) {
	            throw new Error(`${objectName} cannot be null.`);
	        }
	        if (object == undefined) {
	            payload = object;
	        }
	        else {
	            // Validate Constraints if any
	            this.validateConstraints(mapper, object, objectName);
	            if (mapperType.match(/^any$/i) !== null) {
	                payload = object;
	            }
	            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
	                payload = serializeBasicTypes(mapperType, objectName, object);
	            }
	            else if (mapperType.match(/^Enum$/i) !== null) {
	                const enumMapper = mapper;
	                payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
	            }
	            else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
	                payload = serializeDateTypes(mapperType, object, objectName);
	            }
	            else if (mapperType.match(/^ByteArray$/i) !== null) {
	                payload = serializeByteArrayType(objectName, object);
	            }
	            else if (mapperType.match(/^Base64Url$/i) !== null) {
	                payload = serializeBase64UrlType(objectName, object);
	            }
	            else if (mapperType.match(/^Sequence$/i) !== null) {
	                payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
	            }
	            else if (mapperType.match(/^Dictionary$/i) !== null) {
	                payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
	            }
	            else if (mapperType.match(/^Composite$/i) !== null) {
	                payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
	            }
	        }
	        return payload;
	    }
	    /**
	     * Deserialize the given object based on its metadata defined in the mapper
	     *
	     * @param mapper - The mapper which defines the metadata of the serializable object
	     * @param responseBody - A valid Javascript entity to be deserialized
	     * @param objectName - Name of the deserialized object
	     * @param options - Controls behavior of XML parser and builder.
	     * @returns A valid deserialized Javascript object
	     */
	    deserialize(mapper, responseBody, objectName, options = {}) {
	        var _a, _b, _c;
	        const updatedOptions = {
	            rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
	            includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
	            xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
	        };
	        if (responseBody == undefined) {
	            if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
	                // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
	                // between the list being empty versus being missing,
	                // so let's do the more user-friendly thing and return an empty list.
	                responseBody = [];
	            }
	            // specifically check for undefined as default value can be a falsey value `0, "", false, null`
	            if (mapper.defaultValue !== undefined) {
	                responseBody = mapper.defaultValue;
	            }
	            return responseBody;
	        }
	        let payload;
	        const mapperType = mapper.type.name;
	        if (!objectName) {
	            objectName = mapper.serializedName;
	        }
	        if (mapperType.match(/^Composite$/i) !== null) {
	            payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
	        }
	        else {
	            if (this.isXML) {
	                const xmlCharKey = updatedOptions.xmlCharKey;
	                const castResponseBody = responseBody;
	                /**
	                 * If the mapper specifies this as a non-composite type value but the responseBody contains
	                 * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
	                 * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
	                 */
	                if (castResponseBody[XML_ATTRKEY] != undefined &&
	                    castResponseBody[xmlCharKey] != undefined) {
	                    responseBody = castResponseBody[xmlCharKey];
	                }
	            }
	            if (mapperType.match(/^Number$/i) !== null) {
	                payload = parseFloat(responseBody);
	                if (isNaN(payload)) {
	                    payload = responseBody;
	                }
	            }
	            else if (mapperType.match(/^Boolean$/i) !== null) {
	                if (responseBody === "true") {
	                    payload = true;
	                }
	                else if (responseBody === "false") {
	                    payload = false;
	                }
	                else {
	                    payload = responseBody;
	                }
	            }
	            else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
	                payload = responseBody;
	            }
	            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
	                payload = new Date(responseBody);
	            }
	            else if (mapperType.match(/^UnixTime$/i) !== null) {
	                payload = unixTimeToDate(responseBody);
	            }
	            else if (mapperType.match(/^ByteArray$/i) !== null) {
	                payload = decodeString(responseBody);
	            }
	            else if (mapperType.match(/^Base64Url$/i) !== null) {
	                payload = base64UrlToByteArray(responseBody);
	            }
	            else if (mapperType.match(/^Sequence$/i) !== null) {
	                payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
	            }
	            else if (mapperType.match(/^Dictionary$/i) !== null) {
	                payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
	            }
	        }
	        if (mapper.isConstant) {
	            payload = mapper.defaultValue;
	        }
	        return payload;
	    }
	}
	function trimEnd(str, ch) {
	    let len = str.length;
	    while (len - 1 >= 0 && str[len - 1] === ch) {
	        --len;
	    }
	    return str.substr(0, len);
	}
	function bufferToBase64Url(buffer) {
	    if (!buffer) {
	        return undefined;
	    }
	    if (!(buffer instanceof Uint8Array)) {
	        throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
	    }
	    // Uint8Array to Base64.
	    const str = encodeByteArray(buffer);
	    // Base64 to Base64Url.
	    return trimEnd(str, "=")
	        .replace(/\+/g, "-")
	        .replace(/\//g, "_");
	}
	function base64UrlToByteArray(str) {
	    if (!str) {
	        return undefined;
	    }
	    if (str && typeof str.valueOf() !== "string") {
	        throw new Error("Please provide an input of type string for converting to Uint8Array");
	    }
	    // Base64Url to Base64.
	    str = str.replace(/-/g, "+").replace(/_/g, "/");
	    // Base64 to Uint8Array.
	    return decodeString(str);
	}
	function splitSerializeName(prop) {
	    const classes = [];
	    let partialclass = "";
	    if (prop) {
	        const subwords = prop.split(".");
	        for (const item of subwords) {
	            if (item.charAt(item.length - 1) === "\\") {
	                partialclass += item.substr(0, item.length - 1) + ".";
	            }
	            else {
	                partialclass += item;
	                classes.push(partialclass);
	                partialclass = "";
	            }
	        }
	    }
	    return classes;
	}
	function dateToUnixTime(d) {
	    if (!d) {
	        return undefined;
	    }
	    if (typeof d.valueOf() === "string") {
	        d = new Date(d);
	    }
	    return Math.floor(d.getTime() / 1000);
	}
	function unixTimeToDate(n) {
	    if (!n) {
	        return undefined;
	    }
	    return new Date(n * 1000);
	}
	function serializeBasicTypes(typeName, objectName, value) {
	    if (value !== null && value !== undefined) {
	        if (typeName.match(/^Number$/i) !== null) {
	            if (typeof value !== "number") {
	                throw new Error(`${objectName} with value ${value} must be of type number.`);
	            }
	        }
	        else if (typeName.match(/^String$/i) !== null) {
	            if (typeof value.valueOf() !== "string") {
	                throw new Error(`${objectName} with value "${value}" must be of type string.`);
	            }
	        }
	        else if (typeName.match(/^Uuid$/i) !== null) {
	            if (!(typeof value.valueOf() === "string" && isValidUuid(value))) {
	                throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
	            }
	        }
	        else if (typeName.match(/^Boolean$/i) !== null) {
	            if (typeof value !== "boolean") {
	                throw new Error(`${objectName} with value ${value} must be of type boolean.`);
	            }
	        }
	        else if (typeName.match(/^Stream$/i) !== null) {
	            const objectType = typeof value;
	            if (objectType !== "string" &&
	                objectType !== "function" &&
	                !(value instanceof ArrayBuffer) &&
	                !ArrayBuffer.isView(value) &&
	                !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob)) {
	                throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`);
	            }
	        }
	    }
	    return value;
	}
	function serializeEnumType(objectName, allowedValues, value) {
	    if (!allowedValues) {
	        throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
	    }
	    const isPresent = allowedValues.some((item) => {
	        if (typeof item.valueOf() === "string") {
	            return item.toLowerCase() === value.toLowerCase();
	        }
	        return item === value;
	    });
	    if (!isPresent) {
	        throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
	    }
	    return value;
	}
	function serializeByteArrayType(objectName, value) {
	    let returnValue = "";
	    if (value != undefined) {
	        if (!(value instanceof Uint8Array)) {
	            throw new Error(`${objectName} must be of type Uint8Array.`);
	        }
	        returnValue = encodeByteArray(value);
	    }
	    return returnValue;
	}
	function serializeBase64UrlType(objectName, value) {
	    let returnValue = "";
	    if (value != undefined) {
	        if (!(value instanceof Uint8Array)) {
	            throw new Error(`${objectName} must be of type Uint8Array.`);
	        }
	        returnValue = bufferToBase64Url(value) || "";
	    }
	    return returnValue;
	}
	function serializeDateTypes(typeName, value, objectName) {
	    if (value != undefined) {
	        if (typeName.match(/^Date$/i) !== null) {
	            if (!(value instanceof Date ||
	                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
	                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
	            }
	            value =
	                value instanceof Date
	                    ? value.toISOString().substring(0, 10)
	                    : new Date(value).toISOString().substring(0, 10);
	        }
	        else if (typeName.match(/^DateTime$/i) !== null) {
	            if (!(value instanceof Date ||
	                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
	                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
	            }
	            value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
	        }
	        else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
	            if (!(value instanceof Date ||
	                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
	                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
	            }
	            value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
	        }
	        else if (typeName.match(/^UnixTime$/i) !== null) {
	            if (!(value instanceof Date ||
	                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
	                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +
	                    `for it to be serialized in UnixTime/Epoch format.`);
	            }
	            value = dateToUnixTime(value);
	        }
	        else if (typeName.match(/^TimeSpan$/i) !== null) {
	            if (!isDuration(value)) {
	                throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
	            }
	        }
	    }
	    return value;
	}
	function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
	    if (!Array.isArray(object)) {
	        throw new Error(`${objectName} must be of type Array.`);
	    }
	    const elementType = mapper.type.element;
	    if (!elementType || typeof elementType !== "object") {
	        throw new Error(`element" metadata for an Array must be defined in the ` +
	            `mapper and it must of type "object" in ${objectName}.`);
	    }
	    const tempArray = [];
	    for (let i = 0; i < object.length; i++) {
	        const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
	        if (isXml && elementType.xmlNamespace) {
	            const xmlnsKey = elementType.xmlNamespacePrefix
	                ? `xmlns:${elementType.xmlNamespacePrefix}`
	                : "xmlns";
	            if (elementType.type.name === "Composite") {
	                tempArray[i] = Object.assign({}, serializedValue);
	                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
	            }
	            else {
	                tempArray[i] = {};
	                tempArray[i][options.xmlCharKey] = serializedValue;
	                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
	            }
	        }
	        else {
	            tempArray[i] = serializedValue;
	        }
	    }
	    return tempArray;
	}
	function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
	    if (typeof object !== "object") {
	        throw new Error(`${objectName} must be of type object.`);
	    }
	    const valueType = mapper.type.value;
	    if (!valueType || typeof valueType !== "object") {
	        throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
	            `mapper and it must of type "object" in ${objectName}.`);
	    }
	    const tempDictionary = {};
	    for (const key of Object.keys(object)) {
	        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
	        // If the element needs an XML namespace we need to add it within the $ property
	        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
	    }
	    // Add the namespace to the root element if needed
	    if (isXml && mapper.xmlNamespace) {
	        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
	        const result = tempDictionary;
	        result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
	        return result;
	    }
	    return tempDictionary;
	}
	/**
	 * Resolves the additionalProperties property from a referenced mapper
	 * @param serializer - The serializer containing the entire set of mappers
	 * @param mapper - The composite mapper to resolve
	 * @param objectName - Name of the object being serialized
	 */
	function resolveAdditionalProperties(serializer, mapper, objectName) {
	    const additionalProperties = mapper.type.additionalProperties;
	    if (!additionalProperties && mapper.type.className) {
	        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
	        return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
	    }
	    return additionalProperties;
	}
	/**
	 * Finds the mapper referenced by className
	 * @param serializer - The serializer containing the entire set of mappers
	 * @param mapper - The composite mapper to resolve
	 * @param objectName - Name of the object being serialized
	 */
	function resolveReferencedMapper(serializer, mapper, objectName) {
	    const className = mapper.type.className;
	    if (!className) {
	        throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, undefined, 2)}".`);
	    }
	    return serializer.modelMappers[className];
	}
	/**
	 * Resolves a composite mapper's modelProperties.
	 * @param serializer - The serializer containing the entire set of mappers
	 * @param mapper - The composite mapper to resolve
	 */
	function resolveModelProperties(serializer, mapper, objectName) {
	    let modelProps = mapper.type.modelProperties;
	    if (!modelProps) {
	        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
	        if (!modelMapper) {
	            throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
	        }
	        modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
	        if (!modelProps) {
	            throw new Error(`modelProperties cannot be null or undefined in the ` +
	                `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
	        }
	    }
	    return modelProps;
	}
	function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
	    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
	        mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
	    }
	    if (object != undefined) {
	        const payload = {};
	        const modelProps = resolveModelProperties(serializer, mapper, objectName);
	        for (const key of Object.keys(modelProps)) {
	            const propertyMapper = modelProps[key];
	            if (propertyMapper.readOnly) {
	                continue;
	            }
	            let propName;
	            let parentObject = payload;
	            if (serializer.isXML) {
	                if (propertyMapper.xmlIsWrapped) {
	                    propName = propertyMapper.xmlName;
	                }
	                else {
	                    propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
	                }
	            }
	            else {
	                const paths = splitSerializeName(propertyMapper.serializedName);
	                propName = paths.pop();
	                for (const pathName of paths) {
	                    const childObject = parentObject[pathName];
	                    if (childObject == undefined &&
	                        (object[key] != undefined || propertyMapper.defaultValue !== undefined)) {
	                        parentObject[pathName] = {};
	                    }
	                    parentObject = parentObject[pathName];
	                }
	            }
	            if (parentObject != undefined) {
	                if (isXml && mapper.xmlNamespace) {
	                    const xmlnsKey = mapper.xmlNamespacePrefix
	                        ? `xmlns:${mapper.xmlNamespacePrefix}`
	                        : "xmlns";
	                    parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });
	                }
	                const propertyObjectName = propertyMapper.serializedName !== ""
	                    ? objectName + "." + propertyMapper.serializedName
	                    : objectName;
	                let toSerialize = object[key];
	                const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
	                if (polymorphicDiscriminator &&
	                    polymorphicDiscriminator.clientName === key &&
	                    toSerialize == undefined) {
	                    toSerialize = mapper.serializedName;
	                }
	                const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
	                if (serializedValue !== undefined && propName != undefined) {
	                    const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
	                    if (isXml && propertyMapper.xmlIsAttribute) {
	                        // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
	                        // This keeps things simple while preventing name collision
	                        // with names in user documents.
	                        parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};
	                        parentObject[XML_ATTRKEY][propName] = serializedValue;
	                    }
	                    else if (isXml && propertyMapper.xmlIsWrapped) {
	                        parentObject[propName] = { [propertyMapper.xmlElementName]: value };
	                    }
	                    else {
	                        parentObject[propName] = value;
	                    }
	                }
	            }
	        }
	        const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
	        if (additionalPropertiesMapper) {
	            const propNames = Object.keys(modelProps);
	            for (const clientPropName in object) {
	                const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
	                if (isAdditionalProperty) {
	                    payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
	                }
	            }
	        }
	        return payload;
	    }
	    return object;
	}
	function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
	    if (!isXml || !propertyMapper.xmlNamespace) {
	        return serializedValue;
	    }
	    const xmlnsKey = propertyMapper.xmlNamespacePrefix
	        ? `xmlns:${propertyMapper.xmlNamespacePrefix}`
	        : "xmlns";
	    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
	    if (["Composite"].includes(propertyMapper.type.name)) {
	        if (serializedValue[XML_ATTRKEY]) {
	            return serializedValue;
	        }
	        else {
	            const result = Object.assign({}, serializedValue);
	            result[XML_ATTRKEY] = xmlNamespace;
	            return result;
	        }
	    }
	    const result = {};
	    result[options.xmlCharKey] = serializedValue;
	    result[XML_ATTRKEY] = xmlNamespace;
	    return result;
	}
	function isSpecialXmlProperty(propertyName, options) {
	    return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);
	}
	function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
	    var _a;
	    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
	        mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
	    }
	    const modelProps = resolveModelProperties(serializer, mapper, objectName);
	    let instance = {};
	    const handledPropertyNames = [];
	    for (const key of Object.keys(modelProps)) {
	        const propertyMapper = modelProps[key];
	        const paths = splitSerializeName(modelProps[key].serializedName);
	        handledPropertyNames.push(paths[0]);
	        const { serializedName, xmlName, xmlElementName } = propertyMapper;
	        let propertyObjectName = objectName;
	        if (serializedName !== "" && serializedName !== undefined) {
	            propertyObjectName = objectName + "." + serializedName;
	        }
	        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
	        if (headerCollectionPrefix) {
	            const dictionary = {};
	            for (const headerKey of Object.keys(responseBody)) {
	                if (headerKey.startsWith(headerCollectionPrefix)) {
	                    dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
	                }
	                handledPropertyNames.push(headerKey);
	            }
	            instance[key] = dictionary;
	        }
	        else if (serializer.isXML) {
	            if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {
	                instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);
	            }
	            else {
	                const propertyName = xmlElementName || xmlName || serializedName;
	                if (propertyMapper.xmlIsWrapped) {
	                    /* a list of <xmlElementName> wrapped by <xmlName>
	                      For the xml example below
	                        <Cors>
	                          <CorsRule>...</CorsRule>
	                          <CorsRule>...</CorsRule>
	                        </Cors>
	                      the responseBody has
	                        {
	                          Cors: {
	                            CorsRule: [{...}, {...}]
	                          }
	                        }
	                      xmlName is "Cors" and xmlElementName is"CorsRule".
	                    */
	                    const wrapped = responseBody[xmlName];
	                    const elementList = (_a = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _a !== void 0 ? _a : [];
	                    instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
	                }
	                else {
	                    const property = responseBody[propertyName];
	                    instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
	                }
	            }
	        }
	        else {
	            // deserialize the property if it is present in the provided responseBody instance
	            let propertyInstance;
	            let res = responseBody;
	            // traversing the object step by step.
	            for (const item of paths) {
	                if (!res)
	                    break;
	                res = res[item];
	            }
	            propertyInstance = res;
	            const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
	            // checking that the model property name (key)(ex: "fishtype") and the
	            // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
	            // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
	            // is a better approach. The generator is not consistent with escaping '\.' in the
	            // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
	            // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
	            // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
	            // the transformation of model property name (ex: "fishtype") is done consistently.
	            // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
	            if (polymorphicDiscriminator &&
	                key === polymorphicDiscriminator.clientName &&
	                propertyInstance == undefined) {
	                propertyInstance = mapper.serializedName;
	            }
	            let serializedValue;
	            // paging
	            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
	                propertyInstance = responseBody[key];
	                const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
	                // Copy over any properties that have already been added into the instance, where they do
	                // not exist on the newly de-serialized array
	                for (const [k, v] of Object.entries(instance)) {
	                    if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
	                        arrayInstance[k] = v;
	                    }
	                }
	                instance = arrayInstance;
	            }
	            else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
	                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
	                instance[key] = serializedValue;
	            }
	        }
	    }
	    const additionalPropertiesMapper = mapper.type.additionalProperties;
	    if (additionalPropertiesMapper) {
	        const isAdditionalProperty = (responsePropName) => {
	            for (const clientPropName in modelProps) {
	                const paths = splitSerializeName(modelProps[clientPropName].serializedName);
	                if (paths[0] === responsePropName) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        for (const responsePropName in responseBody) {
	            if (isAdditionalProperty(responsePropName)) {
	                instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
	            }
	        }
	    }
	    else if (responseBody) {
	        for (const key of Object.keys(responseBody)) {
	            if (instance[key] === undefined &&
	                !handledPropertyNames.includes(key) &&
	                !isSpecialXmlProperty(key, options)) {
	                instance[key] = responseBody[key];
	            }
	        }
	    }
	    return instance;
	}
	function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
	    const value = mapper.type.value;
	    if (!value || typeof value !== "object") {
	        throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
	            `mapper and it must of type "object" in ${objectName}`);
	    }
	    if (responseBody) {
	        const tempDictionary = {};
	        for (const key of Object.keys(responseBody)) {
	            tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
	        }
	        return tempDictionary;
	    }
	    return responseBody;
	}
	function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
	    const element = mapper.type.element;
	    if (!element || typeof element !== "object") {
	        throw new Error(`element" metadata for an Array must be defined in the ` +
	            `mapper and it must of type "object" in ${objectName}`);
	    }
	    if (responseBody) {
	        if (!Array.isArray(responseBody)) {
	            // xml2js will interpret a single element array as just the element, so force it to be an array
	            responseBody = [responseBody];
	        }
	        const tempArray = [];
	        for (let i = 0; i < responseBody.length; i++) {
	            tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
	        }
	        return tempArray;
	    }
	    return responseBody;
	}
	function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
	    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
	    if (polymorphicDiscriminator) {
	        const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
	        if (discriminatorName != undefined) {
	            const discriminatorValue = object[discriminatorName];
	            if (discriminatorValue != undefined) {
	                const typeName = mapper.type.uberParent || mapper.type.className;
	                const indexDiscriminator = discriminatorValue === typeName
	                    ? discriminatorValue
	                    : typeName + "." + discriminatorValue;
	                const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];
	                if (polymorphicMapper) {
	                    mapper = polymorphicMapper;
	                }
	            }
	        }
	    }
	    return mapper;
	}
	function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
	    return (mapper.type.polymorphicDiscriminator ||
	        getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||
	        getPolymorphicDiscriminatorSafely(serializer, mapper.type.className));
	}
	function getPolymorphicDiscriminatorSafely(serializer, typeName) {
	    return (typeName &&
	        serializer.modelMappers[typeName] &&
	        serializer.modelMappers[typeName].type.polymorphicDiscriminator);
	}
	// TODO: why is this here?
	function serializeObject(toSerialize) {
	    const castToSerialize = toSerialize;
	    if (toSerialize == undefined)
	        return undefined;
	    if (toSerialize instanceof Uint8Array) {
	        toSerialize = encodeByteArray(toSerialize);
	        return toSerialize;
	    }
	    else if (toSerialize instanceof Date) {
	        return toSerialize.toISOString();
	    }
	    else if (Array.isArray(toSerialize)) {
	        const array = [];
	        for (let i = 0; i < toSerialize.length; i++) {
	            array.push(serializeObject(toSerialize[i]));
	        }
	        return array;
	    }
	    else if (typeof toSerialize === "object") {
	        const dictionary = {};
	        for (const property in toSerialize) {
	            dictionary[property] = serializeObject(castToSerialize[property]);
	        }
	        return dictionary;
	    }
	    return toSerialize;
	}
	/**
	 * Utility function to create a K:V from a list of strings
	 */
	function strEnum(o) {
	    const result = {};
	    for (const key of o) {
	        result[key] = key;
	    }
	    return result;
	}
	// eslint-disable-next-line @typescript-eslint/no-redeclare
	const MapperType = strEnum([
	    "Base64Url",
	    "Boolean",
	    "ByteArray",
	    "Composite",
	    "Date",
	    "DateTime",
	    "DateTimeRfc1123",
	    "Dictionary",
	    "Enum",
	    "Number",
	    "Object",
	    "Sequence",
	    "String",
	    "Stream",
	    "TimeSpan",
	    "UnixTime"
	]);

	// Copyright (c) Microsoft Corporation.
	function isWebResourceLike(object) {
	    if (object && typeof object === "object") {
	        const castObject = object;
	        if (typeof castObject.url === "string" &&
	            typeof castObject.method === "string" &&
	            typeof castObject.headers === "object" &&
	            isHttpHeadersLike(castObject.headers) &&
	            typeof castObject.validateRequestProperties === "function" &&
	            typeof castObject.prepare === "function" &&
	            typeof castObject.clone === "function") {
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * Creates a new WebResource object.
	 *
	 * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary
	 * properties to initiate a request.
	 */
	class WebResource {
	    constructor(url, method, body, query, headers, streamResponseBody, withCredentials, abortSignal, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive, decompressResponse, streamResponseStatusCodes) {
	        this.streamResponseBody = streamResponseBody;
	        this.streamResponseStatusCodes = streamResponseStatusCodes;
	        this.url = url || "";
	        this.method = method || "GET";
	        this.headers = isHttpHeadersLike(headers) ? headers : new HttpHeaders(headers);
	        this.body = body;
	        this.query = query;
	        this.formData = undefined;
	        this.withCredentials = withCredentials || false;
	        this.abortSignal = abortSignal;
	        this.timeout = timeout || 0;
	        this.onUploadProgress = onUploadProgress;
	        this.onDownloadProgress = onDownloadProgress;
	        this.proxySettings = proxySettings;
	        this.keepAlive = keepAlive;
	        this.decompressResponse = decompressResponse;
	        this.requestId = this.headers.get("x-ms-client-request-id") || generateUuid();
	    }
	    /**
	     * Validates that the required properties such as method, url, headers["Content-Type"],
	     * headers["accept-language"] are defined. It will throw an error if one of the above
	     * mentioned properties are not defined.
	     */
	    validateRequestProperties() {
	        if (!this.method) {
	            throw new Error("WebResource.method is required.");
	        }
	        if (!this.url) {
	            throw new Error("WebResource.url is required.");
	        }
	    }
	    /**
	     * Prepares the request.
	     * @param options - Options to provide for preparing the request.
	     * @returns Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.
	     */
	    prepare(options) {
	        if (!options) {
	            throw new Error("options object is required");
	        }
	        if (options.method === undefined ||
	            options.method === null ||
	            typeof options.method.valueOf() !== "string") {
	            throw new Error("options.method must be a string.");
	        }
	        if (options.url && options.pathTemplate) {
	            throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
	        }
	        if ((options.pathTemplate === undefined ||
	            options.pathTemplate === null ||
	            typeof options.pathTemplate.valueOf() !== "string") &&
	            (options.url === undefined ||
	                options.url === null ||
	                typeof options.url.valueOf() !== "string")) {
	            throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
	        }
	        // set the url if it is provided.
	        if (options.url) {
	            if (typeof options.url !== "string") {
	                throw new Error('options.url must be of type "string".');
	            }
	            this.url = options.url;
	        }
	        // set the method
	        if (options.method) {
	            const validMethods = ["GET", "PUT", "HEAD", "DELETE", "OPTIONS", "POST", "PATCH", "TRACE"];
	            if (validMethods.indexOf(options.method.toUpperCase()) === -1) {
	                throw new Error('The provided method "' +
	                    options.method +
	                    '" is invalid. Supported HTTP methods are: ' +
	                    JSON.stringify(validMethods));
	            }
	        }
	        this.method = options.method.toUpperCase();
	        // construct the url if path template is provided
	        if (options.pathTemplate) {
	            const { pathTemplate, pathParameters } = options;
	            if (typeof pathTemplate !== "string") {
	                throw new Error('options.pathTemplate must be of type "string".');
	            }
	            if (!options.baseUrl) {
	                options.baseUrl = "https://management.azure.com";
	            }
	            const baseUrl = options.baseUrl;
	            let url = baseUrl +
	                (baseUrl.endsWith("/") ? "" : "/") +
	                (pathTemplate.startsWith("/") ? pathTemplate.slice(1) : pathTemplate);
	            const segments = url.match(/({[\w-]*\s*[\w-]*})/gi);
	            if (segments && segments.length) {
	                if (!pathParameters) {
	                    throw new Error(`pathTemplate: ${pathTemplate} has been provided. Hence, options.pathParameters must also be provided.`);
	                }
	                segments.forEach(function (item) {
	                    const pathParamName = item.slice(1, -1);
	                    const pathParam = pathParameters[pathParamName];
	                    if (pathParam === null ||
	                        pathParam === undefined ||
	                        !(typeof pathParam === "string" || typeof pathParam === "object")) {
	                        const stringifiedPathParameters = JSON.stringify(pathParameters, undefined, 2);
	                        throw new Error(`pathTemplate: ${pathTemplate} contains the path parameter ${pathParamName}` +
	                            ` however, it is not present in parameters: ${stringifiedPathParameters}.` +
	                            `The value of the path parameter can either be a "string" of the form { ${pathParamName}: "some sample value" } or ` +
	                            `it can be an "object" of the form { "${pathParamName}": { value: "some sample value", skipUrlEncoding: true } }.`);
	                    }
	                    if (typeof pathParam.valueOf() === "string") {
	                        url = url.replace(item, encodeURIComponent(pathParam));
	                    }
	                    if (typeof pathParam.valueOf() === "object") {
	                        if (!pathParam.value) {
	                            throw new Error(`options.pathParameters[${pathParamName}] is of type "object" but it does not contain a "value" property.`);
	                        }
	                        if (pathParam.skipUrlEncoding) {
	                            url = url.replace(item, pathParam.value);
	                        }
	                        else {
	                            url = url.replace(item, encodeURIComponent(pathParam.value));
	                        }
	                    }
	                });
	            }
	            this.url = url;
	        }
	        // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.
	        if (options.queryParameters) {
	            const queryParameters = options.queryParameters;
	            if (typeof queryParameters !== "object") {
	                throw new Error(`options.queryParameters must be of type object. It should be a JSON object ` +
	                    `of "query-parameter-name" as the key and the "query-parameter-value" as the value. ` +
	                    `The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.`);
	            }
	            // append question mark if it is not present in the url
	            if (this.url && this.url.indexOf("?") === -1) {
	                this.url += "?";
	            }
	            // construct queryString
	            const queryParams = [];
	            // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().
	            this.query = {};
	            for (const queryParamName in queryParameters) {
	                const queryParam = queryParameters[queryParamName];
	                if (queryParam) {
	                    if (typeof queryParam === "string") {
	                        queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam));
	                        this.query[queryParamName] = encodeURIComponent(queryParam);
	                    }
	                    else if (typeof queryParam === "object") {
	                        if (!queryParam.value) {
	                            throw new Error(`options.queryParameters[${queryParamName}] is of type "object" but it does not contain a "value" property.`);
	                        }
	                        if (queryParam.skipUrlEncoding) {
	                            queryParams.push(queryParamName + "=" + queryParam.value);
	                            this.query[queryParamName] = queryParam.value;
	                        }
	                        else {
	                            queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam.value));
	                            this.query[queryParamName] = encodeURIComponent(queryParam.value);
	                        }
	                    }
	                }
	            } // end-of-for
	            // append the queryString
	            this.url += queryParams.join("&");
	        }
	        // add headers to the request if they are provided
	        if (options.headers) {
	            const headers = options.headers;
	            for (const headerName of Object.keys(options.headers)) {
	                this.headers.set(headerName, headers[headerName]);
	            }
	        }
	        // ensure accept-language is set correctly
	        if (!this.headers.get("accept-language")) {
	            this.headers.set("accept-language", "en-US");
	        }
	        // ensure the request-id is set correctly
	        if (!this.headers.get("x-ms-client-request-id") && !options.disableClientRequestId) {
	            this.headers.set("x-ms-client-request-id", this.requestId);
	        }
	        // default
	        if (!this.headers.get("Content-Type")) {
	            this.headers.set("Content-Type", "application/json; charset=utf-8");
	        }
	        // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicitly
	        this.body = options.body;
	        if (options.body !== undefined && options.body !== null) {
	            // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.
	            if (options.bodyIsStream) {
	                if (!this.headers.get("Transfer-Encoding")) {
	                    this.headers.set("Transfer-Encoding", "chunked");
	                }
	                if (this.headers.get("Content-Type") !== "application/octet-stream") {
	                    this.headers.set("Content-Type", "application/octet-stream");
	                }
	            }
	            else {
	                if (options.serializationMapper) {
	                    this.body = new Serializer(options.mappers).serialize(options.serializationMapper, options.body, "requestBody");
	                }
	                if (!options.disableJsonStringifyOnBody) {
	                    this.body = JSON.stringify(options.body);
	                }
	            }
	        }
	        if (options.spanOptions) {
	            this.spanOptions = options.spanOptions;
	        }
	        if (options.tracingContext) {
	            this.tracingContext = options.tracingContext;
	        }
	        this.abortSignal = options.abortSignal;
	        this.onDownloadProgress = options.onDownloadProgress;
	        this.onUploadProgress = options.onUploadProgress;
	        return this;
	    }
	    /**
	     * Clone this WebResource HTTP request object.
	     * @returns The clone of this WebResource HTTP request object.
	     */
	    clone() {
	        const result = new WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse, this.streamResponseStatusCodes);
	        if (this.formData) {
	            result.formData = this.formData;
	        }
	        if (this.operationSpec) {
	            result.operationSpec = this.operationSpec;
	        }
	        if (this.shouldDeserialize) {
	            result.shouldDeserialize = this.shouldDeserialize;
	        }
	        if (this.operationResponseGetter) {
	            result.operationResponseGetter = this.operationResponseGetter;
	        }
	        return result;
	    }
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	function __values(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	function __spread() {
	    for (var ar = [], i = 0; i < arguments.length; i++)
	        ar = ar.concat(__read(arguments[i]));
	    return ar;
	}

	var listenersMap = new WeakMap();
	var abortedMap = new WeakMap();
	/**
	 * An aborter instance implements AbortSignal interface, can abort HTTP requests.
	 *
	 * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.
	 * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation
	 * cannot or will not ever be cancelled.
	 *
	 * @example
	 * // Abort without timeout
	 * await doAsyncWork(AbortSignal.none);
	 *
	 * @export
	 * @class AbortSignal
	 * @implements {AbortSignalLike}
	 */
	var AbortSignal = /** @class */ (function () {
	    function AbortSignal() {
	        /**
	         * onabort event listener.
	         *
	         * @memberof AbortSignal
	         */
	        this.onabort = null;
	        listenersMap.set(this, []);
	        abortedMap.set(this, false);
	    }
	    Object.defineProperty(AbortSignal.prototype, "aborted", {
	        /**
	         * Status of whether aborted or not.
	         *
	         * @readonly
	         * @type {boolean}
	         * @memberof AbortSignal
	         */
	        get: function () {
	            if (!abortedMap.has(this)) {
	                throw new TypeError("Expected `this` to be an instance of AbortSignal.");
	            }
	            return abortedMap.get(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbortSignal, "none", {
	        /**
	         * Creates a new AbortSignal instance that will never be aborted.
	         *
	         * @readonly
	         * @static
	         * @type {AbortSignal}
	         * @memberof AbortSignal
	         */
	        get: function () {
	            return new AbortSignal();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Added new "abort" event listener, only support "abort" event.
	     *
	     * @param {"abort"} _type Only support "abort" event
	     * @param {(this: AbortSignalLike, ev: any) => any} listener
	     * @memberof AbortSignal
	     */
	    AbortSignal.prototype.addEventListener = function (
	    // tslint:disable-next-line:variable-name
	    _type, listener) {
	        if (!listenersMap.has(this)) {
	            throw new TypeError("Expected `this` to be an instance of AbortSignal.");
	        }
	        var listeners = listenersMap.get(this);
	        listeners.push(listener);
	    };
	    /**
	     * Remove "abort" event listener, only support "abort" event.
	     *
	     * @param {"abort"} _type Only support "abort" event
	     * @param {(this: AbortSignalLike, ev: any) => any} listener
	     * @memberof AbortSignal
	     */
	    AbortSignal.prototype.removeEventListener = function (
	    // tslint:disable-next-line:variable-name
	    _type, listener) {
	        if (!listenersMap.has(this)) {
	            throw new TypeError("Expected `this` to be an instance of AbortSignal.");
	        }
	        var listeners = listenersMap.get(this);
	        var index = listeners.indexOf(listener);
	        if (index > -1) {
	            listeners.splice(index, 1);
	        }
	    };
	    /**
	     * Dispatches a synthetic event to the AbortSignal.
	     */
	    AbortSignal.prototype.dispatchEvent = function (_event) {
	        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
	    };
	    return AbortSignal;
	}());
	/**
	 * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.
	 * Will try to trigger abort event for all linked AbortSignal nodes.
	 *
	 * - If there is a timeout, the timer will be cancelled.
	 * - If aborted is true, nothing will happen.
	 *
	 * @returns
	 * @internal
	 */
	function abortSignal(signal) {
	    if (signal.aborted) {
	        return;
	    }
	    if (signal.onabort) {
	        signal.onabort.call(signal);
	    }
	    var listeners = listenersMap.get(signal);
	    if (listeners) {
	        listeners.forEach(function (listener) {
	            listener.call(signal, { type: "abort" });
	        });
	    }
	    abortedMap.set(signal, true);
	}

	/**
	 * This error is thrown when an asynchronous operation has been aborted.
	 * Check for this error by testing the `name` that the name property of the
	 * error matches `"AbortError"`.
	 *
	 * @example
	 * const controller = new AbortController();
	 * controller.abort();
	 * try {
	 *   doAsyncWork(controller.signal)
	 * } catch (e) {
	 *   if (e.name === 'AbortError') {
	 *     // handle abort error here.
	 *   }
	 * }
	 */
	var AbortError = /** @class */ (function (_super) {
	    __extends(AbortError, _super);
	    function AbortError(message) {
	        var _this = _super.call(this, message) || this;
	        _this.name = "AbortError";
	        return _this;
	    }
	    return AbortError;
	}(Error));
	/**
	 * An AbortController provides an AbortSignal and the associated controls to signal
	 * that an asynchronous operation should be aborted.
	 *
	 * @example
	 * // Abort an operation when another event fires
	 * const controller = new AbortController();
	 * const signal = controller.signal;
	 * doAsyncWork(signal);
	 * button.addEventListener('click', () => controller.abort());
	 *
	 * @example
	 * // Share aborter cross multiple operations in 30s
	 * // Upload the same data to 2 different data centers at the same time,
	 * // abort another when any of them is finished
	 * const controller = AbortController.withTimeout(30 * 1000);
	 * doAsyncWork(controller.signal).then(controller.abort);
	 * doAsyncWork(controller.signal).then(controller.abort);
	 *
	 * @example
	 * // Cascaded aborting
	 * // All operations can't take more than 30 seconds
	 * const aborter = Aborter.timeout(30 * 1000);
	 *
	 * // Following 2 operations can't take more than 25 seconds
	 * await doAsyncWork(aborter.withTimeout(25 * 1000));
	 * await doAsyncWork(aborter.withTimeout(25 * 1000));
	 *
	 * @export
	 * @class AbortController
	 * @implements {AbortSignalLike}
	 */
	var AbortController = /** @class */ (function () {
	    function AbortController(parentSignals) {
	        var _this = this;
	        this._signal = new AbortSignal();
	        if (!parentSignals) {
	            return;
	        }
	        // coerce parentSignals into an array
	        if (!Array.isArray(parentSignals)) {
	            parentSignals = arguments;
	        }
	        for (var _i = 0, parentSignals_1 = parentSignals; _i < parentSignals_1.length; _i++) {
	            var parentSignal = parentSignals_1[_i];
	            // if the parent signal has already had abort() called,
	            // then call abort on this signal as well.
	            if (parentSignal.aborted) {
	                this.abort();
	            }
	            else {
	                // when the parent signal aborts, this signal should as well.
	                parentSignal.addEventListener("abort", function () {
	                    _this.abort();
	                });
	            }
	        }
	    }
	    Object.defineProperty(AbortController.prototype, "signal", {
	        /**
	         * The AbortSignal associated with this controller that will signal aborted
	         * when the abort method is called on this controller.
	         *
	         * @readonly
	         * @type {AbortSignal}
	         * @memberof AbortController
	         */
	        get: function () {
	            return this._signal;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Signal that any operations passed this controller's associated abort signal
	     * to cancel any remaining work and throw an `AbortError`.
	     *
	     * @memberof AbortController
	     */
	    AbortController.prototype.abort = function () {
	        abortSignal(this._signal);
	    };
	    /**
	     * Creates a new AbortSignal instance that will abort after the provided ms.
	     *
	     * @static
	     * @params {number} ms Elapsed time in milliseconds to trigger an abort.
	     * @returns {AbortSignal}
	     */
	    AbortController.timeout = function (ms) {
	        var signal = new AbortSignal();
	        var timer = setTimeout(abortSignal, ms, signal);
	        // Prevent the active Timer from keeping the Node.js event loop active.
	        if (typeof timer.unref === "function") {
	            timer.unref();
	        }
	        return signal;
	    };
	    return AbortController;
	}());

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	const custom = {};

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	const url = URL;

	// Copyright (c) Microsoft Corporation.
	/**
	 * A class that handles the query portion of a URLBuilder.
	 */
	class URLQuery {
	    constructor() {
	        this._rawQuery = {};
	    }
	    /**
	     * Get whether or not there any query parameters in this URLQuery.
	     */
	    any() {
	        return Object.keys(this._rawQuery).length > 0;
	    }
	    /**
	     * Get the keys of the query string.
	     */
	    keys() {
	        return Object.keys(this._rawQuery);
	    }
	    /**
	     * Set a query parameter with the provided name and value. If the parameterValue is undefined or
	     * empty, then this will attempt to remove an existing query parameter with the provided
	     * parameterName.
	     */
	    set(parameterName, parameterValue) {
	        const caseParameterValue = parameterValue;
	        if (parameterName) {
	            if (caseParameterValue !== undefined && caseParameterValue !== null) {
	                const newValue = Array.isArray(caseParameterValue)
	                    ? caseParameterValue
	                    : caseParameterValue.toString();
	                this._rawQuery[parameterName] = newValue;
	            }
	            else {
	                delete this._rawQuery[parameterName];
	            }
	        }
	    }
	    /**
	     * Get the value of the query parameter with the provided name. If no parameter exists with the
	     * provided parameter name, then undefined will be returned.
	     */
	    get(parameterName) {
	        return parameterName ? this._rawQuery[parameterName] : undefined;
	    }
	    /**
	     * Get the string representation of this query. The return value will not start with a "?".
	     */
	    toString() {
	        let result = "";
	        for (const parameterName in this._rawQuery) {
	            if (result) {
	                result += "&";
	            }
	            const parameterValue = this._rawQuery[parameterName];
	            if (Array.isArray(parameterValue)) {
	                const parameterStrings = [];
	                for (const parameterValueElement of parameterValue) {
	                    parameterStrings.push(`${parameterName}=${parameterValueElement}`);
	                }
	                result += parameterStrings.join("&");
	            }
	            else {
	                result += `${parameterName}=${parameterValue}`;
	            }
	        }
	        return result;
	    }
	    /**
	     * Parse a URLQuery from the provided text.
	     */
	    static parse(text) {
	        const result = new URLQuery();
	        if (text) {
	            if (text.startsWith("?")) {
	                text = text.substring(1);
	            }
	            let currentState = "ParameterName";
	            let parameterName = "";
	            let parameterValue = "";
	            for (let i = 0; i < text.length; ++i) {
	                const currentCharacter = text[i];
	                switch (currentState) {
	                    case "ParameterName":
	                        switch (currentCharacter) {
	                            case "=":
	                                currentState = "ParameterValue";
	                                break;
	                            case "&":
	                                parameterName = "";
	                                parameterValue = "";
	                                break;
	                            default:
	                                parameterName += currentCharacter;
	                                break;
	                        }
	                        break;
	                    case "ParameterValue":
	                        switch (currentCharacter) {
	                            case "&":
	                                result.set(parameterName, parameterValue);
	                                parameterName = "";
	                                parameterValue = "";
	                                currentState = "ParameterName";
	                                break;
	                            default:
	                                parameterValue += currentCharacter;
	                                break;
	                        }
	                        break;
	                    default:
	                        throw new Error("Unrecognized URLQuery parse state: " + currentState);
	                }
	            }
	            if (currentState === "ParameterValue") {
	                result.set(parameterName, parameterValue);
	            }
	        }
	        return result;
	    }
	}
	/**
	 * A class that handles creating, modifying, and parsing URLs.
	 */
	class URLBuilder {
	    /**
	     * Set the scheme/protocol for this URL. If the provided scheme contains other parts of a URL
	     * (such as a host, port, path, or query), those parts will be added to this URL as well.
	     */
	    setScheme(scheme) {
	        if (!scheme) {
	            this._scheme = undefined;
	        }
	        else {
	            this.set(scheme, "SCHEME");
	        }
	    }
	    /**
	     * Get the scheme that has been set in this URL.
	     */
	    getScheme() {
	        return this._scheme;
	    }
	    /**
	     * Set the host for this URL. If the provided host contains other parts of a URL (such as a
	     * port, path, or query), those parts will be added to this URL as well.
	     */
	    setHost(host) {
	        if (!host) {
	            this._host = undefined;
	        }
	        else {
	            this.set(host, "SCHEME_OR_HOST");
	        }
	    }
	    /**
	     * Get the host that has been set in this URL.
	     */
	    getHost() {
	        return this._host;
	    }
	    /**
	     * Set the port for this URL. If the provided port contains other parts of a URL (such as a
	     * path or query), those parts will be added to this URL as well.
	     */
	    setPort(port) {
	        if (port === undefined || port === null || port === "") {
	            this._port = undefined;
	        }
	        else {
	            this.set(port.toString(), "PORT");
	        }
	    }
	    /**
	     * Get the port that has been set in this URL.
	     */
	    getPort() {
	        return this._port;
	    }
	    /**
	     * Set the path for this URL. If the provided path contains a query, then it will be added to
	     * this URL as well.
	     */
	    setPath(path) {
	        if (!path) {
	            this._path = undefined;
	        }
	        else {
	            const schemeIndex = path.indexOf("://");
	            if (schemeIndex !== -1) {
	                const schemeStart = path.lastIndexOf("/", schemeIndex);
	                // Make sure to only grab the URL part of the path before setting the state back to SCHEME
	                // this will handle cases such as "/a/b/c/https://microsoft.com" => "https://microsoft.com"
	                this.set(schemeStart === -1 ? path : path.substr(schemeStart + 1), "SCHEME");
	            }
	            else {
	                this.set(path, "PATH");
	            }
	        }
	    }
	    /**
	     * Append the provided path to this URL's existing path. If the provided path contains a query,
	     * then it will be added to this URL as well.
	     */
	    appendPath(path) {
	        if (path) {
	            let currentPath = this.getPath();
	            if (currentPath) {
	                if (!currentPath.endsWith("/")) {
	                    currentPath += "/";
	                }
	                if (path.startsWith("/")) {
	                    path = path.substring(1);
	                }
	                path = currentPath + path;
	            }
	            this.set(path, "PATH");
	        }
	    }
	    /**
	     * Get the path that has been set in this URL.
	     */
	    getPath() {
	        return this._path;
	    }
	    /**
	     * Set the query in this URL.
	     */
	    setQuery(query) {
	        if (!query) {
	            this._query = undefined;
	        }
	        else {
	            this._query = URLQuery.parse(query);
	        }
	    }
	    /**
	     * Set a query parameter with the provided name and value in this URL's query. If the provided
	     * query parameter value is undefined or empty, then the query parameter will be removed if it
	     * existed.
	     */
	    setQueryParameter(queryParameterName, queryParameterValue) {
	        if (queryParameterName) {
	            if (!this._query) {
	                this._query = new URLQuery();
	            }
	            this._query.set(queryParameterName, queryParameterValue);
	        }
	    }
	    /**
	     * Get the value of the query parameter with the provided query parameter name. If no query
	     * parameter exists with the provided name, then undefined will be returned.
	     */
	    getQueryParameterValue(queryParameterName) {
	        return this._query ? this._query.get(queryParameterName) : undefined;
	    }
	    /**
	     * Get the query in this URL.
	     */
	    getQuery() {
	        return this._query ? this._query.toString() : undefined;
	    }
	    /**
	     * Set the parts of this URL by parsing the provided text using the provided startState.
	     */
	    set(text, startState) {
	        const tokenizer = new URLTokenizer(text, startState);
	        while (tokenizer.next()) {
	            const token = tokenizer.current();
	            let tokenPath;
	            if (token) {
	                switch (token.type) {
	                    case "SCHEME":
	                        this._scheme = token.text || undefined;
	                        break;
	                    case "HOST":
	                        this._host = token.text || undefined;
	                        break;
	                    case "PORT":
	                        this._port = token.text || undefined;
	                        break;
	                    case "PATH":
	                        tokenPath = token.text || undefined;
	                        if (!this._path || this._path === "/" || tokenPath !== "/") {
	                            this._path = tokenPath;
	                        }
	                        break;
	                    case "QUERY":
	                        this._query = URLQuery.parse(token.text);
	                        break;
	                    default:
	                        throw new Error(`Unrecognized URLTokenType: ${token.type}`);
	                }
	            }
	        }
	    }
	    toString() {
	        let result = "";
	        if (this._scheme) {
	            result += `${this._scheme}://`;
	        }
	        if (this._host) {
	            result += this._host;
	        }
	        if (this._port) {
	            result += `:${this._port}`;
	        }
	        if (this._path) {
	            if (!this._path.startsWith("/")) {
	                result += "/";
	            }
	            result += this._path;
	        }
	        if (this._query && this._query.any()) {
	            result += `?${this._query.toString()}`;
	        }
	        return result;
	    }
	    /**
	     * If the provided searchValue is found in this URLBuilder, then replace it with the provided
	     * replaceValue.
	     */
	    replaceAll(searchValue, replaceValue) {
	        if (searchValue) {
	            this.setScheme(replaceAll(this.getScheme(), searchValue, replaceValue));
	            this.setHost(replaceAll(this.getHost(), searchValue, replaceValue));
	            this.setPort(replaceAll(this.getPort(), searchValue, replaceValue));
	            this.setPath(replaceAll(this.getPath(), searchValue, replaceValue));
	            this.setQuery(replaceAll(this.getQuery(), searchValue, replaceValue));
	        }
	    }
	    static parse(text) {
	        const result = new URLBuilder();
	        result.set(text, "SCHEME_OR_HOST");
	        return result;
	    }
	}
	class URLToken {
	    constructor(text, type) {
	        this.text = text;
	        this.type = type;
	    }
	    static scheme(text) {
	        return new URLToken(text, "SCHEME");
	    }
	    static host(text) {
	        return new URLToken(text, "HOST");
	    }
	    static port(text) {
	        return new URLToken(text, "PORT");
	    }
	    static path(text) {
	        return new URLToken(text, "PATH");
	    }
	    static query(text) {
	        return new URLToken(text, "QUERY");
	    }
	}
	/**
	 * Get whether or not the provided character (single character string) is an alphanumeric (letter or
	 * digit) character.
	 */
	function isAlphaNumericCharacter(character) {
	    const characterCode = character.charCodeAt(0);
	    return ((48 /* '0' */ <= characterCode && characterCode <= 57) /* '9' */ ||
	        (65 /* 'A' */ <= characterCode && characterCode <= 90) /* 'Z' */ ||
	        (97 /* 'a' */ <= characterCode && characterCode <= 122) /* 'z' */);
	}
	/**
	 * A class that tokenizes URL strings.
	 */
	class URLTokenizer {
	    constructor(_text, state) {
	        this._text = _text;
	        this._textLength = _text ? _text.length : 0;
	        this._currentState = state !== undefined && state !== null ? state : "SCHEME_OR_HOST";
	        this._currentIndex = 0;
	    }
	    /**
	     * Get the current URLToken this URLTokenizer is pointing at, or undefined if the URLTokenizer
	     * hasn't started or has finished tokenizing.
	     */
	    current() {
	        return this._currentToken;
	    }
	    /**
	     * Advance to the next URLToken and return whether or not a URLToken was found.
	     */
	    next() {
	        if (!hasCurrentCharacter(this)) {
	            this._currentToken = undefined;
	        }
	        else {
	            switch (this._currentState) {
	                case "SCHEME":
	                    nextScheme(this);
	                    break;
	                case "SCHEME_OR_HOST":
	                    nextSchemeOrHost(this);
	                    break;
	                case "HOST":
	                    nextHost(this);
	                    break;
	                case "PORT":
	                    nextPort(this);
	                    break;
	                case "PATH":
	                    nextPath(this);
	                    break;
	                case "QUERY":
	                    nextQuery(this);
	                    break;
	                default:
	                    throw new Error(`Unrecognized URLTokenizerState: ${this._currentState}`);
	            }
	        }
	        return !!this._currentToken;
	    }
	}
	/**
	 * Read the remaining characters from this Tokenizer's character stream.
	 */
	function readRemaining(tokenizer) {
	    let result = "";
	    if (tokenizer._currentIndex < tokenizer._textLength) {
	        result = tokenizer._text.substring(tokenizer._currentIndex);
	        tokenizer._currentIndex = tokenizer._textLength;
	    }
	    return result;
	}
	/**
	 * Whether or not this URLTokenizer has a current character.
	 */
	function hasCurrentCharacter(tokenizer) {
	    return tokenizer._currentIndex < tokenizer._textLength;
	}
	/**
	 * Get the character in the text string at the current index.
	 */
	function getCurrentCharacter(tokenizer) {
	    return tokenizer._text[tokenizer._currentIndex];
	}
	/**
	 * Advance to the character in text that is "step" characters ahead. If no step value is provided,
	 * then step will default to 1.
	 */
	function nextCharacter(tokenizer, step) {
	    if (hasCurrentCharacter(tokenizer)) {
	        if (!step) {
	            step = 1;
	        }
	        tokenizer._currentIndex += step;
	    }
	}
	/**
	 * Starting with the current character, peek "charactersToPeek" number of characters ahead in this
	 * Tokenizer's stream of characters.
	 */
	function peekCharacters(tokenizer, charactersToPeek) {
	    let endIndex = tokenizer._currentIndex + charactersToPeek;
	    if (tokenizer._textLength < endIndex) {
	        endIndex = tokenizer._textLength;
	    }
	    return tokenizer._text.substring(tokenizer._currentIndex, endIndex);
	}
	/**
	 * Read characters from this Tokenizer until the end of the stream or until the provided condition
	 * is false when provided the current character.
	 */
	function readWhile(tokenizer, condition) {
	    let result = "";
	    while (hasCurrentCharacter(tokenizer)) {
	        const currentCharacter = getCurrentCharacter(tokenizer);
	        if (!condition(currentCharacter)) {
	            break;
	        }
	        else {
	            result += currentCharacter;
	            nextCharacter(tokenizer);
	        }
	    }
	    return result;
	}
	/**
	 * Read characters from this Tokenizer until a non-alphanumeric character or the end of the
	 * character stream is reached.
	 */
	function readWhileLetterOrDigit(tokenizer) {
	    return readWhile(tokenizer, (character) => isAlphaNumericCharacter(character));
	}
	/**
	 * Read characters from this Tokenizer until one of the provided terminating characters is read or
	 * the end of the character stream is reached.
	 */
	function readUntilCharacter(tokenizer, ...terminatingCharacters) {
	    return readWhile(tokenizer, (character) => terminatingCharacters.indexOf(character) === -1);
	}
	function nextScheme(tokenizer) {
	    const scheme = readWhileLetterOrDigit(tokenizer);
	    tokenizer._currentToken = URLToken.scheme(scheme);
	    if (!hasCurrentCharacter(tokenizer)) {
	        tokenizer._currentState = "DONE";
	    }
	    else {
	        tokenizer._currentState = "HOST";
	    }
	}
	function nextSchemeOrHost(tokenizer) {
	    const schemeOrHost = readUntilCharacter(tokenizer, ":", "/", "?");
	    if (!hasCurrentCharacter(tokenizer)) {
	        tokenizer._currentToken = URLToken.host(schemeOrHost);
	        tokenizer._currentState = "DONE";
	    }
	    else if (getCurrentCharacter(tokenizer) === ":") {
	        if (peekCharacters(tokenizer, 3) === "://") {
	            tokenizer._currentToken = URLToken.scheme(schemeOrHost);
	            tokenizer._currentState = "HOST";
	        }
	        else {
	            tokenizer._currentToken = URLToken.host(schemeOrHost);
	            tokenizer._currentState = "PORT";
	        }
	    }
	    else {
	        tokenizer._currentToken = URLToken.host(schemeOrHost);
	        if (getCurrentCharacter(tokenizer) === "/") {
	            tokenizer._currentState = "PATH";
	        }
	        else {
	            tokenizer._currentState = "QUERY";
	        }
	    }
	}
	function nextHost(tokenizer) {
	    if (peekCharacters(tokenizer, 3) === "://") {
	        nextCharacter(tokenizer, 3);
	    }
	    const host = readUntilCharacter(tokenizer, ":", "/", "?");
	    tokenizer._currentToken = URLToken.host(host);
	    if (!hasCurrentCharacter(tokenizer)) {
	        tokenizer._currentState = "DONE";
	    }
	    else if (getCurrentCharacter(tokenizer) === ":") {
	        tokenizer._currentState = "PORT";
	    }
	    else if (getCurrentCharacter(tokenizer) === "/") {
	        tokenizer._currentState = "PATH";
	    }
	    else {
	        tokenizer._currentState = "QUERY";
	    }
	}
	function nextPort(tokenizer) {
	    if (getCurrentCharacter(tokenizer) === ":") {
	        nextCharacter(tokenizer);
	    }
	    const port = readUntilCharacter(tokenizer, "/", "?");
	    tokenizer._currentToken = URLToken.port(port);
	    if (!hasCurrentCharacter(tokenizer)) {
	        tokenizer._currentState = "DONE";
	    }
	    else if (getCurrentCharacter(tokenizer) === "/") {
	        tokenizer._currentState = "PATH";
	    }
	    else {
	        tokenizer._currentState = "QUERY";
	    }
	}
	function nextPath(tokenizer) {
	    const path = readUntilCharacter(tokenizer, "?");
	    tokenizer._currentToken = URLToken.path(path);
	    if (!hasCurrentCharacter(tokenizer)) {
	        tokenizer._currentState = "DONE";
	    }
	    else {
	        tokenizer._currentState = "QUERY";
	    }
	}
	function nextQuery(tokenizer) {
	    if (getCurrentCharacter(tokenizer) === "?") {
	        nextCharacter(tokenizer);
	    }
	    const query = readRemaining(tokenizer);
	    tokenizer._currentToken = URLToken.query(query);
	    tokenizer._currentState = "DONE";
	}

	// Copyright (c) Microsoft Corporation.
	const RedactedString = "REDACTED";
	const defaultAllowedHeaderNames = [
	    "x-ms-client-request-id",
	    "x-ms-return-client-request-id",
	    "x-ms-useragent",
	    "x-ms-correlation-request-id",
	    "x-ms-request-id",
	    "client-request-id",
	    "ms-cv",
	    "return-client-request-id",
	    "traceparent",
	    "Access-Control-Allow-Credentials",
	    "Access-Control-Allow-Headers",
	    "Access-Control-Allow-Methods",
	    "Access-Control-Allow-Origin",
	    "Access-Control-Expose-Headers",
	    "Access-Control-Max-Age",
	    "Access-Control-Request-Headers",
	    "Access-Control-Request-Method",
	    "Origin",
	    "Accept",
	    "Accept-Encoding",
	    "Cache-Control",
	    "Connection",
	    "Content-Length",
	    "Content-Type",
	    "Date",
	    "ETag",
	    "Expires",
	    "If-Match",
	    "If-Modified-Since",
	    "If-None-Match",
	    "If-Unmodified-Since",
	    "Last-Modified",
	    "Pragma",
	    "Request-Id",
	    "Retry-After",
	    "Server",
	    "Transfer-Encoding",
	    "User-Agent"
	];
	const defaultAllowedQueryParameters = ["api-version"];
	class Sanitizer {
	    constructor({ allowedHeaderNames = [], allowedQueryParameters = [] } = {}) {
	        allowedHeaderNames = Array.isArray(allowedHeaderNames)
	            ? defaultAllowedHeaderNames.concat(allowedHeaderNames)
	            : defaultAllowedHeaderNames;
	        allowedQueryParameters = Array.isArray(allowedQueryParameters)
	            ? defaultAllowedQueryParameters.concat(allowedQueryParameters)
	            : defaultAllowedQueryParameters;
	        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
	        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
	    }
	    sanitize(obj) {
	        const seen = new Set();
	        return JSON.stringify(obj, (key, value) => {
	            // Ensure Errors include their interesting non-enumerable members
	            if (value instanceof Error) {
	                return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
	            }
	            if (key === "_headersMap") {
	                return this.sanitizeHeaders(value);
	            }
	            else if (key === "url") {
	                return this.sanitizeUrl(value);
	            }
	            else if (key === "query") {
	                return this.sanitizeQuery(value);
	            }
	            else if (key === "body") {
	                // Don't log the request body
	                return undefined;
	            }
	            else if (key === "response") {
	                // Don't log response again
	                return undefined;
	            }
	            else if (key === "operationSpec") {
	                // When using sendOperationRequest, the request carries a massive
	                // field with the autorest spec. No need to log it.
	                return undefined;
	            }
	            else if (Array.isArray(value) || isObject(value)) {
	                if (seen.has(value)) {
	                    return "[Circular]";
	                }
	                seen.add(value);
	            }
	            return value;
	        }, 2);
	    }
	    sanitizeHeaders(value) {
	        return this.sanitizeObject(value, this.allowedHeaderNames, (v, k) => v[k].value);
	    }
	    sanitizeQuery(value) {
	        return this.sanitizeObject(value, this.allowedQueryParameters, (v, k) => v[k]);
	    }
	    sanitizeObject(value, allowedKeys, accessor) {
	        if (typeof value !== "object" || value === null) {
	            return value;
	        }
	        const sanitized = {};
	        for (const k of Object.keys(value)) {
	            if (allowedKeys.has(k.toLowerCase())) {
	                sanitized[k] = accessor(value, k);
	            }
	            else {
	                sanitized[k] = RedactedString;
	            }
	        }
	        return sanitized;
	    }
	    sanitizeUrl(value) {
	        if (typeof value !== "string" || value === null) {
	            return value;
	        }
	        const urlBuilder = URLBuilder.parse(value);
	        const queryString = urlBuilder.getQuery();
	        if (!queryString) {
	            return value;
	        }
	        const query = URLQuery.parse(queryString);
	        for (const k of query.keys()) {
	            if (!this.allowedQueryParameters.has(k.toLowerCase())) {
	                query.set(k, RedactedString);
	            }
	        }
	        urlBuilder.setQuery(query.toString());
	        return urlBuilder.toString();
	    }
	}

	// Copyright (c) Microsoft Corporation.
	const errorSanitizer = new Sanitizer();
	class RestError extends Error {
	    constructor(message, code, statusCode, request, response) {
	        super(message);
	        this.name = "RestError";
	        this.code = code;
	        this.statusCode = statusCode;
	        this.request = request;
	        this.response = response;
	        Object.setPrototypeOf(this, RestError.prototype);
	    }
	    /**
	     * Logging method for util.inspect in Node
	     */
	    [custom]() {
	        return `RestError: ${this.message} \n ${errorSanitizer.sanitize(this)}`;
	    }
	}
	RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
	RestError.PARSE_ERROR = "PARSE_ERROR";

	// Copyright (c) Microsoft Corporation.
	/**
	 * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.
	 */
	class XhrHttpClient {
	    sendRequest(request) {
	        var _a;
	        const xhr = new XMLHttpRequest();
	        if (request.proxySettings) {
	            throw new Error("HTTP proxy is not supported in browser environment");
	        }
	        const abortSignal = request.abortSignal;
	        if (abortSignal) {
	            if (abortSignal.aborted) {
	                return Promise.reject(new AbortError("The operation was aborted."));
	            }
	            const listener = () => {
	                xhr.abort();
	            };
	            abortSignal.addEventListener("abort", listener);
	            xhr.addEventListener("readystatechange", () => {
	                if (xhr.readyState === XMLHttpRequest.DONE) {
	                    abortSignal.removeEventListener("abort", listener);
	                }
	            });
	        }
	        addProgressListener(xhr.upload, request.onUploadProgress);
	        addProgressListener(xhr, request.onDownloadProgress);
	        if (request.formData) {
	            const formData = request.formData;
	            const requestForm = new FormData();
	            const appendFormValue = (key, value) => {
	                if (value &&
	                    Object.prototype.hasOwnProperty.call(value, "value") &&
	                    Object.prototype.hasOwnProperty.call(value, "options")) {
	                    requestForm.append(key, value.value, value.options);
	                }
	                else {
	                    requestForm.append(key, value);
	                }
	            };
	            for (const formKey of Object.keys(formData)) {
	                const formValue = formData[formKey];
	                if (Array.isArray(formValue)) {
	                    for (let j = 0; j < formValue.length; j++) {
	                        appendFormValue(formKey, formValue[j]);
	                    }
	                }
	                else {
	                    appendFormValue(formKey, formValue);
	                }
	            }
	            request.body = requestForm;
	            request.formData = undefined;
	            const contentType = request.headers.get("Content-Type");
	            if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
	                // browser will automatically apply a suitable content-type header
	                request.headers.remove("Content-Type");
	            }
	        }
	        xhr.open(request.method, request.url);
	        xhr.timeout = request.timeout;
	        xhr.withCredentials = request.withCredentials;
	        for (const header of request.headers.headersArray()) {
	            xhr.setRequestHeader(header.name, header.value);
	        }
	        xhr.responseType =
	            ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.size) || request.streamResponseBody ? "blob" : "text";
	        // tslint:disable-next-line:no-null-keyword
	        xhr.send(request.body === undefined ? null : request.body);
	        if (xhr.responseType === "blob") {
	            return new Promise((resolve, reject) => {
	                handleBlobResponse(xhr, request, resolve, reject);
	                rejectOnTerminalEvent(request, xhr, reject);
	            });
	        }
	        else {
	            return new Promise(function (resolve, reject) {
	                xhr.addEventListener("load", () => resolve({
	                    request,
	                    status: xhr.status,
	                    headers: parseHeaders(xhr),
	                    bodyAsText: xhr.responseText
	                }));
	                rejectOnTerminalEvent(request, xhr, reject);
	            });
	        }
	    }
	}
	function handleBlobResponse(xhr, request, res, rej) {
	    xhr.addEventListener("readystatechange", () => {
	        var _a;
	        // Resolve as soon as headers are loaded
	        if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
	            if (request.streamResponseBody || ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(xhr.status))) {
	                const blobBody = new Promise((resolve, reject) => {
	                    xhr.addEventListener("load", () => {
	                        resolve(xhr.response);
	                    });
	                    rejectOnTerminalEvent(request, xhr, reject);
	                });
	                res({
	                    request,
	                    status: xhr.status,
	                    headers: parseHeaders(xhr),
	                    blobBody
	                });
	            }
	            else {
	                xhr.addEventListener("load", () => {
	                    // xhr.response is of Blob type if the request is sent with xhr.responseType === "blob"
	                    // but the status code is not one of the stream response status codes,
	                    // so treat it as text and convert from Blob to text
	                    if (xhr.response) {
	                        // Blob.text() is not supported in IE so using FileReader instead
	                        const reader = new FileReader();
	                        reader.onload = function (e) {
	                            var _a;
	                            const text = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;
	                            res({
	                                request,
	                                status: xhr.status,
	                                headers: parseHeaders(xhr),
	                                bodyAsText: text
	                            });
	                        };
	                        reader.onerror = function (_e) {
	                            rej(reader.error);
	                        };
	                        reader.readAsText(xhr.response, "UTF-8");
	                    }
	                    else {
	                        res({
	                            request,
	                            status: xhr.status,
	                            headers: parseHeaders(xhr)
	                        });
	                    }
	                });
	            }
	        }
	    });
	}
	function addProgressListener(xhr, listener) {
	    if (listener) {
	        xhr.addEventListener("progress", (rawEvent) => listener({
	            loadedBytes: rawEvent.loaded
	        }));
	    }
	}
	// exported locally for testing
	function parseHeaders(xhr) {
	    const responseHeaders = new HttpHeaders();
	    const headerLines = xhr
	        .getAllResponseHeaders()
	        .trim()
	        .split(/[\r\n]+/);
	    for (const line of headerLines) {
	        const index = line.indexOf(":");
	        const headerName = line.slice(0, index);
	        const headerValue = line.slice(index + 2);
	        responseHeaders.set(headerName, headerValue);
	    }
	    return responseHeaders;
	}
	function rejectOnTerminalEvent(request, xhr, reject) {
	    xhr.addEventListener("error", () => reject(new RestError(`Failed to send request to ${request.url}`, RestError.REQUEST_SEND_ERROR, undefined, request)));
	    const abortError = new AbortError("The operation was aborted.");
	    xhr.addEventListener("abort", () => reject(abortError));
	    xhr.addEventListener("timeout", () => reject(abortError));
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * The different levels of logs that can be used with the HttpPipelineLogger.
	 */
	var HttpPipelineLogLevel;
	(function (HttpPipelineLogLevel) {
	    /**
	     * A log level that indicates that no logs will be logged.
	     */
	    HttpPipelineLogLevel[HttpPipelineLogLevel["OFF"] = 0] = "OFF";
	    /**
	     * An error log.
	     */
	    HttpPipelineLogLevel[HttpPipelineLogLevel["ERROR"] = 1] = "ERROR";
	    /**
	     * A warning log.
	     */
	    HttpPipelineLogLevel[HttpPipelineLogLevel["WARNING"] = 2] = "WARNING";
	    /**
	     * An information log.
	     */
	    HttpPipelineLogLevel[HttpPipelineLogLevel["INFO"] = 3] = "INFO";
	})(HttpPipelineLogLevel || (HttpPipelineLogLevel = {}));

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	function __rest(s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	}

	/**
	 * Converts an OperationOptions to a RequestOptionsBase
	 *
	 * @param opts - OperationOptions object to convert to RequestOptionsBase
	 */
	function operationOptionsToRequestOptionsBase(opts) {
	    var _a;
	    const { requestOptions, tracingOptions } = opts, additionalOptions = __rest(opts, ["requestOptions", "tracingOptions"]);
	    let result = additionalOptions;
	    if (requestOptions) {
	        result = Object.assign(Object.assign({}, result), requestOptions);
	    }
	    if (tracingOptions) {
	        result.tracingContext = tracingOptions.tracingContext;
	        // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.
	        result.spanOptions = (_a = tracingOptions) === null || _a === void 0 ? void 0 : _a.spanOptions;
	    }
	    return result;
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * Tests an object to determine whether it implements TokenCredential.
	 *
	 * @param credential - The assumed TokenCredential to be tested.
	 */
	function isTokenCredential(credential) {
	    // Check for an object with a 'getToken' function and possibly with
	    // a 'signRequest' function.  We do this check to make sure that
	    // a ServiceClientCredentials implementor (like TokenClientCredentials
	    // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
	    // it doesn't actually implement TokenCredential also.
	    const castCredential = credential;
	    return (castCredential &&
	        typeof castCredential.getToken === "function" &&
	        (castCredential.signRequest === undefined || castCredential.getToken.length > 0));
	}

	// Copyright (c) Microsoft Corporation.
	class BaseRequestPolicy {
	    constructor(_nextPolicy, _options) {
	        this._nextPolicy = _nextPolicy;
	        this._options = _options;
	    }
	    /**
	     * Get whether or not a log with the provided log level should be logged.
	     * @param logLevel - The log level of the log that will be logged.
	     * @returns Whether or not a log with the provided log level should be logged.
	     */
	    shouldLog(logLevel) {
	        return this._options.shouldLog(logLevel);
	    }
	    /**
	     * Attempt to log the provided message to the provided logger. If no logger was provided or if
	     * the log level does not meat the logger's threshold, then nothing will be logged.
	     * @param logLevel - The log level of this log.
	     * @param message - The message of this log.
	     */
	    log(logLevel, message) {
	        this._options.log(logLevel, message);
	    }
	}
	/**
	 * Optional properties that can be used when creating a RequestPolicy.
	 */
	class RequestPolicyOptions {
	    constructor(_logger) {
	        this._logger = _logger;
	    }
	    /**
	     * Get whether or not a log with the provided log level should be logged.
	     * @param logLevel - The log level of the log that will be logged.
	     * @returns Whether or not a log with the provided log level should be logged.
	     */
	    shouldLog(logLevel) {
	        return (!!this._logger &&
	            logLevel !== HttpPipelineLogLevel.OFF &&
	            logLevel <= this._logger.minimumLogLevel);
	    }
	    /**
	     * Attempt to log the provided message to the provided logger. If no logger was provided or if
	     * the log level does not meet the logger's threshold, then nothing will be logged.
	     * @param logLevel - The log level of this log.
	     * @param message - The message of this log.
	     */
	    log(logLevel, message) {
	        if (this._logger && this.shouldLog(logLevel)) {
	            this._logger.log(logLevel, message);
	        }
	    }
	}

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var logFunction = console.debug || console.log;
	function log() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    logFunction.apply(void 0, __spread(args));
	}

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var debugEnvVariable = (typeof process !== "undefined" && process.env && process.env.DEBUG) || undefined;
	var enabledString;
	var enabledNamespaces = [];
	var skippedNamespaces = [];
	var debuggers = [];
	if (debugEnvVariable) {
	    enable(debugEnvVariable);
	}
	function enable(namespaces) {
	    var e_1, _a, e_2, _b;
	    enabledString = namespaces;
	    enabledNamespaces = [];
	    skippedNamespaces = [];
	    var wildcard = /\*/g;
	    var namespaceList = namespaces.split(",").map(function (ns) { return ns.trim().replace(wildcard, ".*?"); });
	    try {
	        for (var namespaceList_1 = __values(namespaceList), namespaceList_1_1 = namespaceList_1.next(); !namespaceList_1_1.done; namespaceList_1_1 = namespaceList_1.next()) {
	            var ns = namespaceList_1_1.value;
	            if (ns.startsWith("-")) {
	                skippedNamespaces.push(new RegExp("^" + ns.substr(1) + "$"));
	            }
	            else {
	                enabledNamespaces.push(new RegExp("^" + ns + "$"));
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (namespaceList_1_1 && !namespaceList_1_1.done && (_a = namespaceList_1.return)) _a.call(namespaceList_1);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    try {
	        for (var debuggers_1 = __values(debuggers), debuggers_1_1 = debuggers_1.next(); !debuggers_1_1.done; debuggers_1_1 = debuggers_1.next()) {
	            var instance = debuggers_1_1.value;
	            instance.enabled = enabled(instance.namespace);
	        }
	    }
	    catch (e_2_1) { e_2 = { error: e_2_1 }; }
	    finally {
	        try {
	            if (debuggers_1_1 && !debuggers_1_1.done && (_b = debuggers_1.return)) _b.call(debuggers_1);
	        }
	        finally { if (e_2) throw e_2.error; }
	    }
	}
	function enabled(namespace) {
	    var e_3, _a, e_4, _b;
	    if (namespace.endsWith("*")) {
	        return true;
	    }
	    try {
	        for (var skippedNamespaces_1 = __values(skippedNamespaces), skippedNamespaces_1_1 = skippedNamespaces_1.next(); !skippedNamespaces_1_1.done; skippedNamespaces_1_1 = skippedNamespaces_1.next()) {
	            var skipped = skippedNamespaces_1_1.value;
	            if (skipped.test(namespace)) {
	                return false;
	            }
	        }
	    }
	    catch (e_3_1) { e_3 = { error: e_3_1 }; }
	    finally {
	        try {
	            if (skippedNamespaces_1_1 && !skippedNamespaces_1_1.done && (_a = skippedNamespaces_1.return)) _a.call(skippedNamespaces_1);
	        }
	        finally { if (e_3) throw e_3.error; }
	    }
	    try {
	        for (var enabledNamespaces_1 = __values(enabledNamespaces), enabledNamespaces_1_1 = enabledNamespaces_1.next(); !enabledNamespaces_1_1.done; enabledNamespaces_1_1 = enabledNamespaces_1.next()) {
	            var enabled_1 = enabledNamespaces_1_1.value;
	            if (enabled_1.test(namespace)) {
	                return true;
	            }
	        }
	    }
	    catch (e_4_1) { e_4 = { error: e_4_1 }; }
	    finally {
	        try {
	            if (enabledNamespaces_1_1 && !enabledNamespaces_1_1.done && (_b = enabledNamespaces_1.return)) _b.call(enabledNamespaces_1);
	        }
	        finally { if (e_4) throw e_4.error; }
	    }
	    return false;
	}
	function disable() {
	    var result = enabledString || "";
	    enable("");
	    return result;
	}
	function createDebugger(namespace) {
	    function debug() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (!newDebugger.enabled) {
	            return;
	        }
	        if (args.length > 0) {
	            args[0] = namespace + " " + args[0];
	        }
	        newDebugger.log.apply(newDebugger, __spread(args));
	    }
	    var newDebugger = Object.assign(debug, {
	        enabled: enabled(namespace),
	        destroy: destroy,
	        log: debugObj.log,
	        namespace: namespace,
	        extend: extend
	    });
	    debuggers.push(newDebugger);
	    return newDebugger;
	}
	function destroy() {
	    var index = debuggers.indexOf(this);
	    if (index >= 0) {
	        debuggers.splice(index, 1);
	        return true;
	    }
	    return false;
	}
	function extend(namespace) {
	    var newDebugger = createDebugger(this.namespace + ":" + namespace);
	    newDebugger.log = this.log;
	    return newDebugger;
	}
	var debugObj = Object.assign(function (namespace) {
	    return createDebugger(namespace);
	}, {
	    enable: enable,
	    enabled: enabled,
	    disable: disable,
	    log: log
	});

	// Copyright (c) Microsoft Corporation. All rights reserved.
	var registeredLoggers = new Set();
	var logLevelFromEnv = (typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;
	var azureLogLevel;
	/**
	 * The AzureLogger provides a mechanism for overriding where logs are output to.
	 * By default, logs are sent to stderr.
	 * Override the `log` method to redirect logs to another location.
	 */
	var AzureLogger = debugObj("azure");
	AzureLogger.log = function () {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    debugObj.log.apply(debugObj, __spread(args));
	};
	var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
	if (logLevelFromEnv) {
	    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
	    if (isAzureLogLevel(logLevelFromEnv)) {
	        setLogLevel(logLevelFromEnv);
	    }
	    else {
	        console.error("AZURE_LOG_LEVEL set to unknown log level '" + logLevelFromEnv + "'; logging is not enabled. Acceptable values: " + AZURE_LOG_LEVELS.join(", ") + ".");
	    }
	}
	/**
	 * Immediately enables logging at the specified log level.
	 * @param level The log level to enable for logging.
	 * Options from most verbose to least verbose are:
	 * - verbose
	 * - info
	 * - warning
	 * - error
	 */
	function setLogLevel(level) {
	    var e_1, _a;
	    if (level && !isAzureLogLevel(level)) {
	        throw new Error("Unknown log level '" + level + "'. Acceptable values: " + AZURE_LOG_LEVELS.join(","));
	    }
	    azureLogLevel = level;
	    var enabledNamespaces = [];
	    try {
	        for (var registeredLoggers_1 = __values(registeredLoggers), registeredLoggers_1_1 = registeredLoggers_1.next(); !registeredLoggers_1_1.done; registeredLoggers_1_1 = registeredLoggers_1.next()) {
	            var logger = registeredLoggers_1_1.value;
	            if (shouldEnable(logger)) {
	                enabledNamespaces.push(logger.namespace);
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (registeredLoggers_1_1 && !registeredLoggers_1_1.done && (_a = registeredLoggers_1.return)) _a.call(registeredLoggers_1);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    debugObj.enable(enabledNamespaces.join(","));
	}
	var levelMap = {
	    verbose: 400,
	    info: 300,
	    warning: 200,
	    error: 100
	};
	/**
	 * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
	 * @param namespace The name of the SDK package.
	 * @ignore
	 */
	function createClientLogger(namespace) {
	    var clientRootLogger = AzureLogger.extend(namespace);
	    patchLogMethod(AzureLogger, clientRootLogger);
	    return {
	        error: createLogger(clientRootLogger, "error"),
	        warning: createLogger(clientRootLogger, "warning"),
	        info: createLogger(clientRootLogger, "info"),
	        verbose: createLogger(clientRootLogger, "verbose")
	    };
	}
	function patchLogMethod(parent, child) {
	    child.log = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        parent.log.apply(parent, __spread(args));
	    };
	}
	function createLogger(parent, level) {
	    var logger = Object.assign(parent.extend(level), {
	        level: level
	    });
	    patchLogMethod(parent, logger);
	    if (shouldEnable(logger)) {
	        var enabledNamespaces = debugObj.disable();
	        debugObj.enable(enabledNamespaces + "," + logger.namespace);
	    }
	    registeredLoggers.add(logger);
	    return logger;
	}
	function shouldEnable(logger) {
	    if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) {
	        return true;
	    }
	    else {
	        return false;
	    }
	}
	function isAzureLogLevel(logLevel) {
	    return AZURE_LOG_LEVELS.includes(logLevel);
	}

	// Copyright (c) Microsoft Corporation.
	const logger = createClientLogger("core-http");

	// Copyright (c) Microsoft Corporation.
	function logPolicy(loggingOptions = {}) {
	    return {
	        create: (nextPolicy, options) => {
	            return new LogPolicy(nextPolicy, options, loggingOptions);
	        }
	    };
	}
	class LogPolicy extends BaseRequestPolicy {
	    constructor(nextPolicy, options, { logger: logger$1 = logger.info, allowedHeaderNames = [], allowedQueryParameters = [] } = {}) {
	        super(nextPolicy, options);
	        this.logger = logger$1;
	        this.sanitizer = new Sanitizer({ allowedHeaderNames, allowedQueryParameters });
	    }
	    /**
	     * Header names whose values will be logged when logging is enabled. Defaults to
	     * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
	     * specified in this field will be added to that list.  Any other values will
	     * be written to logs as "REDACTED".
	     * @deprecated Pass these into the constructor instead.
	     */
	    get allowedHeaderNames() {
	        return this.sanitizer.allowedHeaderNames;
	    }
	    /**
	     * Header names whose values will be logged when logging is enabled. Defaults to
	     * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
	     * specified in this field will be added to that list.  Any other values will
	     * be written to logs as "REDACTED".
	     * @deprecated Pass these into the constructor instead.
	     */
	    set allowedHeaderNames(allowedHeaderNames) {
	        this.sanitizer.allowedHeaderNames = allowedHeaderNames;
	    }
	    /**
	     * Query string names whose values will be logged when logging is enabled. By default no
	     * query string values are logged.
	     * @deprecated Pass these into the constructor instead.
	     */
	    get allowedQueryParameters() {
	        return this.sanitizer.allowedQueryParameters;
	    }
	    /**
	     * Query string names whose values will be logged when logging is enabled. By default no
	     * query string values are logged.
	     * @deprecated Pass these into the constructor instead.
	     */
	    set allowedQueryParameters(allowedQueryParameters) {
	        this.sanitizer.allowedQueryParameters = allowedQueryParameters;
	    }
	    sendRequest(request) {
	        if (!this.logger.enabled)
	            return this._nextPolicy.sendRequest(request);
	        this.logRequest(request);
	        return this._nextPolicy.sendRequest(request).then((response) => this.logResponse(response));
	    }
	    logRequest(request) {
	        this.logger(`Request: ${this.sanitizer.sanitize(request)}`);
	    }
	    logResponse(response) {
	        this.logger(`Response status code: ${response.status}`);
	        this.logger(`Headers: ${this.sanitizer.sanitize(response.headers)}`);
	        return response;
	    }
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * Get the path to this parameter's value as a dotted string (a.b.c).
	 * @param parameter - The parameter to get the path string for.
	 * @returns The path to this parameter's value as a dotted string.
	 */
	function getPathStringFromParameter(parameter) {
	    return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);
	}
	function getPathStringFromParameterPath(parameterPath, mapper) {
	    let result;
	    if (typeof parameterPath === "string") {
	        result = parameterPath;
	    }
	    else if (Array.isArray(parameterPath)) {
	        result = parameterPath.join(".");
	    }
	    else {
	        result = mapper.serializedName;
	    }
	    return result;
	}

	// Copyright (c) Microsoft Corporation.
	/**
	 * Gets the list of status codes for streaming responses.
	 * @internal
	 */
	function getStreamResponseStatusCodes(operationSpec) {
	    const result = new Set();
	    for (const statusCode in operationSpec.responses) {
	        const operationResponse = operationSpec.responses[statusCode];
	        if (operationResponse.bodyMapper &&
	            operationResponse.bodyMapper.type.name === MapperType.Stream) {
	            result.add(Number(statusCode));
	        }
	    }
	    return result;
	}

	// Copyright (c) Microsoft Corporation.
	if (!self.document || !self.DOMParser || !self.Node || !self.XMLSerializer) {
	    throw new Error(`This library depends on the following DOM objects: ["document", "DOMParser", "Node", "XMLSerializer"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. `);
	}
	const doc = document.implementation.createDocument(null, null, null);
	const parser = new DOMParser();
	function parseXML(str, opts = {}) {
	    var _a, _b, _c;
	    try {
	        const updatedOptions = {
	            rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "",
	            includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
	            xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
	        };
	        const dom = parser.parseFromString(str, "application/xml");
	        throwIfError(dom);
	        let obj;
	        if (updatedOptions.includeRoot) {
	            obj = domToObject(dom, updatedOptions);
	        }
	        else {
	            obj = domToObject(dom.childNodes[0], updatedOptions);
	        }
	        return Promise.resolve(obj);
	    }
	    catch (err) {
	        return Promise.reject(err);
	    }
	}
	let errorNS;
	function getErrorNamespace() {
	    var _a;
	    if (errorNS === undefined) {
	        try {
	            errorNS =
	                (_a = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0]
	                    .namespaceURI) !== null && _a !== void 0 ? _a : "";
	        }
	        catch (ignored) {
	            // Most browsers will return a document containing <parsererror>, but IE will throw.
	            errorNS = "";
	        }
	    }
	    return errorNS;
	}
	function throwIfError(dom) {
	    const parserErrors = dom.getElementsByTagName("parsererror");
	    if (parserErrors.length > 0 && getErrorNamespace()) {
	        for (let i = 0; i < parserErrors.length; i++) {
	            if (parserErrors[i].namespaceURI === errorNS) {
	                throw new Error(parserErrors[i].innerHTML);
	            }
	        }
	    }
	}
	function isElement(node) {
	    return !!node.attributes;
	}
	/**
	 * Get the Element-typed version of the provided Node if the provided node is an element with
	 * attributes. If it isn't, then undefined is returned.
	 */
	function asElementWithAttributes(node) {
	    return isElement(node) && node.hasAttributes() ? node : undefined;
	}
	function domToObject(node, options) {
	    let result = {};
	    const childNodeCount = node.childNodes.length;
	    const firstChildNode = node.childNodes[0];
	    const onlyChildTextValue = (firstChildNode &&
	        childNodeCount === 1 &&
	        firstChildNode.nodeType === Node.TEXT_NODE &&
	        firstChildNode.nodeValue) ||
	        undefined;
	    const elementWithAttributes = asElementWithAttributes(node);
	    if (elementWithAttributes) {
	        result[XML_ATTRKEY] = {};
	        for (let i = 0; i < elementWithAttributes.attributes.length; i++) {
	            const attr = elementWithAttributes.attributes[i];
	            result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;
	        }
	        if (onlyChildTextValue) {
	            result[options.xmlCharKey] = onlyChildTextValue;
	        }
	    }
	    else if (childNodeCount === 0) {
	        result = "";
	    }
	    else if (onlyChildTextValue) {
	        result = onlyChildTextValue;
	    }
	    if (!onlyChildTextValue) {
	        for (let i = 0; i < childNodeCount; i++) {
	            const child = node.childNodes[i];
	            // Ignore leading/trailing whitespace nodes
	            if (child.nodeType !== Node.TEXT_NODE) {
	                const childObject = domToObject(child, options);
	                if (!result[child.nodeName]) {
	                    result[child.nodeName] = childObject;
	                }
	                else if (Array.isArray(result[child.nodeName])) {
	                    result[child.nodeName].push(childObject);
	                }
	                else {
	                    result[child.nodeName] = [result[child.nodeName], childObject];
	                }
	            }
	        }
	    }
	    return result;
	}
	const serializer = new XMLSerializer();
	function stringifyXML(content, opts = {}) {
	    var _a, _b, _c;
	    const updatedOptions = {
	        rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "root",
	        includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
	        xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
	    };
	    const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];
	    return ('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + serializer.serializeToString(dom));
	}
	function buildAttributes(attrs) {
	    const result = [];
	    for (const key of Object.keys(attrs)) {
	        const attr = doc.createAttribute(key);
	        attr.value = attrs[key].toString();
	        result.push(attr);
	    }
	    return result;
	}
	function buildNode(obj, elementName, options) {
	    if (obj === undefined ||
	        obj === null ||
	        typeof obj === "string" ||
	        typeof obj === "number" ||
	        typeof obj === "boolean") {
	        const elem = doc.createElement(elementName);
	        elem.textContent = obj === undefined || obj === null ? "" : obj.toString();
	        return [elem];
	    }
	    else if (Array.isArray(obj)) {
	        const result = [];
	        for (const arrayElem of obj) {
	            for (const child of buildNode(arrayElem, elementName, options)) {
	                result.push(child);
	            }
	        }
	        return result;
	    }
	    else if (typeof obj === "object") {
	        const elem = doc.createElement(elementName);
	        for (const key of Object.keys(obj)) {
	            if (key === XML_ATTRKEY) {
	                for (const attr of buildAttributes(obj[key])) {
	                    elem.attributes.setNamedItem(attr);
	                }
	            }
	            else if (key === options.xmlCharKey) {
	                elem.textContent = obj[key].toString();
	            }
	            else {
	                for (const child of buildNode(obj[key], key, options)) {
	                    elem.appendChild(child);
	                }
	            }
	        }
	        return [elem];
	    }
	    else {
	        throw new Error(`Illegal value passed to buildObject: ${obj}`);
	    }
	}

	// Copyright (c) Microsoft Corporation.
	/**
	 * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they
	 * pass through the HTTP pipeline.
	 */
	function deserializationPolicy(deserializationContentTypes, parsingOptions) {
	    return {
	        create: (nextPolicy, options) => {
	            return new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions);
	        }
	    };
	}
	const defaultJsonContentTypes = ["application/json", "text/json"];
	const defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
	const DefaultDeserializationOptions = {
	    expectedContentTypes: {
	        json: defaultJsonContentTypes,
	        xml: defaultXmlContentTypes
	    }
	};
	/**
	 * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the
	 * HTTP pipeline.
	 */
	class DeserializationPolicy extends BaseRequestPolicy {
	    constructor(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions = {}) {
	        var _a;
	        super(nextPolicy, requestPolicyOptions);
	        this.jsonContentTypes =
	            (deserializationContentTypes && deserializationContentTypes.json) || defaultJsonContentTypes;
	        this.xmlContentTypes =
	            (deserializationContentTypes && deserializationContentTypes.xml) || defaultXmlContentTypes;
	        this.xmlCharKey = (_a = parsingOptions.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;
	    }
	    async sendRequest(request) {
	        return this._nextPolicy.sendRequest(request).then((response) => deserializeResponseBody(this.jsonContentTypes, this.xmlContentTypes, response, {
	            xmlCharKey: this.xmlCharKey
	        }));
	    }
	}
	function getOperationResponse(parsedResponse) {
	    let result;
	    const request = parsedResponse.request;
	    const operationSpec = request.operationSpec;
	    if (operationSpec) {
	        const operationResponseGetter = request.operationResponseGetter;
	        if (!operationResponseGetter) {
	            result = operationSpec.responses[parsedResponse.status];
	        }
	        else {
	            result = operationResponseGetter(operationSpec, parsedResponse);
	        }
	    }
	    return result;
	}
	function shouldDeserializeResponse(parsedResponse) {
	    const shouldDeserialize = parsedResponse.request.shouldDeserialize;
	    let result;
	    if (shouldDeserialize === undefined) {
	        result = true;
	    }
	    else if (typeof shouldDeserialize === "boolean") {
	        result = shouldDeserialize;
	    }
	    else {
	        result = shouldDeserialize(parsedResponse);
	    }
	    return result;
	}
	function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options = {}) {
	    var _a, _b, _c;
	    const updatedOptions = {
	        rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
	        includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
	        xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
	    };
	    return parse(jsonContentTypes, xmlContentTypes, response, updatedOptions).then((parsedResponse) => {
	        if (!shouldDeserializeResponse(parsedResponse)) {
	            return parsedResponse;
	        }
	        const operationSpec = parsedResponse.request.operationSpec;
	        if (!operationSpec || !operationSpec.responses) {
	            return parsedResponse;
	        }
	        const responseSpec = getOperationResponse(parsedResponse);
	        const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);
	        if (error) {
	            throw error;
	        }
	        else if (shouldReturnResponse) {
	            return parsedResponse;
	        }
	        // An operation response spec does exist for current status code, so
	        // use it to deserialize the response.
	        if (responseSpec) {
	            if (responseSpec.bodyMapper) {
	                let valueToDeserialize = parsedResponse.parsedBody;
	                if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) {
	                    valueToDeserialize =
	                        typeof valueToDeserialize === "object"
	                            ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]
	                            : [];
	                }
	                try {
	                    parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
	                }
	                catch (innerError) {
	                    const restError = new RestError(`Error ${innerError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);
	                    throw restError;
	                }
	            }
	            else if (operationSpec.httpMethod === "HEAD") {
	                // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
	                parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
	            }
	            if (responseSpec.headersMapper) {
	                parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders", options);
	            }
	        }
	        return parsedResponse;
	    });
	}
	function isOperationSpecEmpty(operationSpec) {
	    const expectedStatusCodes = Object.keys(operationSpec.responses);
	    return (expectedStatusCodes.length === 0 ||
	        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default"));
	}
	function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
	    var _a;
	    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
	    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)
	        ? isSuccessByStatus
	        : !!responseSpec;
	    if (isExpectedStatusCode) {
	        if (responseSpec) {
	            if (!responseSpec.isError) {
	                return { error: null, shouldReturnResponse: false };
	            }
	        }
	        else {
	            return { error: null, shouldReturnResponse: false };
	        }
	    }
	    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
	    const streaming = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ||
	        parsedResponse.request.streamResponseBody;
	    const initialErrorMessage = streaming
	        ? `Unexpected status code: ${parsedResponse.status}`
	        : parsedResponse.bodyAsText;
	    const error = new RestError(initialErrorMessage, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);
	    // If the item failed but there's no error spec or default spec to deserialize the error,
	    // we should fail so we just throw the parsed response
	    if (!errorResponseSpec) {
	        throw error;
	    }
	    const defaultBodyMapper = errorResponseSpec.bodyMapper;
	    const defaultHeadersMapper = errorResponseSpec.headersMapper;
	    try {
	        // If error response has a body, try to deserialize it using default body mapper.
	        // Then try to extract error code & message from it
	        if (parsedResponse.parsedBody) {
	            const parsedBody = parsedResponse.parsedBody;
	            let parsedError;
	            if (defaultBodyMapper) {
	                let valueToDeserialize = parsedBody;
	                if (operationSpec.isXML && defaultBodyMapper.type.name === MapperType.Sequence) {
	                    valueToDeserialize =
	                        typeof parsedBody === "object" ? parsedBody[defaultBodyMapper.xmlElementName] : [];
	                }
	                parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
	            }
	            const internalError = parsedBody.error || parsedError || parsedBody;
	            error.code = internalError.code;
	            if (internalError.message) {
	                error.message = internalError.message;
	            }
	            if (defaultBodyMapper) {
	                error.response.parsedBody = parsedError;
	            }
	        }
	        // If error response has headers, try to deserialize it using default header mapper
	        if (parsedResponse.headers && defaultHeadersMapper) {
	            error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders");
	        }
	    }
	    catch (defaultError) {
	        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
	    }
	    return { error, shouldReturnResponse: false };
	}
	function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts) {
	    var _a;
	    const errorHandler = (err) => {
	        const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
	        const errCode = err.code || RestError.PARSE_ERROR;
	        const e = new RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);
	        return Promise.reject(e);
	    };
	    const streaming = ((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) ||
	        operationResponse.request.streamResponseBody;
	    if (!streaming && operationResponse.bodyAsText) {
	        const text = operationResponse.bodyAsText;
	        const contentType = operationResponse.headers.get("Content-Type") || "";
	        const contentComponents = !contentType
	            ? []
	            : contentType.split(";").map((component) => component.toLowerCase());
	        if (contentComponents.length === 0 ||
	            contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
	            return new Promise((resolve) => {
	                operationResponse.parsedBody = JSON.parse(text);
	                resolve(operationResponse);
	            }).catch(errorHandler);
	        }
	        else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
	            return parseXML(text, opts)
	                .then((body) => {
	                operationResponse.parsedBody = body;
	                return operationResponse;
	            })
	                .catch(errorHandler);
	        }
	    }
	    return Promise.resolve(operationResponse);
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	const DEFAULT_CLIENT_RETRY_COUNT = 3;
	// intervals are in ms
	const DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;
	const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;
	const DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;
	function isNumber(n) {
	    return typeof n === "number";
	}
	/**
	 * @internal
	 * Determines if the operation should be retried.
	 *
	 * @param retryLimit - Specifies the max number of retries.
	 * @param predicate - Initial chekck on whether to retry based on given responses or errors
	 * @param retryData -  The retry data.
	 * @returns True if the operation qualifies for a retry; false otherwise.
	 */
	function shouldRetry(retryLimit, predicate, retryData, response, error) {
	    if (!predicate(response, error)) {
	        return false;
	    }
	    return retryData.retryCount < retryLimit;
	}
	/**
	 * @internal
	 * Updates the retry data for the next attempt.
	 *
	 * @param retryOptions - specifies retry interval, and its lower bound and upper bound.
	 * @param retryData -  The retry data.
	 * @param err - The operation"s error, if any.
	 */
	function updateRetryData(retryOptions, retryData = { retryCount: 0, retryInterval: 0 }, err) {
	    if (err) {
	        if (retryData.error) {
	            err.innerError = retryData.error;
	        }
	        retryData.error = err;
	    }
	    // Adjust retry count
	    retryData.retryCount++;
	    // Adjust retry interval
	    let incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;
	    const boundedRandDelta = retryOptions.retryInterval * 0.8 +
	        Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));
	    incrementDelta *= boundedRandDelta;
	    retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);
	    return retryData;
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * Helper TypeGuard that checks if the value is not null or undefined.
	 * @param thing - Anything
	 * @internal
	 */
	function isDefined(thing) {
	    return typeof thing !== "undefined" && thing !== null;
	}

	// Copyright (c) Microsoft Corporation.
	const StandardAbortMessage = "The operation was aborted.";
	/**
	 * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.
	 * @param delayInMs - The number of milliseconds to be delayed.
	 * @param value - The value to be resolved with after a timeout of t milliseconds.
	 * @param options - The options for delay - currently abort options
	 *   @param abortSignal - The abortSignal associated with containing operation.
	 *   @param abortErrorMsg - The abort error message associated with containing operation.
	 * @returns - Resolved promise
	 */
	function delay(delayInMs, value, options) {
	    return new Promise((resolve, reject) => {
	        let timer = undefined;
	        let onAborted = undefined;
	        const rejectOnAbort = () => {
	            return reject(new AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));
	        };
	        const removeListeners = () => {
	            if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
	                options.abortSignal.removeEventListener("abort", onAborted);
	            }
	        };
	        onAborted = () => {
	            if (isDefined(timer)) {
	                clearTimeout(timer);
	            }
	            removeListeners();
	            return rejectOnAbort();
	        };
	        if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
	            return rejectOnAbort();
	        }
	        timer = setTimeout(() => {
	            removeListeners();
	            resolve(value);
	        }, delayInMs);
	        if (options === null || options === void 0 ? void 0 : options.abortSignal) {
	            options.abortSignal.addEventListener("abort", onAborted);
	        }
	    });
	}

	// Copyright (c) Microsoft Corporation.
	function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {
	    return {
	        create: (nextPolicy, options) => {
	            return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);
	        }
	    };
	}
	/**
	 * Describes the Retry Mode type. Currently supporting only Exponential.
	 */
	var RetryMode;
	(function (RetryMode) {
	    RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
	})(RetryMode || (RetryMode = {}));
	const DefaultRetryOptions = {
	    maxRetries: DEFAULT_CLIENT_RETRY_COUNT,
	    retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,
	    maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL
	};
	/**
	 * Instantiates a new "ExponentialRetryPolicyFilter" instance.
	 */
	class ExponentialRetryPolicy extends BaseRequestPolicy {
	    /**
	     * @param nextPolicy - The next RequestPolicy in the pipeline chain.
	     * @param options - The options for this RequestPolicy.
	     * @param retryCount - The client retry count.
	     * @param retryInterval - The client retry interval, in milliseconds.
	     * @param minRetryInterval - The minimum retry interval, in milliseconds.
	     * @param maxRetryInterval - The maximum retry interval, in milliseconds.
	     */
	    constructor(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {
	        super(nextPolicy, options);
	        this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;
	        this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;
	        this.maxRetryInterval = isNumber(maxRetryInterval)
	            ? maxRetryInterval
	            : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
	    }
	    sendRequest(request) {
	        return this._nextPolicy
	            .sendRequest(request.clone())
	            .then((response) => retry(this, request, response))
	            .catch((error) => retry(this, request, error.response, undefined, error));
	    }
	}
	async function retry(policy, request, response, retryData, requestError) {
	    function shouldPolicyRetry(responseParam) {
	        const statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;
	        if (statusCode === 503 && (response === null || response === void 0 ? void 0 : response.headers.get(Constants.HeaderConstants.RETRY_AFTER))) {
	            return false;
	        }
	        if (statusCode === undefined ||
	            (statusCode < 500 && statusCode !== 408) ||
	            statusCode === 501 ||
	            statusCode === 505) {
	            return false;
	        }
	        return true;
	    }
	    retryData = updateRetryData({
	        retryInterval: policy.retryInterval,
	        minRetryInterval: 0,
	        maxRetryInterval: policy.maxRetryInterval
	    }, retryData, requestError);
	    const isAborted = request.abortSignal && request.abortSignal.aborted;
	    if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {
	        logger.info(`Retrying request in ${retryData.retryInterval}`);
	        try {
	            await delay(retryData.retryInterval);
	            const res = await policy._nextPolicy.sendRequest(request.clone());
	            return retry(policy, request, res, retryData);
	        }
	        catch (err) {
	            return retry(policy, request, response, retryData, err);
	        }
	    }
	    else if (isAborted || requestError || !response) {
	        // If the operation failed in the end, return all errors instead of just the last one
	        const err = retryData.error ||
	            new RestError("Failed to send the request.", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);
	        throw err;
	    }
	    else {
	        return response;
	    }
	}

	// Copyright (c) Microsoft Corporation.
	function generateClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
	    return {
	        create: (nextPolicy, options) => {
	            return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);
	        }
	    };
	}
	class GenerateClientRequestIdPolicy extends BaseRequestPolicy {
	    constructor(nextPolicy, options, _requestIdHeaderName) {
	        super(nextPolicy, options);
	        this._requestIdHeaderName = _requestIdHeaderName;
	    }
	    sendRequest(request) {
	        if (!request.headers.contains(this._requestIdHeaderName)) {
	            request.headers.set(this._requestIdHeaderName, request.requestId);
	        }
	        return this._nextPolicy.sendRequest(request);
	    }
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	function getDefaultUserAgentKey() {
	    return "x-ms-useragent";
	}
	function getPlatformSpecificData() {
	    const navigator = self.navigator;
	    const osInfo = {
	        key: "OS",
	        value: (navigator.oscpu || navigator.platform).replace(" ", "")
	    };
	    return [osInfo];
	}

	// Copyright (c) Microsoft Corporation.
	function getRuntimeInfo() {
	    const msRestRuntime = {
	        key: "core-http",
	        value: Constants.coreHttpVersion
	    };
	    return [msRestRuntime];
	}
	function getUserAgentString(telemetryInfo, keySeparator = " ", valueSeparator = "/") {
	    return telemetryInfo
	        .map((info) => {
	        const value = info.value ? `${valueSeparator}${info.value}` : "";
	        return `${info.key}${value}`;
	    })
	        .join(keySeparator);
	}
	const getDefaultUserAgentHeaderName = getDefaultUserAgentKey;
	function getDefaultUserAgentValue() {
	    const runtimeInfo = getRuntimeInfo();
	    const platformSpecificData = getPlatformSpecificData();
	    const userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));
	    return userAgent;
	}
	function userAgentPolicy(userAgentData) {
	    const key = !userAgentData || userAgentData.key === undefined || userAgentData.key === null
	        ? getDefaultUserAgentKey()
	        : userAgentData.key;
	    const value = !userAgentData || userAgentData.value === undefined || userAgentData.value === null
	        ? getDefaultUserAgentValue()
	        : userAgentData.value;
	    return {
	        create: (nextPolicy, options) => {
	            return new UserAgentPolicy(nextPolicy, options, key, value);
	        }
	    };
	}
	class UserAgentPolicy extends BaseRequestPolicy {
	    constructor(_nextPolicy, _options, headerKey, headerValue) {
	        super(_nextPolicy, _options);
	        this._nextPolicy = _nextPolicy;
	        this._options = _options;
	        this.headerKey = headerKey;
	        this.headerValue = headerValue;
	    }
	    sendRequest(request) {
	        this.addUserAgentHeader(request);
	        return this._nextPolicy.sendRequest(request);
	    }
	    addUserAgentHeader(request) {
	        if (!request.headers) {
	            request.headers = new HttpHeaders();
	        }
	        if (!request.headers.get(this.headerKey) && this.headerValue) {
	            request.headers.set(this.headerKey, this.headerValue);
	        }
	    }
	}

	// Copyright (c) Microsoft Corporation.
	/**
	 * Methods that are allowed to follow redirects 301 and 302
	 */
	const allowedRedirect = ["GET", "HEAD"];
	const DefaultRedirectOptions = {
	    handleRedirects: true,
	    maxRetries: 20
	};
	function redirectPolicy(maximumRetries = 20) {
	    return {
	        create: (nextPolicy, options) => {
	            return new RedirectPolicy(nextPolicy, options, maximumRetries);
	        }
	    };
	}
	class RedirectPolicy extends BaseRequestPolicy {
	    constructor(nextPolicy, options, maxRetries = 20) {
	        super(nextPolicy, options);
	        this.maxRetries = maxRetries;
	    }
	    sendRequest(request) {
	        return this._nextPolicy
	            .sendRequest(request)
	            .then((response) => handleRedirect(this, response, 0));
	    }
	}
	function handleRedirect(policy, response, currentRetries) {
	    const { request, status } = response;
	    const locationHeader = response.headers.get("location");
	    if (locationHeader &&
	        (status === 300 ||
	            (status === 301 && allowedRedirect.includes(request.method)) ||
	            (status === 302 && allowedRedirect.includes(request.method)) ||
	            (status === 303 && request.method === "POST") ||
	            status === 307) &&
	        (!policy.maxRetries || currentRetries < policy.maxRetries)) {
	        const builder = URLBuilder.parse(request.url);
	        builder.setPath(locationHeader);
	        request.url = builder.toString();
	        // POST request with Status code 303 should be converted into a
	        // redirected GET request if the redirect url is present in the location header
	        if (status === 303) {
	            request.method = "GET";
	            delete request.body;
	        }
	        return policy._nextPolicy
	            .sendRequest(request)
	            .then((res) => handleRedirect(policy, res, currentRetries + 1));
	    }
	    return Promise.resolve(response);
	}

	// Copyright (c) Microsoft Corporation.
	function rpRegistrationPolicy(retryTimeout = 30) {
	    return {
	        create: (nextPolicy, options) => {
	            return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);
	        }
	    };
	}
	class RPRegistrationPolicy extends BaseRequestPolicy {
	    constructor(nextPolicy, options, _retryTimeout = 30) {
	        super(nextPolicy, options);
	        this._retryTimeout = _retryTimeout;
	    }
	    sendRequest(request) {
	        return this._nextPolicy
	            .sendRequest(request.clone())
	            .then((response) => registerIfNeeded(this, request, response));
	    }
	}
	function registerIfNeeded(policy, request, response) {
	    if (response.status === 409) {
	        const rpName = checkRPNotRegisteredError(response.bodyAsText);
	        if (rpName) {
	            const urlPrefix = extractSubscriptionUrl(request.url);
	            return (registerRP(policy, urlPrefix, rpName, request)
	                // Autoregistration of ${provider} failed for some reason. We will not return this error
	                // instead will return the initial response with 409 status code back to the user.
	                // do nothing here as we are returning the original response at the end of this method.
	                .catch(() => false)
	                .then((registrationStatus) => {
	                if (registrationStatus) {
	                    // Retry the original request. We have to change the x-ms-client-request-id
	                    // otherwise Azure endpoint will return the initial 409 (cached) response.
	                    request.headers.set("x-ms-client-request-id", generateUuid());
	                    return policy._nextPolicy.sendRequest(request.clone());
	                }
	                return response;
	            }));
	        }
	    }
	    return Promise.resolve(response);
	}
	/**
	 * Reuses the headers of the original request and url (if specified).
	 * @param originalRequest - The original request
	 * @param reuseUrlToo - Should the url from the original request be reused as well. Default false.
	 * @returns A new request object with desired headers.
	 */
	function getRequestEssentials(originalRequest, reuseUrlToo = false) {
	    const reqOptions = originalRequest.clone();
	    if (reuseUrlToo) {
	        reqOptions.url = originalRequest.url;
	    }
	    // We have to change the x-ms-client-request-id otherwise Azure endpoint
	    // will return the initial 409 (cached) response.
	    reqOptions.headers.set("x-ms-client-request-id", generateUuid());
	    // Set content-type to application/json
	    reqOptions.headers.set("Content-Type", "application/json; charset=utf-8");
	    return reqOptions;
	}
	/**
	 * Validates the error code and message associated with 409 response status code. If it matches to that of
	 * RP not registered then it returns the name of the RP else returns undefined.
	 * @param body - The response body received after making the original request.
	 * @returns The name of the RP if condition is satisfied else undefined.
	 */
	function checkRPNotRegisteredError(body) {
	    let result, responseBody;
	    if (body) {
	        try {
	            responseBody = JSON.parse(body);
	        }
	        catch (err) {
	            // do nothing;
	        }
	        if (responseBody &&
	            responseBody.error &&
	            responseBody.error.message &&
	            responseBody.error.code &&
	            responseBody.error.code === "MissingSubscriptionRegistration") {
	            const matchRes = responseBody.error.message.match(/.*'(.*)'/i);
	            if (matchRes) {
	                result = matchRes.pop();
	            }
	        }
	    }
	    return result;
	}
	/**
	 * Extracts the first part of the URL, just after subscription:
	 * https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
	 * @param url - The original request url
	 * @returns The url prefix as explained above.
	 */
	function extractSubscriptionUrl(url) {
	    let result;
	    const matchRes = url.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);
	    if (matchRes && matchRes[0]) {
	        result = matchRes[0];
	    }
	    else {
	        throw new Error(`Unable to extract subscriptionId from the given url - ${url}.`);
	    }
	    return result;
	}
	/**
	 * Registers the given provider.
	 * @param policy - The RPRegistrationPolicy this function is being called against.
	 * @param urlPrefix - https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
	 * @param provider - The provider name to be registered.
	 * @param originalRequest - The original request sent by the user that returned a 409 response
	 * with a message that the provider is not registered.
	 */
	async function registerRP(policy, urlPrefix, provider, originalRequest) {
	    const postUrl = `${urlPrefix}providers/${provider}/register?api-version=2016-02-01`;
	    const getUrl = `${urlPrefix}providers/${provider}?api-version=2016-02-01`;
	    const reqOptions = getRequestEssentials(originalRequest);
	    reqOptions.method = "POST";
	    reqOptions.url = postUrl;
	    const response = await policy._nextPolicy.sendRequest(reqOptions);
	    if (response.status !== 200) {
	        throw new Error(`Autoregistration of ${provider} failed. Please try registering manually.`);
	    }
	    return getRegistrationStatus(policy, getUrl, originalRequest);
	}
	/**
	 * Polls the registration status of the provider that was registered. Polling happens at an interval of 30 seconds.
	 * Polling will happen till the registrationState property of the response body is "Registered".
	 * @param policy - The RPRegistrationPolicy this function is being called against.
	 * @param url - The request url for polling
	 * @param originalRequest - The original request sent by the user that returned a 409 response
	 * with a message that the provider is not registered.
	 * @returns True if RP Registration is successful.
	 */
	async function getRegistrationStatus(policy, url, originalRequest) {
	    const reqOptions = getRequestEssentials(originalRequest);
	    reqOptions.url = url;
	    reqOptions.method = "GET";
	    const res = await policy._nextPolicy.sendRequest(reqOptions);
	    const obj = res.parsedBody;
	    if (res.parsedBody && obj.registrationState && obj.registrationState === "Registered") {
	        return true;
	    }
	    else {
	        await delay(policy._retryTimeout * 1000);
	        return getRegistrationStatus(policy, url, originalRequest);
	    }
	}

	// Copyright (c) Microsoft Corporation.
	// Default options for the cycler if none are provided
	const DEFAULT_CYCLER_OPTIONS = {
	    forcedRefreshWindowInMs: 1000,
	    retryIntervalInMs: 3000,
	    refreshWindowInMs: 1000 * 60 * 2 // Start refreshing 2m before expiry
	};
	/**
	 * Converts an an unreliable access token getter (which may resolve with null)
	 * into an AccessTokenGetter by retrying the unreliable getter in a regular
	 * interval.
	 *
	 * @param getAccessToken - a function that produces a promise of an access
	 * token that may fail by returning null
	 * @param retryIntervalInMs - the time (in milliseconds) to wait between retry
	 * attempts
	 * @param timeoutInMs - the timestamp after which the refresh attempt will fail,
	 * throwing an exception
	 * @returns - a promise that, if it resolves, will resolve with an access token
	 */
	async function beginRefresh(getAccessToken, retryIntervalInMs, timeoutInMs) {
	    // This wrapper handles exceptions gracefully as long as we haven't exceeded
	    // the timeout.
	    async function tryGetAccessToken() {
	        if (Date.now() < timeoutInMs) {
	            try {
	                return await getAccessToken();
	            }
	            catch (_a) {
	                return null;
	            }
	        }
	        else {
	            const finalToken = await getAccessToken();
	            // Timeout is up, so throw if it's still null
	            if (finalToken === null) {
	                throw new Error("Failed to refresh access token.");
	            }
	            return finalToken;
	        }
	    }
	    let token = await tryGetAccessToken();
	    while (token === null) {
	        await delay(retryIntervalInMs);
	        token = await tryGetAccessToken();
	    }
	    return token;
	}
	/**
	 * Creates a token cycler from a credential, scopes, and optional settings.
	 *
	 * A token cycler represents a way to reliably retrieve a valid access token
	 * from a TokenCredential. It will handle initializing the token, refreshing it
	 * when it nears expiration, and synchronizes refresh attempts to avoid
	 * concurrency hazards.
	 *
	 * @param credential - the underlying TokenCredential that provides the access
	 * token
	 * @param scopes - the scopes to request authorization for
	 * @param tokenCyclerOptions - optionally override default settings for the cycler
	 *
	 * @returns - a function that reliably produces a valid access token
	 */
	function createTokenCycler(credential, scopes, tokenCyclerOptions) {
	    let refreshWorker = null;
	    let token = null;
	    const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
	    /**
	     * This little holder defines several predicates that we use to construct
	     * the rules of refreshing the token.
	     */
	    const cycler = {
	        /**
	         * Produces true if a refresh job is currently in progress.
	         */
	        get isRefreshing() {
	            return refreshWorker !== null;
	        },
	        /**
	         * Produces true if the cycler SHOULD refresh (we are within the refresh
	         * window and not already refreshing)
	         */
	        get shouldRefresh() {
	            var _a;
	            return (!cycler.isRefreshing &&
	                ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now());
	        },
	        /**
	         * Produces true if the cycler MUST refresh (null or nearly-expired
	         * token).
	         */
	        get mustRefresh() {
	            return (token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now());
	        }
	    };
	    /**
	     * Starts a refresh job or returns the existing job if one is already
	     * running.
	     */
	    function refresh(getTokenOptions) {
	        var _a;
	        if (!cycler.isRefreshing) {
	            // We bind `scopes` here to avoid passing it around a lot
	            const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
	            // Take advantage of promise chaining to insert an assignment to `token`
	            // before the refresh can be considered done.
	            refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, 
	            // If we don't have a token, then we should timeout immediately
	            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now())
	                .then((_token) => {
	                refreshWorker = null;
	                token = _token;
	                return token;
	            })
	                .catch((reason) => {
	                // We also should reset the refresher if we enter a failed state.  All
	                // existing awaiters will throw, but subsequent requests will start a
	                // new retry chain.
	                refreshWorker = null;
	                token = null;
	                throw reason;
	            });
	        }
	        return refreshWorker;
	    }
	    return async (tokenOptions) => {
	        //
	        // Simple rules:
	        // - If we MUST refresh, then return the refresh task, blocking
	        //   the pipeline until a token is available.
	        // - If we SHOULD refresh, then run refresh but don't return it
	        //   (we can still use the cached token).
	        // - Return the token, since it's fine if we didn't return in
	        //   step 1.
	        //
	        if (cycler.mustRefresh)
	            return refresh(tokenOptions);
	        if (cycler.shouldRefresh) {
	            refresh(tokenOptions);
	        }
	        return token;
	    };
	}
	// #endregion
	/**
	 * Creates a new factory for a RequestPolicy that applies a bearer token to
	 * the requests' `Authorization` headers.
	 *
	 * @param credential - The TokenCredential implementation that can supply the bearer token.
	 * @param scopes - The scopes for which the bearer token applies.
	 */
	function bearerTokenAuthenticationPolicy(credential, scopes) {
	    // This simple function encapsulates the entire process of reliably retrieving the token
	    const getToken = createTokenCycler(credential, scopes /* , options */);
	    class BearerTokenAuthenticationPolicy extends BaseRequestPolicy {
	        constructor(nextPolicy, options) {
	            super(nextPolicy, options);
	        }
	        async sendRequest(webResource) {
	            if (!webResource.url.toLowerCase().startsWith("https://")) {
	                throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
	            }
	            const { token } = await getToken({
	                abortSignal: webResource.abortSignal,
	                tracingOptions: {
	                    tracingContext: webResource.tracingContext
	                }
	            });
	            webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);
	            return this._nextPolicy.sendRequest(webResource);
	        }
	    }
	    return {
	        create: (nextPolicy, options) => {
	            return new BearerTokenAuthenticationPolicy(nextPolicy, options);
	        }
	    };
	}

	// Copyright (c) Microsoft Corporation.
	function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
	    return {
	        create: (nextPolicy, options) => {
	            return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);
	        }
	    };
	}
	/**
	 * @param retryCount - The client retry count.
	 * @param retryInterval - The client retry interval, in milliseconds.
	 * @param minRetryInterval - The minimum retry interval, in milliseconds.
	 * @param maxRetryInterval - The maximum retry interval, in milliseconds.
	 */
	class SystemErrorRetryPolicy extends BaseRequestPolicy {
	    constructor(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
	        super(nextPolicy, options);
	        this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;
	        this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;
	        this.minRetryInterval = isNumber(minRetryInterval)
	            ? minRetryInterval
	            : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
	        this.maxRetryInterval = isNumber(maxRetryInterval)
	            ? maxRetryInterval
	            : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
	    }
	    sendRequest(request) {
	        return this._nextPolicy
	            .sendRequest(request.clone())
	            .catch((error) => retry$1(this, request, error.response, error));
	    }
	}
	async function retry$1(policy, request, operationResponse, err, retryData) {
	    retryData = updateRetryData(policy, retryData, err);
	    function shouldPolicyRetry(_response, error) {
	        if (error &&
	            error.code &&
	            (error.code === "ETIMEDOUT" ||
	                error.code === "ESOCKETTIMEDOUT" ||
	                error.code === "ECONNREFUSED" ||
	                error.code === "ECONNRESET" ||
	                error.code === "ENOENT")) {
	            return true;
	        }
	        return false;
	    }
	    if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) {
	        // If previous operation ended with an error and the policy allows a retry, do that
	        try {
	            await delay(retryData.retryInterval);
	            return policy._nextPolicy.sendRequest(request.clone());
	        }
	        catch (nestedErr) {
	            return retry$1(policy, request, operationResponse, nestedErr, retryData);
	        }
	    }
	    else {
	        if (err) {
	            // If the operation failed in the end, return all errors instead of just the last one
	            return Promise.reject(retryData.error);
	        }
	        return operationResponse;
	    }
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * The format that will be used to join an array of values together for a query parameter value.
	 */
	var QueryCollectionFormat;
	(function (QueryCollectionFormat) {
	    QueryCollectionFormat["Csv"] = ",";
	    QueryCollectionFormat["Ssv"] = " ";
	    QueryCollectionFormat["Tsv"] = "\t";
	    QueryCollectionFormat["Pipes"] = "|";
	    QueryCollectionFormat["Multi"] = "Multi";
	})(QueryCollectionFormat || (QueryCollectionFormat = {}));

	// Copyright (c) Microsoft Corporation.
	const proxyNotSupportedInBrowser = new Error("ProxyPolicy is not supported in browser environment");
	function getDefaultProxySettings(_proxyUrl) {
	    return undefined;
	}
	function proxyPolicy(_proxySettings) {
	    return {
	        create: (_nextPolicy, _options) => {
	            throw proxyNotSupportedInBrowser;
	        }
	    };
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * Maximum number of retries for the throttling retry policy
	 */
	const DEFAULT_CLIENT_MAX_RETRY_COUNT = 3;

	// Copyright (c) Microsoft Corporation.
	const StatusCodes = Constants.HttpConstants.StatusCodes;
	function throttlingRetryPolicy() {
	    return {
	        create: (nextPolicy, options) => {
	            return new ThrottlingRetryPolicy(nextPolicy, options);
	        }
	    };
	}
	const StandardAbortMessage$1 = "The operation was aborted.";
	/**
	 * To learn more, please refer to
	 * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,
	 * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and
	 * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
	 */
	class ThrottlingRetryPolicy extends BaseRequestPolicy {
	    constructor(nextPolicy, options, _handleResponse) {
	        super(nextPolicy, options);
	        this.numberOfRetries = 0;
	        this._handleResponse = _handleResponse || this._defaultResponseHandler;
	    }
	    async sendRequest(httpRequest) {
	        const response = await this._nextPolicy.sendRequest(httpRequest.clone());
	        if (response.status !== StatusCodes.TooManyRequests &&
	            response.status !== StatusCodes.ServiceUnavailable) {
	            return response;
	        }
	        else {
	            return this._handleResponse(httpRequest, response);
	        }
	    }
	    async _defaultResponseHandler(httpRequest, httpResponse) {
	        var _a;
	        const retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);
	        if (retryAfterHeader) {
	            const delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);
	            if (delayInMs) {
	                this.numberOfRetries += 1;
	                await delay(delayInMs, undefined, {
	                    abortSignal: httpRequest.abortSignal,
	                    abortErrorMsg: StandardAbortMessage$1
	                });
	                if ((_a = httpRequest.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
	                    throw new AbortError(StandardAbortMessage$1);
	                }
	                if (this.numberOfRetries < DEFAULT_CLIENT_MAX_RETRY_COUNT) {
	                    return this.sendRequest(httpRequest);
	                }
	                else {
	                    return this._nextPolicy.sendRequest(httpRequest);
	                }
	            }
	        }
	        return httpResponse;
	    }
	    static parseRetryAfterHeader(headerValue) {
	        const retryAfterInSeconds = Number(headerValue);
	        if (Number.isNaN(retryAfterInSeconds)) {
	            return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
	        }
	        else {
	            return retryAfterInSeconds * 1000;
	        }
	    }
	    static parseDateRetryAfterHeader(headerValue) {
	        try {
	            const now = Date.now();
	            const date = Date.parse(headerValue);
	            const diff = date - now;
	            return Number.isNaN(diff) ? undefined : diff;
	        }
	        catch (error) {
	            return undefined;
	        }
	    }
	}

	// Copyright (c) Microsoft Corporation.
	function signingPolicy(authenticationProvider) {
	    return {
	        create: (nextPolicy, options) => {
	            return new SigningPolicy(nextPolicy, options, authenticationProvider);
	        }
	    };
	}
	class SigningPolicy extends BaseRequestPolicy {
	    constructor(nextPolicy, options, authenticationProvider) {
	        super(nextPolicy, options);
	        this.authenticationProvider = authenticationProvider;
	    }
	    signRequest(request) {
	        return this.authenticationProvider.signRequest(request);
	    }
	    sendRequest(request) {
	        return this.signRequest(request).then((nextRequest) => this._nextPolicy.sendRequest(nextRequest));
	    }
	}

	// Copyright (c) Microsoft Corporation.
	const DefaultKeepAliveOptions = {
	    enable: true
	};
	function keepAlivePolicy(keepAliveOptions) {
	    return {
	        create: (nextPolicy, options) => {
	            return new KeepAlivePolicy(nextPolicy, options, keepAliveOptions || DefaultKeepAliveOptions);
	        }
	    };
	}
	/**
	 * KeepAlivePolicy is a policy used to control keep alive settings for every request.
	 */
	class KeepAlivePolicy extends BaseRequestPolicy {
	    /**
	     * Creates an instance of KeepAlivePolicy.
	     *
	     * @param nextPolicy -
	     * @param options -
	     * @param keepAliveOptions -
	     */
	    constructor(nextPolicy, options, keepAliveOptions) {
	        super(nextPolicy, options);
	        this.keepAliveOptions = keepAliveOptions;
	    }
	    /**
	     * Sends out request.
	     *
	     * @param request -
	     * @returns
	     */
	    async sendRequest(request) {
	        request.keepAlive = this.keepAliveOptions.enable;
	        return this._nextPolicy.sendRequest(request);
	    }
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/** only globals that common to node and browsers are allowed */
	// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
	var _globalThis = typeof globalThis === 'object' ? globalThis : window;

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	// this is autogenerated file, see scripts/version-update.js
	var VERSION = '1.0.3';

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
	/**
	 * Create a function to test an API version to see if it is compatible with the provided ownVersion.
	 *
	 * The returned function has the following semantics:
	 * - Exact match is always compatible
	 * - Major versions must match exactly
	 *    - 1.x package cannot use global 2.x package
	 *    - 2.x package cannot use global 1.x package
	 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
	 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
	 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
	 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
	 * - Patch and build tag differences are not considered at this time
	 *
	 * @param ownVersion version which should be checked against
	 */
	function _makeCompatibilityCheck(ownVersion) {
	    var acceptedVersions = new Set([ownVersion]);
	    var rejectedVersions = new Set();
	    var myVersionMatch = ownVersion.match(re);
	    if (!myVersionMatch) {
	        // we cannot guarantee compatibility so we always return noop
	        return function () { return false; };
	    }
	    var ownVersionParsed = {
	        major: +myVersionMatch[1],
	        minor: +myVersionMatch[2],
	        patch: +myVersionMatch[3],
	        prerelease: myVersionMatch[4],
	    };
	    // if ownVersion has a prerelease tag, versions must match exactly
	    if (ownVersionParsed.prerelease != null) {
	        return function isExactmatch(globalVersion) {
	            return globalVersion === ownVersion;
	        };
	    }
	    function _reject(v) {
	        rejectedVersions.add(v);
	        return false;
	    }
	    function _accept(v) {
	        acceptedVersions.add(v);
	        return true;
	    }
	    return function isCompatible(globalVersion) {
	        if (acceptedVersions.has(globalVersion)) {
	            return true;
	        }
	        if (rejectedVersions.has(globalVersion)) {
	            return false;
	        }
	        var globalVersionMatch = globalVersion.match(re);
	        if (!globalVersionMatch) {
	            // cannot parse other version
	            // we cannot guarantee compatibility so we always noop
	            return _reject(globalVersion);
	        }
	        var globalVersionParsed = {
	            major: +globalVersionMatch[1],
	            minor: +globalVersionMatch[2],
	            patch: +globalVersionMatch[3],
	            prerelease: globalVersionMatch[4],
	        };
	        // if globalVersion has a prerelease tag, versions must match exactly
	        if (globalVersionParsed.prerelease != null) {
	            return _reject(globalVersion);
	        }
	        // major versions must match
	        if (ownVersionParsed.major !== globalVersionParsed.major) {
	            return _reject(globalVersion);
	        }
	        if (ownVersionParsed.major === 0) {
	            if (ownVersionParsed.minor === globalVersionParsed.minor &&
	                ownVersionParsed.patch <= globalVersionParsed.patch) {
	                return _accept(globalVersion);
	            }
	            return _reject(globalVersion);
	        }
	        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
	            return _accept(globalVersion);
	        }
	        return _reject(globalVersion);
	    };
	}
	/**
	 * Test an API version to see if it is compatible with this API.
	 *
	 * - Exact match is always compatible
	 * - Major versions must match exactly
	 *    - 1.x package cannot use global 2.x package
	 *    - 2.x package cannot use global 1.x package
	 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
	 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
	 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
	 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
	 * - Patch and build tag differences are not considered at this time
	 *
	 * @param version version of the API requesting an instance of the global API
	 */
	var isCompatible = _makeCompatibilityCheck(VERSION);

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var major = VERSION.split('.')[0];
	var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
	var _global = _globalThis;
	function registerGlobal(type, instance, diag, allowOverride) {
	    var _a;
	    if (allowOverride === void 0) { allowOverride = false; }
	    var api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
	        version: VERSION,
	    });
	    if (!allowOverride && api[type]) {
	        // already registered an API of this type
	        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
	        diag.error(err.stack || err.message);
	        return false;
	    }
	    if (api.version !== VERSION) {
	        // All registered APIs must be of the same version exactly
	        var err = new Error('@opentelemetry/api: All API registration versions must match');
	        diag.error(err.stack || err.message);
	        return false;
	    }
	    api[type] = instance;
	    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
	    return true;
	}
	function getGlobal(type) {
	    var _a, _b;
	    var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
	    if (!globalVersion || !isCompatible(globalVersion)) {
	        return;
	    }
	    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
	}
	function unregisterGlobal(type, diag) {
	    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
	    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
	    if (api) {
	        delete api[type];
	    }
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * Component Logger which is meant to be used as part of any component which
	 * will add automatically additional namespace in front of the log message.
	 * It will then forward all message to global diag logger
	 * @example
	 * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
	 * cLogger.debug('test');
	 * // @opentelemetry/instrumentation-http test
	 */
	var DiagComponentLogger = /** @class */ (function () {
	    function DiagComponentLogger(props) {
	        this._namespace = props.namespace || 'DiagComponentLogger';
	    }
	    DiagComponentLogger.prototype.debug = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return logProxy('debug', this._namespace, args);
	    };
	    DiagComponentLogger.prototype.error = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return logProxy('error', this._namespace, args);
	    };
	    DiagComponentLogger.prototype.info = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return logProxy('info', this._namespace, args);
	    };
	    DiagComponentLogger.prototype.warn = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return logProxy('warn', this._namespace, args);
	    };
	    DiagComponentLogger.prototype.verbose = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return logProxy('verbose', this._namespace, args);
	    };
	    return DiagComponentLogger;
	}());
	function logProxy(funcName, namespace, args) {
	    var logger = getGlobal('diag');
	    // shortcut if logger not set
	    if (!logger) {
	        return;
	    }
	    args.unshift(namespace);
	    return logger[funcName].apply(logger, args);
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * Defines the available internal logging levels for the diagnostic logger, the numeric values
	 * of the levels are defined to match the original values from the initial LogLevel to avoid
	 * compatibility/migration issues for any implementation that assume the numeric ordering.
	 */
	var DiagLogLevel;
	(function (DiagLogLevel) {
	    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
	    DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
	    /** Identifies an error scenario */
	    DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
	    /** Identifies a warning scenario */
	    DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
	    /** General informational log message */
	    DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
	    /** General debug log message */
	    DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
	    /**
	     * Detailed trace level logging should only be used for development, should only be set
	     * in a development environment.
	     */
	    DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
	    /** Used to set the logging level to include all logging */
	    DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
	})(DiagLogLevel || (DiagLogLevel = {}));

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	function createLogLevelDiagLogger(maxLevel, logger) {
	    if (maxLevel < DiagLogLevel.NONE) {
	        maxLevel = DiagLogLevel.NONE;
	    }
	    else if (maxLevel > DiagLogLevel.ALL) {
	        maxLevel = DiagLogLevel.ALL;
	    }
	    // In case the logger is null or undefined
	    logger = logger || {};
	    function _filterFunc(funcName, theLevel) {
	        var theFunc = logger[funcName];
	        if (typeof theFunc === 'function' && maxLevel >= theLevel) {
	            return theFunc.bind(logger);
	        }
	        return function () { };
	    }
	    return {
	        error: _filterFunc('error', DiagLogLevel.ERROR),
	        warn: _filterFunc('warn', DiagLogLevel.WARN),
	        info: _filterFunc('info', DiagLogLevel.INFO),
	        debug: _filterFunc('debug', DiagLogLevel.DEBUG),
	        verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),
	    };
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var API_NAME = 'diag';
	/**
	 * Singleton object which represents the entry point to the OpenTelemetry internal
	 * diagnostic API
	 */
	var DiagAPI = /** @class */ (function () {
	    /**
	     * Private internal constructor
	     * @private
	     */
	    function DiagAPI() {
	        function _logProxy(funcName) {
	            return function () {
	                var logger = getGlobal('diag');
	                // shortcut if logger not set
	                if (!logger)
	                    return;
	                return logger[funcName].apply(logger, 
	                // work around Function.prototype.apply types
	                // eslint-disable-next-line @typescript-eslint/no-explicit-any
	                arguments);
	            };
	        }
	        // Using self local variable for minification purposes as 'this' cannot be minified
	        var self = this;
	        // DiagAPI specific functions
	        self.setLogger = function (logger, logLevel) {
	            var _a, _b;
	            if (logLevel === void 0) { logLevel = DiagLogLevel.INFO; }
	            if (logger === self) {
	                // There isn't much we can do here.
	                // Logging to the console might break the user application.
	                // Try to log to self. If a logger was previously registered it will receive the log.
	                var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
	                self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
	                return false;
	            }
	            var oldLogger = getGlobal('diag');
	            var newLogger = createLogLevelDiagLogger(logLevel, logger);
	            // There already is an logger registered. We'll let it know before overwriting it.
	            if (oldLogger) {
	                var stack = (_b = new Error().stack) !== null && _b !== void 0 ? _b : '<failed to generate stacktrace>';
	                oldLogger.warn("Current logger will be overwritten from " + stack);
	                newLogger.warn("Current logger will overwrite one already registered from " + stack);
	            }
	            return registerGlobal('diag', newLogger, self, true);
	        };
	        self.disable = function () {
	            unregisterGlobal(API_NAME, self);
	        };
	        self.createComponentLogger = function (options) {
	            return new DiagComponentLogger(options);
	        };
	        self.verbose = _logProxy('verbose');
	        self.debug = _logProxy('debug');
	        self.info = _logProxy('info');
	        self.warn = _logProxy('warn');
	        self.error = _logProxy('error');
	    }
	    /** Get the singleton instance of the DiagAPI API */
	    DiagAPI.instance = function () {
	        if (!this._instance) {
	            this._instance = new DiagAPI();
	        }
	        return this._instance;
	    };
	    return DiagAPI;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var BaggageImpl = /** @class */ (function () {
	    function BaggageImpl(entries) {
	        this._entries = entries ? new Map(entries) : new Map();
	    }
	    BaggageImpl.prototype.getEntry = function (key) {
	        var entry = this._entries.get(key);
	        if (!entry) {
	            return undefined;
	        }
	        return Object.assign({}, entry);
	    };
	    BaggageImpl.prototype.getAllEntries = function () {
	        return Array.from(this._entries.entries()).map(function (_a) {
	            var k = _a[0], v = _a[1];
	            return [k, v];
	        });
	    };
	    BaggageImpl.prototype.setEntry = function (key, entry) {
	        var newBaggage = new BaggageImpl(this._entries);
	        newBaggage._entries.set(key, entry);
	        return newBaggage;
	    };
	    BaggageImpl.prototype.removeEntry = function (key) {
	        var newBaggage = new BaggageImpl(this._entries);
	        newBaggage._entries.delete(key);
	        return newBaggage;
	    };
	    BaggageImpl.prototype.removeEntries = function () {
	        var keys = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            keys[_i] = arguments[_i];
	        }
	        var newBaggage = new BaggageImpl(this._entries);
	        for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {
	            var key = keys_1[_a];
	            newBaggage._entries.delete(key);
	        }
	        return newBaggage;
	    };
	    BaggageImpl.prototype.clear = function () {
	        return new BaggageImpl();
	    };
	    return BaggageImpl;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var diag = DiagAPI.instance();
	/**
	 * Create a new Baggage with optional entries
	 *
	 * @param entries An array of baggage entries the new baggage should contain
	 */
	function createBaggage(entries) {
	    if (entries === void 0) { entries = {}; }
	    return new BaggageImpl(new Map(Object.entries(entries)));
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var defaultTextMapGetter = {
	    get: function (carrier, key) {
	        if (carrier == null) {
	            return undefined;
	        }
	        return carrier[key];
	    },
	    keys: function (carrier) {
	        if (carrier == null) {
	            return [];
	        }
	        return Object.keys(carrier);
	    },
	};
	var defaultTextMapSetter = {
	    set: function (carrier, key, value) {
	        if (carrier == null) {
	            return;
	        }
	        carrier[key] = value;
	    },
	};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/** Get a key to uniquely identify a context value */
	function createContextKey(description) {
	    // The specification states that for the same input, multiple calls should
	    // return different keys. Due to the nature of the JS dependency management
	    // system, this creates problems where multiple versions of some package
	    // could hold different keys for the same property.
	    //
	    // Therefore, we use Symbol.for which returns the same key for the same input.
	    return Symbol.for(description);
	}
	var BaseContext = /** @class */ (function () {
	    /**
	     * Construct a new context which inherits values from an optional parent context.
	     *
	     * @param parentContext a context from which to inherit values
	     */
	    function BaseContext(parentContext) {
	        // for minification
	        var self = this;
	        self._currentContext = parentContext ? new Map(parentContext) : new Map();
	        self.getValue = function (key) { return self._currentContext.get(key); };
	        self.setValue = function (key, value) {
	            var context = new BaseContext(self._currentContext);
	            context._currentContext.set(key, value);
	            return context;
	        };
	        self.deleteValue = function (key) {
	            var context = new BaseContext(self._currentContext);
	            context._currentContext.delete(key);
	            return context;
	        };
	    }
	    return BaseContext;
	}());
	/** The root context is used as the default parent context when there is no active context */
	var ROOT_CONTEXT = new BaseContext();

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __spreadArray = (this && this.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	var NoopContextManager = /** @class */ (function () {
	    function NoopContextManager() {
	    }
	    NoopContextManager.prototype.active = function () {
	        return ROOT_CONTEXT;
	    };
	    NoopContextManager.prototype.with = function (_context, fn, thisArg) {
	        var args = [];
	        for (var _i = 3; _i < arguments.length; _i++) {
	            args[_i - 3] = arguments[_i];
	        }
	        return fn.call.apply(fn, __spreadArray([thisArg], args));
	    };
	    NoopContextManager.prototype.bind = function (_context, target) {
	        return target;
	    };
	    NoopContextManager.prototype.enable = function () {
	        return this;
	    };
	    NoopContextManager.prototype.disable = function () {
	        return this;
	    };
	    return NoopContextManager;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __spreadArray$1 = (this && this.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	var API_NAME$1 = 'context';
	var NOOP_CONTEXT_MANAGER = new NoopContextManager();
	/**
	 * Singleton object which represents the entry point to the OpenTelemetry Context API
	 */
	var ContextAPI = /** @class */ (function () {
	    /** Empty private constructor prevents end users from constructing a new instance of the API */
	    function ContextAPI() {
	    }
	    /** Get the singleton instance of the Context API */
	    ContextAPI.getInstance = function () {
	        if (!this._instance) {
	            this._instance = new ContextAPI();
	        }
	        return this._instance;
	    };
	    /**
	     * Set the current context manager.
	     *
	     * @returns true if the context manager was successfully registered, else false
	     */
	    ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
	        return registerGlobal(API_NAME$1, contextManager, DiagAPI.instance());
	    };
	    /**
	     * Get the currently active context
	     */
	    ContextAPI.prototype.active = function () {
	        return this._getContextManager().active();
	    };
	    /**
	     * Execute a function with an active context
	     *
	     * @param context context to be active during function execution
	     * @param fn function to execute in a context
	     * @param thisArg optional receiver to be used for calling fn
	     * @param args optional arguments forwarded to fn
	     */
	    ContextAPI.prototype.with = function (context, fn, thisArg) {
	        var _a;
	        var args = [];
	        for (var _i = 3; _i < arguments.length; _i++) {
	            args[_i - 3] = arguments[_i];
	        }
	        return (_a = this._getContextManager()).with.apply(_a, __spreadArray$1([context, fn, thisArg], args));
	    };
	    /**
	     * Bind a context to a target function or event emitter
	     *
	     * @param context context to bind to the event emitter or function. Defaults to the currently active context
	     * @param target function or event emitter to bind
	     */
	    ContextAPI.prototype.bind = function (context, target) {
	        return this._getContextManager().bind(context, target);
	    };
	    ContextAPI.prototype._getContextManager = function () {
	        return getGlobal(API_NAME$1) || NOOP_CONTEXT_MANAGER;
	    };
	    /** Disable and remove the global context manager */
	    ContextAPI.prototype.disable = function () {
	        this._getContextManager().disable();
	        unregisterGlobal(API_NAME$1, DiagAPI.instance());
	    };
	    return ContextAPI;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var TraceFlags;
	(function (TraceFlags) {
	    /** Represents no flag set. */
	    TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
	    /** Bit to represent whether trace is sampled in trace flags. */
	    TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
	})(TraceFlags || (TraceFlags = {}));

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var INVALID_SPANID = '0000000000000000';
	var INVALID_TRACEID = '00000000000000000000000000000000';
	var INVALID_SPAN_CONTEXT = {
	    traceId: INVALID_TRACEID,
	    spanId: INVALID_SPANID,
	    traceFlags: TraceFlags.NONE,
	};

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The NonRecordingSpan is the default {@link Span} that is used when no Span
	 * implementation is available. All operations are no-op including context
	 * propagation.
	 */
	var NonRecordingSpan = /** @class */ (function () {
	    function NonRecordingSpan(_spanContext) {
	        if (_spanContext === void 0) { _spanContext = INVALID_SPAN_CONTEXT; }
	        this._spanContext = _spanContext;
	    }
	    // Returns a SpanContext.
	    NonRecordingSpan.prototype.spanContext = function () {
	        return this._spanContext;
	    };
	    // By default does nothing
	    NonRecordingSpan.prototype.setAttribute = function (_key, _value) {
	        return this;
	    };
	    // By default does nothing
	    NonRecordingSpan.prototype.setAttributes = function (_attributes) {
	        return this;
	    };
	    // By default does nothing
	    NonRecordingSpan.prototype.addEvent = function (_name, _attributes) {
	        return this;
	    };
	    // By default does nothing
	    NonRecordingSpan.prototype.setStatus = function (_status) {
	        return this;
	    };
	    // By default does nothing
	    NonRecordingSpan.prototype.updateName = function (_name) {
	        return this;
	    };
	    // By default does nothing
	    NonRecordingSpan.prototype.end = function (_endTime) { };
	    // isRecording always returns false for NonRecordingSpan.
	    NonRecordingSpan.prototype.isRecording = function () {
	        return false;
	    };
	    // By default does nothing
	    NonRecordingSpan.prototype.recordException = function (_exception, _time) { };
	    return NonRecordingSpan;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * span key
	 */
	var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
	/**
	 * Return the span if one exists
	 *
	 * @param context context to get span from
	 */
	function getSpan(context) {
	    return context.getValue(SPAN_KEY) || undefined;
	}
	/**
	 * Set the span on a context
	 *
	 * @param context context to use as parent
	 * @param span span to set active
	 */
	function setSpan(context, span) {
	    return context.setValue(SPAN_KEY, span);
	}
	/**
	 * Remove current span stored in the context
	 *
	 * @param context context to delete span from
	 */
	function deleteSpan(context) {
	    return context.deleteValue(SPAN_KEY);
	}
	/**
	 * Wrap span context in a NoopSpan and set as span in a new
	 * context
	 *
	 * @param context context to set active span on
	 * @param spanContext span context to be wrapped
	 */
	function setSpanContext(context, spanContext) {
	    return setSpan(context, new NonRecordingSpan(spanContext));
	}
	/**
	 * Get the span context of the span if it exists.
	 *
	 * @param context context to get values from
	 */
	function getSpanContext(context) {
	    var _a;
	    return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
	var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
	function isValidTraceId(traceId) {
	    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
	}
	function isValidSpanId(spanId) {
	    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
	}
	/**
	 * Returns true if this {@link SpanContext} is valid.
	 * @return true if this {@link SpanContext} is valid.
	 */
	function isSpanContextValid(spanContext) {
	    return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));
	}
	/**
	 * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
	 *
	 * @param spanContext span context to be wrapped
	 * @returns a new non-recording {@link Span} with the provided context
	 */
	function wrapSpanContext(spanContext) {
	    return new NonRecordingSpan(spanContext);
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var context = ContextAPI.getInstance();
	/**
	 * No-op implementations of {@link Tracer}.
	 */
	var NoopTracer = /** @class */ (function () {
	    function NoopTracer() {
	    }
	    // startSpan starts a noop span.
	    NoopTracer.prototype.startSpan = function (name, options, context) {
	        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
	        if (root) {
	            return new NonRecordingSpan();
	        }
	        var parentFromContext = context && getSpanContext(context);
	        if (isSpanContext(parentFromContext) &&
	            isSpanContextValid(parentFromContext)) {
	            return new NonRecordingSpan(parentFromContext);
	        }
	        else {
	            return new NonRecordingSpan();
	        }
	    };
	    NoopTracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
	        var opts;
	        var ctx;
	        var fn;
	        if (arguments.length < 2) {
	            return;
	        }
	        else if (arguments.length === 2) {
	            fn = arg2;
	        }
	        else if (arguments.length === 3) {
	            opts = arg2;
	            fn = arg3;
	        }
	        else {
	            opts = arg2;
	            ctx = arg3;
	            fn = arg4;
	        }
	        var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();
	        var span = this.startSpan(name, opts, parentContext);
	        var contextWithSpanSet = setSpan(parentContext, span);
	        return context.with(contextWithSpanSet, fn, undefined, span);
	    };
	    return NoopTracer;
	}());
	function isSpanContext(spanContext) {
	    return (typeof spanContext === 'object' &&
	        typeof spanContext['spanId'] === 'string' &&
	        typeof spanContext['traceId'] === 'string' &&
	        typeof spanContext['traceFlags'] === 'number');
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var NOOP_TRACER = new NoopTracer();
	/**
	 * Proxy tracer provided by the proxy tracer provider
	 */
	var ProxyTracer = /** @class */ (function () {
	    function ProxyTracer(_provider, name, version) {
	        this._provider = _provider;
	        this.name = name;
	        this.version = version;
	    }
	    ProxyTracer.prototype.startSpan = function (name, options, context) {
	        return this._getTracer().startSpan(name, options, context);
	    };
	    ProxyTracer.prototype.startActiveSpan = function (_name, _options, _context, _fn) {
	        var tracer = this._getTracer();
	        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
	    };
	    /**
	     * Try to get a tracer from the proxy tracer provider.
	     * If the proxy tracer provider has no delegate, return a noop tracer.
	     */
	    ProxyTracer.prototype._getTracer = function () {
	        if (this._delegate) {
	            return this._delegate;
	        }
	        var tracer = this._provider.getDelegateTracer(this.name, this.version);
	        if (!tracer) {
	            return NOOP_TRACER;
	        }
	        this._delegate = tracer;
	        return this._delegate;
	    };
	    return ProxyTracer;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * An implementation of the {@link TracerProvider} which returns an impotent
	 * Tracer for all calls to `getTracer`.
	 *
	 * All operations are no-op.
	 */
	var NoopTracerProvider = /** @class */ (function () {
	    function NoopTracerProvider() {
	    }
	    NoopTracerProvider.prototype.getTracer = function (_name, _version) {
	        return new NoopTracer();
	    };
	    return NoopTracerProvider;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
	/**
	 * Tracer provider which provides {@link ProxyTracer}s.
	 *
	 * Before a delegate is set, tracers provided are NoOp.
	 *   When a delegate is set, traces are provided from the delegate.
	 *   When a delegate is set after tracers have already been provided,
	 *   all tracers already provided will use the provided delegate implementation.
	 */
	var ProxyTracerProvider = /** @class */ (function () {
	    function ProxyTracerProvider() {
	    }
	    /**
	     * Get a {@link ProxyTracer}
	     */
	    ProxyTracerProvider.prototype.getTracer = function (name, version) {
	        var _a;
	        return ((_a = this.getDelegateTracer(name, version)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version));
	    };
	    ProxyTracerProvider.prototype.getDelegate = function () {
	        var _a;
	        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
	    };
	    /**
	     * Set the delegate tracer provider
	     */
	    ProxyTracerProvider.prototype.setDelegate = function (delegate) {
	        this._delegate = delegate;
	    };
	    ProxyTracerProvider.prototype.getDelegateTracer = function (name, version) {
	        var _a;
	        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version);
	    };
	    return ProxyTracerProvider;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * A sampling decision that determines how a {@link Span} will be recorded
	 * and collected.
	 */
	var SamplingDecision;
	(function (SamplingDecision) {
	    /**
	     * `Span.isRecording() === false`, span will not be recorded and all events
	     * and attributes will be dropped.
	     */
	    SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
	    /**
	     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
	     * MUST NOT be set.
	     */
	    SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
	    /**
	     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
	     * MUST be set.
	     */
	    SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
	})(SamplingDecision || (SamplingDecision = {}));

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var SpanKind;
	(function (SpanKind) {
	    /** Default value. Indicates that the span is used internally. */
	    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
	    /**
	     * Indicates that the span covers server-side handling of an RPC or other
	     * remote request.
	     */
	    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
	    /**
	     * Indicates that the span covers the client-side wrapper around an RPC or
	     * other remote request.
	     */
	    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
	    /**
	     * Indicates that the span describes producer sending a message to a
	     * broker. Unlike client and server, there is no direct critical path latency
	     * relationship between producer and consumer spans.
	     */
	    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
	    /**
	     * Indicates that the span describes consumer receiving a message from a
	     * broker. Unlike client and server, there is no direct critical path latency
	     * relationship between producer and consumer spans.
	     */
	    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
	})(SpanKind || (SpanKind = {}));

	/**
	 * An enumeration of status codes.
	 */
	var SpanStatusCode;
	(function (SpanStatusCode) {
	    /**
	     * The default status.
	     */
	    SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
	    /**
	     * The operation has been validated by an Application developer or
	     * Operator to have completed successfully.
	     */
	    SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
	    /**
	     * The operation contains an error.
	     */
	    SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
	})(SpanStatusCode || (SpanStatusCode = {}));

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var API_NAME$2 = 'trace';
	/**
	 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
	 */
	var TraceAPI = /** @class */ (function () {
	    /** Empty private constructor prevents end users from constructing a new instance of the API */
	    function TraceAPI() {
	        this._proxyTracerProvider = new ProxyTracerProvider();
	        this.wrapSpanContext = wrapSpanContext;
	        this.isSpanContextValid = isSpanContextValid;
	        this.deleteSpan = deleteSpan;
	        this.getSpan = getSpan;
	        this.getSpanContext = getSpanContext;
	        this.setSpan = setSpan;
	        this.setSpanContext = setSpanContext;
	    }
	    /** Get the singleton instance of the Trace API */
	    TraceAPI.getInstance = function () {
	        if (!this._instance) {
	            this._instance = new TraceAPI();
	        }
	        return this._instance;
	    };
	    /**
	     * Set the current global tracer.
	     *
	     * @returns true if the tracer provider was successfully registered, else false
	     */
	    TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
	        var success = registerGlobal(API_NAME$2, this._proxyTracerProvider, DiagAPI.instance());
	        if (success) {
	            this._proxyTracerProvider.setDelegate(provider);
	        }
	        return success;
	    };
	    /**
	     * Returns the global tracer provider.
	     */
	    TraceAPI.prototype.getTracerProvider = function () {
	        return getGlobal(API_NAME$2) || this._proxyTracerProvider;
	    };
	    /**
	     * Returns a tracer from the global tracer provider.
	     */
	    TraceAPI.prototype.getTracer = function (name, version) {
	        return this.getTracerProvider().getTracer(name, version);
	    };
	    /** Remove the global tracer provider */
	    TraceAPI.prototype.disable = function () {
	        unregisterGlobal(API_NAME$2, DiagAPI.instance());
	        this._proxyTracerProvider = new ProxyTracerProvider();
	    };
	    return TraceAPI;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * No-op implementations of {@link TextMapPropagator}.
	 */
	var NoopTextMapPropagator = /** @class */ (function () {
	    function NoopTextMapPropagator() {
	    }
	    /** Noop inject function does nothing */
	    NoopTextMapPropagator.prototype.inject = function (_context, _carrier) { };
	    /** Noop extract function does nothing and returns the input context */
	    NoopTextMapPropagator.prototype.extract = function (context, _carrier) {
	        return context;
	    };
	    NoopTextMapPropagator.prototype.fields = function () {
	        return [];
	    };
	    return NoopTextMapPropagator;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * Baggage key
	 */
	var BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
	/**
	 * Retrieve the current baggage from the given context
	 *
	 * @param {Context} Context that manage all context values
	 * @returns {Baggage} Extracted baggage from the context
	 */
	function getBaggage(context) {
	    return context.getValue(BAGGAGE_KEY) || undefined;
	}
	/**
	 * Store a baggage in the given context
	 *
	 * @param {Context} Context that manage all context values
	 * @param {Baggage} baggage that will be set in the actual context
	 */
	function setBaggage(context, baggage) {
	    return context.setValue(BAGGAGE_KEY, baggage);
	}
	/**
	 * Delete the baggage stored in the given context
	 *
	 * @param {Context} Context that manage all context values
	 */
	function deleteBaggage(context) {
	    return context.deleteValue(BAGGAGE_KEY);
	}

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var API_NAME$3 = 'propagation';
	var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
	/**
	 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
	 */
	var PropagationAPI = /** @class */ (function () {
	    /** Empty private constructor prevents end users from constructing a new instance of the API */
	    function PropagationAPI() {
	        this.createBaggage = createBaggage;
	        this.getBaggage = getBaggage;
	        this.setBaggage = setBaggage;
	        this.deleteBaggage = deleteBaggage;
	    }
	    /** Get the singleton instance of the Propagator API */
	    PropagationAPI.getInstance = function () {
	        if (!this._instance) {
	            this._instance = new PropagationAPI();
	        }
	        return this._instance;
	    };
	    /**
	     * Set the current propagator.
	     *
	     * @returns true if the propagator was successfully registered, else false
	     */
	    PropagationAPI.prototype.setGlobalPropagator = function (propagator) {
	        return registerGlobal(API_NAME$3, propagator, DiagAPI.instance());
	    };
	    /**
	     * Inject context into a carrier to be propagated inter-process
	     *
	     * @param context Context carrying tracing data to inject
	     * @param carrier carrier to inject context into
	     * @param setter Function used to set values on the carrier
	     */
	    PropagationAPI.prototype.inject = function (context, carrier, setter) {
	        if (setter === void 0) { setter = defaultTextMapSetter; }
	        return this._getGlobalPropagator().inject(context, carrier, setter);
	    };
	    /**
	     * Extract context from a carrier
	     *
	     * @param context Context which the newly created context will inherit from
	     * @param carrier Carrier to extract context from
	     * @param getter Function used to extract keys from a carrier
	     */
	    PropagationAPI.prototype.extract = function (context, carrier, getter) {
	        if (getter === void 0) { getter = defaultTextMapGetter; }
	        return this._getGlobalPropagator().extract(context, carrier, getter);
	    };
	    /**
	     * Return a list of all fields which may be used by the propagator.
	     */
	    PropagationAPI.prototype.fields = function () {
	        return this._getGlobalPropagator().fields();
	    };
	    /** Remove the global propagator */
	    PropagationAPI.prototype.disable = function () {
	        unregisterGlobal(API_NAME$3, DiagAPI.instance());
	    };
	    PropagationAPI.prototype._getGlobalPropagator = function () {
	        return getGlobal(API_NAME$3) || NOOP_TEXT_MAP_PROPAGATOR;
	    };
	    return PropagationAPI;
	}());

	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/** Entrypoint for context API */
	var context$1 = ContextAPI.getInstance();
	/** Entrypoint for trace API */
	var trace = TraceAPI.getInstance();
	/** Entrypoint for propagation API */
	var propagation = PropagationAPI.getInstance();
	/**
	 * Entrypoint for Diag API.
	 * Defines Diagnostic handler used for internal diagnostic logging operations.
	 * The default provides a Noop DiagLogger implementation which may be changed via the
	 * diag.setLogger(logger: DiagLogger) function.
	 */
	var diag$1 = DiagAPI.instance();

	// Copyright (c) Microsoft Corporation.
	/**
	 * The kind of span.
	 */
	var SpanKind$1;
	(function (SpanKind) {
	    /** Default value. Indicates that the span is used internally. */
	    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
	    /**
	     * Indicates that the span covers server-side handling of an RPC or other
	     * remote request.
	     */
	    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
	    /**
	     * Indicates that the span covers the client-side wrapper around an RPC or
	     * other remote request.
	     */
	    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
	    /**
	     * Indicates that the span describes producer sending a message to a
	     * broker. Unlike client and server, there is no direct critical path latency
	     * relationship between producer and consumer spans.
	     */
	    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
	    /**
	     * Indicates that the span describes consumer receiving a message from a
	     * broker. Unlike client and server, there is no direct critical path latency
	     * relationship between producer and consumer spans.
	     */
	    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
	})(SpanKind$1 || (SpanKind$1 = {}));
	/**
	 * Set the span on a context
	 *
	 * @param context - context to use as parent
	 * @param span - span to set active
	 */
	function setSpan$1(context, span) {
	    return trace.setSpan(context, span);
	}
	/**
	 * Returns true of the given {@link SpanContext} is valid.
	 * A valid {@link SpanContext} is one which has a valid trace ID and span ID as per the spec.
	 *
	 * @param context - the {@link SpanContext} to validate.
	 *
	 * @returns true if the {@link SpanContext} is valid, false otherwise.
	 */
	function isSpanContextValid$1(context) {
	    return trace.isSpanContextValid(context);
	}
	function getTracer(name, version) {
	    return trace.getTracer(name || "azure/core-tracing", version);
	}
	/** Entrypoint for context API */
	const context$2 = context$1;
	/** SpanStatusCode */
	var SpanStatusCode$1;
	(function (SpanStatusCode) {
	    /**
	     * The default status.
	     */
	    SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
	    /**
	     * The operation has been validated by an Application developer or
	     * Operator to have completed successfully.
	     */
	    SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
	    /**
	     * The operation contains an error.
	     */
	    SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
	})(SpanStatusCode$1 || (SpanStatusCode$1 = {}));

	// Copyright (c) Microsoft Corporation.
	function isTracingDisabled() {
	    var _a;
	    if (typeof process === "undefined") {
	        // not supported in browser for now without polyfills
	        return false;
	    }
	    const azureTracingDisabledValue = (_a = process.env.AZURE_TRACING_DISABLED) === null || _a === void 0 ? void 0 : _a.toLowerCase();
	    if (azureTracingDisabledValue === "false" || azureTracingDisabledValue === "0") {
	        return false;
	    }
	    return Boolean(azureTracingDisabledValue);
	}
	/**
	 * Creates a function that can be used to create spans using the global tracer.
	 *
	 * Usage:
	 *
	 * ```typescript
	 * // once
	 * const createSpan = createSpanFunction({ packagePrefix: "Azure.Data.AppConfiguration", namespace: "Microsoft.AppConfiguration" });
	 *
	 * // in each operation
	 * const span = createSpan("deleteConfigurationSetting", operationOptions);
	 *    // code...
	 * span.end();
	 * ```
	 *
	 * @hidden
	 * @param args - allows configuration of the prefix for each span as well as the az.namespace field.
	 */
	function createSpanFunction(args) {
	    return function (operationName, operationOptions) {
	        const tracer = getTracer();
	        const tracingOptions = (operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) || {};
	        const spanOptions = Object.assign({ kind: SpanKind$1.INTERNAL }, tracingOptions.spanOptions);
	        const spanName = args.packagePrefix ? `${args.packagePrefix}.${operationName}` : operationName;
	        let span;
	        if (isTracingDisabled()) {
	            span = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
	        }
	        else {
	            span = tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);
	        }
	        if (args.namespace) {
	            span.setAttribute("az.namespace", args.namespace);
	        }
	        let newSpanOptions = tracingOptions.spanOptions || {};
	        if (span.isRecording() && args.namespace) {
	            newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": args.namespace }) });
	        }
	        const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), { spanOptions: newSpanOptions, tracingContext: setSpan$1(tracingOptions.tracingContext || context$2.active(), span) });
	        const newOperationOptions = Object.assign(Object.assign({}, operationOptions), { tracingOptions: newTracingOptions });
	        return {
	            span,
	            updatedOptions: newOperationOptions
	        };
	    };
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	const VERSION$1 = "00";
	/**
	 * Generates a `traceparent` value given a span context.
	 * @param spanContext - Contains context for a specific span.
	 * @returns The `spanContext` represented as a `traceparent` value.
	 */
	function getTraceParentHeader(spanContext) {
	    const missingFields = [];
	    if (!spanContext.traceId) {
	        missingFields.push("traceId");
	    }
	    if (!spanContext.spanId) {
	        missingFields.push("spanId");
	    }
	    if (missingFields.length) {
	        return;
	    }
	    const flags = spanContext.traceFlags || 0 /* NONE */;
	    const hexFlags = flags.toString(16);
	    const traceFlags = hexFlags.length === 1 ? `0${hexFlags}` : hexFlags;
	    // https://www.w3.org/TR/trace-context/#traceparent-header-field-values
	    return `${VERSION$1}-${spanContext.traceId}-${spanContext.spanId}-${traceFlags}`;
	}

	// Copyright (c) Microsoft Corporation.
	const createSpan = createSpanFunction({
	    packagePrefix: "",
	    namespace: ""
	});
	function tracingPolicy(tracingOptions = {}) {
	    return {
	        create(nextPolicy, options) {
	            return new TracingPolicy(nextPolicy, options, tracingOptions);
	        }
	    };
	}
	class TracingPolicy extends BaseRequestPolicy {
	    constructor(nextPolicy, options, tracingOptions) {
	        super(nextPolicy, options);
	        this.userAgent = tracingOptions.userAgent;
	    }
	    async sendRequest(request) {
	        if (!request.tracingContext) {
	            return this._nextPolicy.sendRequest(request);
	        }
	        const span = this.tryCreateSpan(request);
	        if (!span) {
	            return this._nextPolicy.sendRequest(request);
	        }
	        try {
	            const response = await this._nextPolicy.sendRequest(request);
	            this.tryProcessResponse(span, response);
	            return response;
	        }
	        catch (err) {
	            this.tryProcessError(span, err);
	            throw err;
	        }
	    }
	    tryCreateSpan(request) {
	        var _a;
	        try {
	            const path = URLBuilder.parse(request.url).getPath() || "/";
	            // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.
	            // We can pass this as a separate parameter once we upgrade to the latest core-tracing.
	            const { span } = createSpan(path, {
	                tracingOptions: {
	                    spanOptions: Object.assign(Object.assign({}, request.spanOptions), { kind: SpanKind$1.CLIENT }),
	                    tracingContext: request.tracingContext
	                }
	            });
	            // If the span is not recording, don't do any more work.
	            if (!span.isRecording()) {
	                span.end();
	                return undefined;
	            }
	            const namespaceFromContext = (_a = request.tracingContext) === null || _a === void 0 ? void 0 : _a.getValue(Symbol.for("az.namespace"));
	            if (typeof namespaceFromContext === "string") {
	                span.setAttribute("az.namespace", namespaceFromContext);
	            }
	            span.setAttributes({
	                "http.method": request.method,
	                "http.url": request.url,
	                requestId: request.requestId
	            });
	            if (this.userAgent) {
	                span.setAttribute("http.user_agent", this.userAgent);
	            }
	            // set headers
	            const spanContext = span.spanContext();
	            const traceParentHeader = getTraceParentHeader(spanContext);
	            if (traceParentHeader && isSpanContextValid$1(spanContext)) {
	                request.headers.set("traceparent", traceParentHeader);
	                const traceState = spanContext.traceState && spanContext.traceState.serialize();
	                // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent
	                if (traceState) {
	                    request.headers.set("tracestate", traceState);
	                }
	            }
	            return span;
	        }
	        catch (error) {
	            logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);
	            return undefined;
	        }
	    }
	    tryProcessError(span, err) {
	        try {
	            span.setStatus({
	                code: SpanStatusCode$1.ERROR,
	                message: err.message
	            });
	            if (err.statusCode) {
	                span.setAttribute("http.status_code", err.statusCode);
	            }
	            span.end();
	        }
	        catch (error) {
	            logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);
	        }
	    }
	    tryProcessResponse(span, response) {
	        try {
	            span.setAttribute("http.status_code", response.status);
	            const serviceRequestId = response.headers.get("x-ms-request-id");
	            if (serviceRequestId) {
	                span.setAttribute("serviceRequestId", serviceRequestId);
	            }
	            span.setStatus({
	                code: SpanStatusCode$1.OK
	            });
	            span.end();
	        }
	        catch (error) {
	            logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);
	        }
	    }
	}

	// Copyright (c) Microsoft Corporation.
	const DisbleResponseDecompressionNotSupportedInBrowser = new Error("DisableResponseDecompressionPolicy is not supported in browser environment");
	/**
	 * {@link DisableResponseDecompressionPolicy} is not supported in browser and attempting
	 * to use it will results in error being thrown.
	 */
	function disableResponseDecompressionPolicy() {
	    return {
	        create: (_nextPolicy, _options) => {
	            throw DisbleResponseDecompressionNotSupportedInBrowser;
	        }
	    };
	}

	// Copyright (c) Microsoft Corporation.
	function ndJsonPolicy() {
	    return {
	        create: (nextPolicy, options) => {
	            return new NdJsonPolicy(nextPolicy, options);
	        }
	    };
	}
	/**
	 * NdJsonPolicy that formats a JSON array as newline-delimited JSON
	 */
	class NdJsonPolicy extends BaseRequestPolicy {
	    /**
	     * Creates an instance of KeepAlivePolicy.
	     */
	    constructor(nextPolicy, options) {
	        super(nextPolicy, options);
	    }
	    /**
	     * Sends a request.
	     */
	    async sendRequest(request) {
	        // There currently isn't a good way to bypass the serializer
	        if (typeof request.body === "string" && request.body.startsWith("[")) {
	            const body = JSON.parse(request.body);
	            if (Array.isArray(body)) {
	                request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
	            }
	        }
	        return this._nextPolicy.sendRequest(request);
	    }
	}

	// Copyright (c) Microsoft Corporation.
	let cachedHttpClient;
	function getCachedDefaultHttpClient() {
	    if (!cachedHttpClient) {
	        cachedHttpClient = new XhrHttpClient();
	    }
	    return cachedHttpClient;
	}

	// Copyright (c) Microsoft Corporation.
	/**
	 * ServiceClient sends service requests and receives responses.
	 */
	class ServiceClient {
	    /**
	     * The ServiceClient constructor
	     * @param credentials - The credentials used for authentication with the service.
	     * @param options - The service client options that govern the behavior of the client.
	     */
	    constructor(credentials, 
	    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */
	    options) {
	        if (!options) {
	            options = {};
	        }
	        this._withCredentials = options.withCredentials || false;
	        this._httpClient = options.httpClient || getCachedDefaultHttpClient();
	        this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);
	        let requestPolicyFactories;
	        if (Array.isArray(options.requestPolicyFactories)) {
	            logger.info("ServiceClient: using custom request policies");
	            requestPolicyFactories = options.requestPolicyFactories;
	        }
	        else {
	            let authPolicyFactory = undefined;
	            if (isTokenCredential(credentials)) {
	                logger.info("ServiceClient: creating bearer token authentication policy from provided credentials");
	                // Create a wrapped RequestPolicyFactory here so that we can provide the
	                // correct scope to the BearerTokenAuthenticationPolicy at the first time
	                // one is requested.  This is needed because generated ServiceClient
	                // implementations do not set baseUri until after ServiceClient's constructor
	                // is finished, leaving baseUri empty at the time when it is needed to
	                // build the correct scope name.
	                const wrappedPolicyFactory = () => {
	                    let bearerTokenPolicyFactory = undefined;
	                    // eslint-disable-next-line @typescript-eslint/no-this-alias
	                    const serviceClient = this;
	                    const serviceClientOptions = options;
	                    return {
	                        create(nextPolicy, createOptions) {
	                            const credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);
	                            if (!credentialScopes) {
	                                throw new Error(`When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`);
	                            }
	                            if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {
	                                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);
	                            }
	                            return bearerTokenPolicyFactory.create(nextPolicy, createOptions);
	                        }
	                    };
	                };
	                authPolicyFactory = wrappedPolicyFactory();
	            }
	            else if (credentials && typeof credentials.signRequest === "function") {
	                logger.info("ServiceClient: creating signing policy from provided credentials");
	                authPolicyFactory = signingPolicy(credentials);
	            }
	            else if (credentials !== undefined && credentials !== null) {
	                throw new Error("The credentials argument must implement the TokenCredential interface");
	            }
	            logger.info("ServiceClient: using default request policies");
	            requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);
	            if (options.requestPolicyFactories) {
	                // options.requestPolicyFactories can also be a function that manipulates
	                // the default requestPolicyFactories array
	                const newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);
	                if (newRequestPolicyFactories) {
	                    requestPolicyFactories = newRequestPolicyFactories;
	                }
	            }
	        }
	        this._requestPolicyFactories = requestPolicyFactories;
	    }
	    /**
	     * Send the provided httpRequest.
	     */
	    sendRequest(options) {
	        if (options === null || options === undefined || typeof options !== "object") {
	            throw new Error("options cannot be null or undefined and it must be of type object.");
	        }
	        let httpRequest;
	        try {
	            if (isWebResourceLike(options)) {
	                options.validateRequestProperties();
	                httpRequest = options;
	            }
	            else {
	                httpRequest = new WebResource();
	                httpRequest = httpRequest.prepare(options);
	            }
	        }
	        catch (error) {
	            return Promise.reject(error);
	        }
	        let httpPipeline = this._httpClient;
	        if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {
	            for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {
	                httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);
	            }
	        }
	        return httpPipeline.sendRequest(httpRequest);
	    }
	    /**
	     * Send an HTTP request that is populated using the provided OperationSpec.
	     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
	     * @param operationSpec - The OperationSpec to use to populate the httpRequest.
	     * @param callback - The callback to call when the response is received.
	     */
	    async sendOperationRequest(operationArguments, operationSpec, callback) {
	        var _a;
	        if (typeof operationArguments.options === "function") {
	            callback = operationArguments.options;
	            operationArguments.options = undefined;
	        }
	        const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
	        const httpRequest = new WebResource();
	        let result;
	        try {
	            const baseUri = operationSpec.baseUrl || this.baseUri;
	            if (!baseUri) {
	                throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
	            }
	            httpRequest.method = operationSpec.httpMethod;
	            httpRequest.operationSpec = operationSpec;
	            const requestUrl = URLBuilder.parse(baseUri);
	            if (operationSpec.path) {
	                requestUrl.appendPath(operationSpec.path);
	            }
	            if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {
	                for (const urlParameter of operationSpec.urlParameters) {
	                    let urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);
	                    urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);
	                    if (!urlParameter.skipEncoding) {
	                        urlParameterValue = encodeURIComponent(urlParameterValue);
	                    }
	                    requestUrl.replaceAll(`{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`, urlParameterValue);
	                }
	            }
	            if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {
	                for (const queryParameter of operationSpec.queryParameters) {
	                    let queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);
	                    if (queryParameterValue !== undefined && queryParameterValue !== null) {
	                        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);
	                        if (queryParameter.collectionFormat !== undefined &&
	                            queryParameter.collectionFormat !== null) {
	                            if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {
	                                if (queryParameterValue.length === 0) {
	                                    // The collection is empty, no need to try serializing the current queryParam
	                                    continue;
	                                }
	                                else {
	                                    for (const index in queryParameterValue) {
	                                        const item = queryParameterValue[index];
	                                        queryParameterValue[index] =
	                                            item === undefined || item === null ? "" : item.toString();
	                                    }
	                                }
	                            }
	                            else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv ||
	                                queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {
	                                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
	                            }
	                        }
	                        if (!queryParameter.skipEncoding) {
	                            if (Array.isArray(queryParameterValue)) {
	                                for (const index in queryParameterValue) {
	                                    if (queryParameterValue[index] !== undefined &&
	                                        queryParameterValue[index] !== null) {
	                                        queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);
	                                    }
	                                }
	                            }
	                            else {
	                                queryParameterValue = encodeURIComponent(queryParameterValue);
	                            }
	                        }
	                        if (queryParameter.collectionFormat !== undefined &&
	                            queryParameter.collectionFormat !== null &&
	                            queryParameter.collectionFormat !== QueryCollectionFormat.Multi &&
	                            queryParameter.collectionFormat !== QueryCollectionFormat.Ssv &&
	                            queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {
	                            queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
	                        }
	                        requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
	                    }
	                }
	            }
	            httpRequest.url = requestUrl.toString();
	            const contentType = operationSpec.contentType || this.requestContentType;
	            if (contentType && operationSpec.requestBody) {
	                httpRequest.headers.set("Content-Type", contentType);
	            }
	            if (operationSpec.headerParameters) {
	                for (const headerParameter of operationSpec.headerParameters) {
	                    let headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);
	                    if (headerValue !== undefined && headerValue !== null) {
	                        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);
	                        const headerCollectionPrefix = headerParameter.mapper
	                            .headerCollectionPrefix;
	                        if (headerCollectionPrefix) {
	                            for (const key of Object.keys(headerValue)) {
	                                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);
	                            }
	                        }
	                        else {
	                            httpRequest.headers.set(headerParameter.mapper.serializedName ||
	                                getPathStringFromParameter(headerParameter), headerValue);
	                        }
	                    }
	                }
	            }
	            const options = operationArguments.options;
	            if (options) {
	                if (options.customHeaders) {
	                    for (const customHeaderName in options.customHeaders) {
	                        httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);
	                    }
	                }
	                if (options.abortSignal) {
	                    httpRequest.abortSignal = options.abortSignal;
	                }
	                if (options.timeout) {
	                    httpRequest.timeout = options.timeout;
	                }
	                if (options.onUploadProgress) {
	                    httpRequest.onUploadProgress = options.onUploadProgress;
	                }
	                if (options.onDownloadProgress) {
	                    httpRequest.onDownloadProgress = options.onDownloadProgress;
	                }
	                if (options.spanOptions) {
	                    // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.
	                    httpRequest.spanOptions = options.spanOptions;
	                }
	                if (options.tracingContext) {
	                    httpRequest.tracingContext = options.tracingContext;
	                }
	                if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {
	                    httpRequest.shouldDeserialize = options.shouldDeserialize;
	                }
	            }
	            httpRequest.withCredentials = this._withCredentials;
	            serializeRequestBody(this, httpRequest, operationArguments, operationSpec);
	            if (httpRequest.streamResponseStatusCodes === undefined) {
	                httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);
	            }
	            let rawResponse;
	            let sendRequestError;
	            try {
	                rawResponse = await this.sendRequest(httpRequest);
	            }
	            catch (error) {
	                sendRequestError = error;
	            }
	            if (sendRequestError) {
	                if (sendRequestError.response) {
	                    sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] ||
	                        operationSpec.responses["default"]);
	                }
	                result = Promise.reject(sendRequestError);
	            }
	            else {
	                result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));
	            }
	        }
	        catch (error) {
	            result = Promise.reject(error);
	        }
	        const cb = callback;
	        if (cb) {
	            result
	                .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))
	                .catch((err) => cb(err));
	        }
	        return result;
	    }
	}
	function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {
	    var _a, _b, _c, _d, _e, _f;
	    const serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};
	    const updatedOptions = {
	        rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : "",
	        includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,
	        xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY
	    };
	    const xmlCharKey = serializerOptions.xmlCharKey;
	    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
	        httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);
	        const bodyMapper = operationSpec.requestBody.mapper;
	        const { required, xmlName, xmlElementName, serializedName, xmlNamespace, xmlNamespacePrefix } = bodyMapper;
	        const typeName = bodyMapper.type.name;
	        try {
	            if ((httpRequest.body !== undefined && httpRequest.body !== null) || required) {
	                const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
	                httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);
	                const isStream = typeName === MapperType.Stream;
	                if (operationSpec.isXML) {
	                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
	                    const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);
	                    if (typeName === MapperType.Sequence) {
	                        httpRequest.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
	                            rootName: xmlName || serializedName,
	                            xmlCharKey
	                        });
	                    }
	                    else if (!isStream) {
	                        httpRequest.body = stringifyXML(value, {
	                            rootName: xmlName || serializedName,
	                            xmlCharKey
	                        });
	                    }
	                }
	                else if (typeName === MapperType.String &&
	                    (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match("text/plain")) || operationSpec.mediaType === "text")) {
	                    // the String serializer has validated that request body is a string
	                    // so just send the string.
	                    return;
	                }
	                else if (!isStream) {
	                    httpRequest.body = JSON.stringify(httpRequest.body);
	                }
	            }
	        }
	        catch (error) {
	            throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`);
	        }
	    }
	    else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
	        httpRequest.formData = {};
	        for (const formDataParameter of operationSpec.formDataParameters) {
	            const formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);
	            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
	                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
	                httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
	            }
	        }
	    }
	}
	/**
	 * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself
	 */
	function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
	    // Composite and Sequence schemas already got their root namespace set during serialization
	    // We just need to add xmlns to the other schema types
	    if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
	        const result = {};
	        result[options.xmlCharKey] = serializedValue;
	        result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
	        return result;
	    }
	    return serializedValue;
	}
	function getValueOrFunctionResult(value, defaultValueCreator) {
	    let result;
	    if (typeof value === "string") {
	        result = value;
	    }
	    else {
	        result = defaultValueCreator();
	        if (typeof value === "function") {
	            result = value(result);
	        }
	    }
	    return result;
	}
	function createDefaultRequestPolicyFactories(authPolicyFactory, options) {
	    const factories = [];
	    if (options.generateClientRequestIdHeader) {
	        factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));
	    }
	    if (authPolicyFactory) {
	        factories.push(authPolicyFactory);
	    }
	    const userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);
	    const userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);
	    if (userAgentHeaderName && userAgentHeaderValue) {
	        factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));
	    }
	    factories.push(redirectPolicy());
	    factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));
	    if (!options.noRetryPolicy) {
	        factories.push(exponentialRetryPolicy());
	        factories.push(systemErrorRetryPolicy());
	        factories.push(throttlingRetryPolicy());
	    }
	    factories.push(deserializationPolicy(options.deserializationContentTypes));
	    factories.push(logPolicy({ logger: logger.info }));
	    return factories;
	}
	function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {
	    const requestPolicyFactories = [];
	    if (pipelineOptions.sendStreamingJson) {
	        requestPolicyFactories.push(ndJsonPolicy());
	    }
	    let userAgentValue = undefined;
	    if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {
	        const userAgentInfo = [];
	        userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);
	        // Add the default user agent value if it isn't already specified
	        // by the userAgentPrefix option.
	        const defaultUserAgentInfo = getDefaultUserAgentValue();
	        if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {
	            userAgentInfo.push(defaultUserAgentInfo);
	        }
	        userAgentValue = userAgentInfo.join(" ");
	    }
	    const keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);
	    const retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);
	    const redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);
	    const deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);
	    const loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);
	    requestPolicyFactories.push(tracingPolicy({ userAgent: userAgentValue }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({ value: userAgentValue }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));
	    if (redirectOptions.handleRedirects) {
	        requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));
	    }
	    if (authPolicyFactory) {
	        requestPolicyFactories.push(authPolicyFactory);
	    }
	    requestPolicyFactories.push(logPolicy(loggingOptions));
	    if (isNode && pipelineOptions.decompressResponse === false) {
	        requestPolicyFactories.push(disableResponseDecompressionPolicy());
	    }
	    return {
	        httpClient: pipelineOptions.httpClient,
	        requestPolicyFactories
	    };
	}
	function getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {
	    return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);
	}
	function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {
	    var _a;
	    let value;
	    if (typeof parameterPath === "string") {
	        parameterPath = [parameterPath];
	    }
	    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
	    if (Array.isArray(parameterPath)) {
	        if (parameterPath.length > 0) {
	            if (parameterMapper.isConstant) {
	                value = parameterMapper.defaultValue;
	            }
	            else {
	                let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
	                if (!propertySearchResult.propertyFound) {
	                    propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);
	                }
	                let useDefaultValue = false;
	                if (!propertySearchResult.propertyFound) {
	                    useDefaultValue =
	                        parameterMapper.required ||
	                            (parameterPath[0] === "options" && parameterPath.length === 2);
	                }
	                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
	            }
	            // Serialize just for validation purposes.
	            const parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);
	            serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);
	        }
	    }
	    else {
	        if (parameterMapper.required) {
	            value = {};
	        }
	        for (const propertyName in parameterPath) {
	            const propertyMapper = parameterMapper.type.modelProperties[propertyName];
	            const propertyPath = parameterPath[propertyName];
	            const propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);
	            // Serialize just for validation purposes.
	            const propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);
	            serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);
	            if (propertyValue !== undefined && propertyValue !== null) {
	                if (!value) {
	                    value = {};
	                }
	                value[propertyName] = propertyValue;
	            }
	        }
	    }
	    return value;
	}
	function getPropertyFromParameterPath(parent, parameterPath) {
	    const result = { propertyFound: false };
	    let i = 0;
	    for (; i < parameterPath.length; ++i) {
	        const parameterPathPart = parameterPath[i];
	        // Make sure to check inherited properties too, so don't use hasOwnProperty().
	        if (parent !== undefined && parent !== null && parameterPathPart in parent) {
	            parent = parent[parameterPathPart];
	        }
	        else {
	            break;
	        }
	    }
	    if (i === parameterPath.length) {
	        result.propertyValue = parent;
	        result.propertyFound = true;
	    }
	    return result;
	}
	function flattenResponse(_response, responseSpec) {
	    const parsedHeaders = _response.parsedHeaders;
	    const bodyMapper = responseSpec && responseSpec.bodyMapper;
	    const addOperationResponse = (obj) => {
	        return Object.defineProperty(obj, "_response", {
	            value: _response
	        });
	    };
	    if (bodyMapper) {
	        const typeName = bodyMapper.type.name;
	        if (typeName === "Stream") {
	            return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), { blobBody: _response.blobBody, readableStreamBody: _response.readableStreamBody }));
	        }
	        const modelProperties = (typeName === "Composite" && bodyMapper.type.modelProperties) || {};
	        const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
	        if (typeName === "Sequence" || isPageableResponse) {
	            const arrayResponse = [...(_response.parsedBody || [])];
	            for (const key of Object.keys(modelProperties)) {
	                if (modelProperties[key].serializedName) {
	                    arrayResponse[key] = _response.parsedBody[key];
	                }
	            }
	            if (parsedHeaders) {
	                for (const key of Object.keys(parsedHeaders)) {
	                    arrayResponse[key] = parsedHeaders[key];
	                }
	            }
	            addOperationResponse(arrayResponse);
	            return arrayResponse;
	        }
	        if (typeName === "Composite" || typeName === "Dictionary") {
	            return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));
	        }
	    }
	    if (bodyMapper ||
	        _response.request.method === "HEAD" ||
	        isPrimitiveType(_response.parsedBody)) {
	        // primitive body types and HEAD booleans
	        return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), { body: _response.parsedBody }));
	    }
	    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));
	}
	function getCredentialScopes(options, baseUri) {
	    if (options === null || options === void 0 ? void 0 : options.credentialScopes) {
	        const scopes = options.credentialScopes;
	        return Array.isArray(scopes)
	            ? scopes.map((scope) => new url(scope).toString())
	            : new url(scopes).toString();
	    }
	    if (baseUri) {
	        return `${baseUri}/.default`;
	    }
	    return undefined;
	}

	// Copyright (c) Microsoft Corporation.
	/**
	 * This function is only here for compatibility. Use createSpanFunction in core-tracing.
	 *
	 * @deprecated This function is only here for compatibility. Use createSpanFunction in core-tracing.
	 * @hidden

	 * @param spanConfig - The name of the operation being performed.
	 * @param tracingOptions - The options for the underlying http request.
	 */
	function createSpanFunction$1(args) {
	    return createSpanFunction(args);
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * Defines the default token refresh buffer duration.
	 */
	const TokenRefreshBufferMs = 2 * 60 * 1000; // 2 Minutes
	/**
	 * Provides an {@link AccessTokenCache} implementation which clears
	 * the cached {@link AccessToken}'s after the expiresOnTimestamp has
	 * passed.
	 *
	 * @deprecated No longer used in the bearer authorization policy.
	 */
	class ExpiringAccessTokenCache {
	    /**
	     * Constructs an instance of {@link ExpiringAccessTokenCache} with
	     * an optional expiration buffer time.
	     */
	    constructor(tokenRefreshBufferMs = TokenRefreshBufferMs) {
	        this.cachedToken = undefined;
	        this.tokenRefreshBufferMs = tokenRefreshBufferMs;
	    }
	    setCachedToken(accessToken) {
	        this.cachedToken = accessToken;
	    }
	    getCachedToken() {
	        if (this.cachedToken &&
	            Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp) {
	            this.cachedToken = undefined;
	        }
	        return this.cachedToken;
	    }
	}

	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	/**
	 * Helps the core-http token authentication policies with requesting a new token if we're not currently waiting for a new token.
	 *
	 * @deprecated No longer used in the bearer authorization policy.
	 */
	class AccessTokenRefresher {
	    constructor(credential, scopes, requiredMillisecondsBeforeNewRefresh = 30000) {
	        this.credential = credential;
	        this.scopes = scopes;
	        this.requiredMillisecondsBeforeNewRefresh = requiredMillisecondsBeforeNewRefresh;
	        this.lastCalled = 0;
	    }
	    /**
	     * Returns true if the required milliseconds(defaulted to 30000) have been passed signifying
	     * that we are ready for a new refresh.
	     */
	    isReady() {
	        // We're only ready for a new refresh if the required milliseconds have passed.
	        return (!this.lastCalled || Date.now() - this.lastCalled > this.requiredMillisecondsBeforeNewRefresh);
	    }
	    /**
	     * Stores the time in which it is called,
	     * then requests a new token,
	     * then sets this.promise to undefined,
	     * then returns the token.
	     */
	    async getToken(options) {
	        this.lastCalled = Date.now();
	        const token = await this.credential.getToken(this.scopes, options);
	        this.promise = undefined;
	        return token || undefined;
	    }
	    /**
	     * Requests a new token if we're not currently waiting for a new token.
	     * Returns null if the required time between each call hasn't been reached.
	     */
	    refresh(options) {
	        if (!this.promise) {
	            this.promise = this.getToken(options);
	        }
	        return this.promise;
	    }
	}

	// Copyright (c) Microsoft Corporation.
	const HeaderConstants = Constants.HeaderConstants;
	const DEFAULT_AUTHORIZATION_SCHEME = "Basic";
	class BasicAuthenticationCredentials {
	    /**
	     * Creates a new BasicAuthenticationCredentials object.
	     *
	     * @param userName - User name.
	     * @param password - Password.
	     * @param authorizationScheme - The authorization scheme.
	     */
	    constructor(userName, password, authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME) {
	        this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
	        if (userName === null || userName === undefined || typeof userName.valueOf() !== "string") {
	            throw new Error("userName cannot be null or undefined and must be of type string.");
	        }
	        if (password === null || password === undefined || typeof password.valueOf() !== "string") {
	            throw new Error("password cannot be null or undefined and must be of type string.");
	        }
	        this.userName = userName;
	        this.password = password;
	        this.authorizationScheme = authorizationScheme;
	    }
	    /**
	     * Signs a request with the Authentication header.
	     *
	     * @param webResource - The WebResourceLike to be signed.
	     * @returns The signed request object.
	     */
	    signRequest(webResource) {
	        const credentials = `${this.userName}:${this.password}`;
	        const encodedCredentials = `${this.authorizationScheme} ${encodeString(credentials)}`;
	        if (!webResource.headers)
	            webResource.headers = new HttpHeaders();
	        webResource.headers.set(HeaderConstants.AUTHORIZATION, encodedCredentials);
	        return Promise.resolve(webResource);
	    }
	}

	// Copyright (c) Microsoft Corporation.
	/**
	 * Authenticates to a service using an API key.
	 */
	class ApiKeyCredentials {
	    /**
	     * @param options - Specifies the options to be provided for auth. Either header or query needs to be provided.
	     */
	    constructor(options) {
	        if (!options || (options && !options.inHeader && !options.inQuery)) {
	            throw new Error(`options cannot be null or undefined. Either "inHeader" or "inQuery" property of the options object needs to be provided.`);
	        }
	        this.inHeader = options.inHeader;
	        this.inQuery = options.inQuery;
	    }
	    /**
	     * Signs a request with the values provided in the inHeader and inQuery parameter.
	     *
	     * @param webResource - The WebResourceLike to be signed.
	     * @returns The signed request object.
	     */
	    signRequest(webResource) {
	        if (!webResource) {
	            return Promise.reject(new Error(`webResource cannot be null or undefined and must be of type "object".`));
	        }
	        if (this.inHeader) {
	            if (!webResource.headers) {
	                webResource.headers = new HttpHeaders();
	            }
	            for (const headerName in this.inHeader) {
	                webResource.headers.set(headerName, this.inHeader[headerName]);
	            }
	        }
	        if (this.inQuery) {
	            if (!webResource.url) {
	                return Promise.reject(new Error(`url cannot be null in the request object.`));
	            }
	            if (webResource.url.indexOf("?") < 0) {
	                webResource.url += "?";
	            }
	            for (const key in this.inQuery) {
	                if (!webResource.url.endsWith("?")) {
	                    webResource.url += "&";
	                }
	                webResource.url += `${key}=${this.inQuery[key]}`;
	            }
	        }
	        return Promise.resolve(webResource);
	    }
	}

	// Copyright (c) Microsoft Corporation.
	class TopicCredentials extends ApiKeyCredentials {
	    /**
	     * Creates a new EventGrid TopicCredentials object.
	     *
	     * @param topicKey - The EventGrid topic key
	     */
	    constructor(topicKey) {
	        if (!topicKey || (topicKey && typeof topicKey !== "string")) {
	            throw new Error("topicKey cannot be null or undefined and must be of type string.");
	        }
	        const options = {
	            inHeader: {
	                "aeg-sas-key": topicKey
	            }
	        };
	        super(options);
	    }
	}

	// Copyright (c) Microsoft Corporation.

	var coreHttp = /*#__PURE__*/Object.freeze({
		__proto__: null,
		WebResource: WebResource,
		DefaultHttpClient: XhrHttpClient,
		HttpHeaders: HttpHeaders,
		get HttpPipelineLogLevel () { return HttpPipelineLogLevel; },
		RestError: RestError,
		operationOptionsToRequestOptionsBase: operationOptionsToRequestOptionsBase,
		ServiceClient: ServiceClient,
		flattenResponse: flattenResponse,
		createPipelineFromOptions: createPipelineFromOptions,
		get QueryCollectionFormat () { return QueryCollectionFormat; },
		Constants: Constants,
		bearerTokenAuthenticationPolicy: bearerTokenAuthenticationPolicy,
		logPolicy: logPolicy,
		BaseRequestPolicy: BaseRequestPolicy,
		RequestPolicyOptions: RequestPolicyOptions,
		generateClientRequestIdPolicy: generateClientRequestIdPolicy,
		exponentialRetryPolicy: exponentialRetryPolicy,
		get RetryMode () { return RetryMode; },
		systemErrorRetryPolicy: systemErrorRetryPolicy,
		throttlingRetryPolicy: throttlingRetryPolicy,
		getDefaultProxySettings: getDefaultProxySettings,
		proxyPolicy: proxyPolicy,
		redirectPolicy: redirectPolicy,
		keepAlivePolicy: keepAlivePolicy,
		disableResponseDecompressionPolicy: disableResponseDecompressionPolicy,
		signingPolicy: signingPolicy,
		userAgentPolicy: userAgentPolicy,
		getDefaultUserAgentValue: getDefaultUserAgentValue,
		deserializationPolicy: deserializationPolicy,
		deserializeResponseBody: deserializeResponseBody,
		tracingPolicy: tracingPolicy,
		MapperType: MapperType,
		Serializer: Serializer,
		serializeObject: serializeObject,
		stripRequest: stripRequest,
		stripResponse: stripResponse,
		executePromisesSequentially: executePromisesSequentially,
		generateUuid: generateUuid,
		encodeUri: encodeUri,
		promiseToCallback: promiseToCallback,
		promiseToServiceCallback: promiseToServiceCallback,
		isValidUuid: isValidUuid,
		applyMixins: applyMixins,
		isNode: isNode,
		isDuration: isDuration,
		URLBuilder: URLBuilder,
		URLQuery: URLQuery,
		delay: delay,
		createSpanFunction: createSpanFunction$1,
		isTokenCredential: isTokenCredential,
		ExpiringAccessTokenCache: ExpiringAccessTokenCache,
		AccessTokenRefresher: AccessTokenRefresher,
		BasicAuthenticationCredentials: BasicAuthenticationCredentials,
		ApiKeyCredentials: ApiKeyCredentials,
		TopicCredentials: TopicCredentials,
		parseXML: parseXML,
		stringifyXML: stringifyXML,
		XML_ATTRKEY: XML_ATTRKEY,
		XML_CHARKEY: XML_CHARKEY
	});

	var constants = createCommonjsModule(function (module, exports) {
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	exports.__esModule = true;
	exports.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES = 3;
	// GCC High gov cloud URLs
	exports.GCCHIGH_TROUTER_SERVICE_URL = "https://go.trouter.gov.teams.microsoft.us/v4/a";
	exports.GCCHIGH_REGISTRAR_SERVICE_URL = "https://registrar.gov.teams.microsoft.us/V3/registrations";
	// DoD gov cloud URLs
	exports.DOD_TROUTER_SERVICE_URL = "https://go.trouter.dod.teams.microsoft.us/v4/a";
	exports.DOD_REGISTRAR_SERVICE_URL = "https://registrar.dod.teams.microsoft.us/V3/registrations";
	// Int URLs
	exports.INT_TROUTER_SERVICE_URL = "https://go.trouter-int.skype.net/v4/a";
	exports.INT_REGISTRAR_SERVICE_URL = "https://edge.skype.net/registrar/testenv/v3/registrations";
	// Public URLs
	exports.PUBLIC_TROUTER_SERVICE_URL = "https://go.trouter.skype.com/v4/a";
	exports.PUBLIC_REGISTRAR_SERVICE_URL = "https://edge.skype.com/registrar/prod/v3/registrations";
	// Gov cloud types
	var CloudType;
	(function (CloudType) {
	    CloudType["Public"] = "Public";
	    CloudType["GccHigh"] = "GCC High";
	    CloudType["Dod"] = "DoD";
	})(CloudType = exports.CloudType || (exports.CloudType = {}));
	var CloudPrefix;
	(function (CloudPrefix) {
	    CloudPrefix["OrgId"] = "orgid";
	    CloudPrefix["Acs"] = "acs";
	    CloudPrefix["Spool"] = "spool";
	    CloudPrefix["GccHigh"] = "gcch";
	    CloudPrefix["GccHighAcs"] = "gcch-acs";
	    CloudPrefix["Dod"] = "dod";
	    CloudPrefix["DodAcs"] = "dod-acs";
	})(CloudPrefix = exports.CloudPrefix || (exports.CloudPrefix = {}));
	});

	unwrapExports(constants);
	var constants_1 = constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES;
	var constants_2 = constants.GCCHIGH_TROUTER_SERVICE_URL;
	var constants_3 = constants.GCCHIGH_REGISTRAR_SERVICE_URL;
	var constants_4 = constants.DOD_TROUTER_SERVICE_URL;
	var constants_5 = constants.DOD_REGISTRAR_SERVICE_URL;
	var constants_6 = constants.INT_TROUTER_SERVICE_URL;
	var constants_7 = constants.INT_REGISTRAR_SERVICE_URL;
	var constants_8 = constants.PUBLIC_TROUTER_SERVICE_URL;
	var constants_9 = constants.PUBLIC_REGISTRAR_SERVICE_URL;
	var constants_10 = constants.CloudType;
	var constants_11 = constants.CloudPrefix;

	var TrouterUtils = createCommonjsModule(function (module, exports) {
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	exports.__esModule = true;


	var eventIds = new Map([
	    ["chatMessageReceived", 200],
	    ["typingIndicatorReceived", 245],
	    ["readReceiptReceived", 246],
	    ["chatMessageEdited", 247],
	    ["chatMessageDeleted", 248],
	    ["chatThreadCreated", 257],
	    ["chatThreadPropertiesUpdated", 258],
	    ["chatThreadDeleted", 259],
	    ["participantsAdded", 260],
	    ["participantsRemoved", 261]
	]);
	var publicTeamsUserPrefix = "8:orgid:";
	var dodTeamsUserPrefix = "8:dod:";
	var gcchTeamsUserPrefix = "8:gcch:";
	var teamsVisitorUserPrefix = "8:teamsvisitor:";
	var phoneNumberPrefix = "4:";
	var acsUserPrefix = "8:acs:";
	var acsGcchUserPrefix = "8:gcch-acs:";
	var acsDodUserPrefix = "8:dod-acs:";
	var spoolUserPrefix = "8:spool:";
	exports.toMessageHandler = function (event, listener) {
	    var eventId = eventIds.get(event);
	    return {
	        handleMessage: function (message) {
	            var genericPayload = null;
	            if (message === null || message === void 0 ? void 0 : message.rawBody) {
	                genericPayload = JSON.parse(message.rawBody);
	            }
	            if (genericPayload === null || genericPayload.eventId !== eventId) {
	                return undefined;
	            }
	            var eventPayload = toEventPayload(event, genericPayload);
	            if (eventPayload === null) {
	                return undefined;
	            }
	            listener(eventPayload);
	            return { isHandled: true, resultCode: 200 };
	        }
	    };
	};
	var toEventPayload = function (event, genericPayload) {
	    if (event === "chatMessageReceived") {
	        var payload = genericPayload;
	        var eventPayload = {
	            threadId: payload.groupId,
	            sender: constructIdentifierKindFromMri(payload.senderId),
	            senderDisplayName: payload.senderDisplayName,
	            recipient: constructIdentifierKindFromMri(payload.recipientMri),
	            id: payload.messageId,
	            createdOn: new Date(payload.originalArrivalTime),
	            version: payload.version,
	            type: payload.messageType,
	            message: payload.messageBody,
	            metadata: parseMetadata(payload.acsChatMessageMetadata)
	        };
	        return eventPayload;
	    }
	    if (event === "chatMessageEdited") {
	        var payload = genericPayload;
	        var eventPayload = {
	            threadId: payload.groupId,
	            sender: constructIdentifierKindFromMri(payload.senderId),
	            senderDisplayName: payload.senderDisplayName,
	            recipient: constructIdentifierKindFromMri(payload.recipientMri),
	            id: payload.messageId,
	            createdOn: new Date(payload.originalArrivalTime),
	            version: payload.version,
	            message: payload.messageBody,
	            editedOn: new Date(payload.edittime),
	            type: payload.messageType,
	            metadata: parseMetadata(payload.acsChatMessageMetadata)
	        };
	        return eventPayload;
	    }
	    if (event === "chatMessageDeleted") {
	        var payload = genericPayload;
	        var eventPayload = {
	            threadId: payload.groupId,
	            sender: constructIdentifierKindFromMri(payload.senderId),
	            senderDisplayName: payload.senderDisplayName,
	            recipient: constructIdentifierKindFromMri(payload.recipientMri),
	            id: payload.messageId,
	            createdOn: new Date(payload.originalArrivalTime),
	            version: payload.version,
	            deletedOn: new Date(payload.deletetime),
	            type: payload.messageType
	        };
	        return eventPayload;
	    }
	    if (event === "typingIndicatorReceived") {
	        var payload = genericPayload;
	        var eventPayload = {
	            threadId: payload.groupId,
	            sender: constructIdentifierKindFromMri(payload.senderId),
	            senderDisplayName: payload.senderDisplayName,
	            recipient: constructIdentifierKindFromMri(payload.recipientMri),
	            version: payload.version,
	            receivedOn: new Date(payload.originalArrivalTime)
	        };
	        return eventPayload;
	    }
	    if (event === "readReceiptReceived") {
	        var payload = genericPayload;
	        var readReceiptMessageBody = JSON.parse(payload.messageBody);
	        var consumptionHorizon = readReceiptMessageBody.consumptionhorizon.split(";");
	        var eventPayload = {
	            threadId: payload.groupId,
	            sender: constructIdentifierKindFromMri(payload.senderId),
	            senderDisplayName: "",
	            recipient: constructIdentifierKindFromMri(payload.recipientMri),
	            chatMessageId: payload.messageId,
	            readOn: new Date(+consumptionHorizon[1])
	        };
	        return eventPayload;
	    }
	    if (event === "chatThreadCreated") {
	        var payload = genericPayload;
	        var createdByPayload = JSON.parse(unescape(payload.createdBy));
	        var membersPayload = JSON.parse(unescape(payload.members));
	        var propertiesPayload = JSON.parse(unescape(payload.properties));
	        var createdBy = {
	            id: constructIdentifierKindFromMri(createdByPayload.participantId),
	            displayName: createdByPayload.displayName
	        };
	        var chatParticipants = membersPayload.map(function (m) {
	            return {
	                id: constructIdentifierKindFromMri(m.participantId),
	                displayName: m.displayName
	            };
	        });
	        var eventPayload = {
	            threadId: payload.threadId,
	            createdOn: new Date(payload.createTime),
	            createdBy: createdBy,
	            version: payload.version,
	            participants: chatParticipants,
	            properties: propertiesPayload
	        };
	        return eventPayload;
	    }
	    if (event === "chatThreadPropertiesUpdated") {
	        var payload = genericPayload;
	        var updatedByPayload = JSON.parse(unescape(payload.editedBy));
	        var propertiesPayload = JSON.parse(unescape(payload.properties));
	        var updatedBy = {
	            id: constructIdentifierKindFromMri(updatedByPayload.participantId),
	            displayName: updatedByPayload.displayName
	        };
	        var eventPayload = {
	            threadId: payload.threadId,
	            updatedOn: new Date(payload.editTime),
	            updatedBy: updatedBy,
	            version: payload.version,
	            properties: propertiesPayload
	        };
	        return eventPayload;
	    }
	    if (event === "chatThreadDeleted") {
	        var payload = genericPayload;
	        var deletedByPayload = JSON.parse(unescape(payload.deletedBy));
	        var deletedBy = {
	            id: constructIdentifierKindFromMri(deletedByPayload.participantId),
	            displayName: deletedByPayload.displayName
	        };
	        var eventPayload = {
	            threadId: payload.threadId,
	            deletedOn: new Date(payload.deleteTime),
	            deletedBy: deletedBy,
	            version: payload.version
	        };
	        return eventPayload;
	    }
	    if (event === "participantsAdded") {
	        var payload = genericPayload;
	        var addedByPayload = JSON.parse(unescape(payload.addedBy));
	        var participantsAddedPayload = JSON.parse(unescape(payload.participantsAdded));
	        var addedBy = {
	            id: constructIdentifierKindFromMri(addedByPayload.participantId),
	            displayName: addedByPayload.displayName
	        };
	        var chatParticipants = participantsAddedPayload.map(function (m) {
	            return {
	                id: constructIdentifierKindFromMri(m.participantId),
	                displayName: m.displayName,
	                shareHistoryTime: new Date(m.shareHistoryTime)
	            };
	        });
	        var eventPayload = {
	            threadId: payload.threadId,
	            addedOn: new Date(payload.time),
	            addedBy: addedBy,
	            version: payload.version,
	            participantsAdded: chatParticipants
	        };
	        return eventPayload;
	    }
	    if (event === "participantsRemoved") {
	        var payload = genericPayload;
	        var removedByPayload = JSON.parse(unescape(payload.removedBy));
	        var participantsRemovedPayload = JSON.parse(unescape(payload.participantsRemoved));
	        var removedBy = {
	            id: constructIdentifierKindFromMri(removedByPayload.participantId),
	            displayName: removedByPayload.displayName
	        };
	        var chatParticipants = participantsRemovedPayload.map(function (m) {
	            return {
	                id: constructIdentifierKindFromMri(m.participantId),
	                displayName: m.displayName,
	                shareHistoryTime: new Date(m.shareHistoryTime)
	            };
	        });
	        var eventPayload = {
	            threadId: payload.threadId,
	            removedOn: new Date(payload.time),
	            removedBy: removedBy,
	            version: payload.version,
	            participantsRemoved: chatParticipants
	        };
	        return eventPayload;
	    }
	    return null;
	};
	exports.toLogProvider = function (logger) {
	    return {
	        log: function () {
	            var message = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                message[_i] = arguments[_i];
	            }
	            return logger.info(message);
	        },
	        warn: function () {
	            var message = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                message[_i] = arguments[_i];
	            }
	            return logger.warning(message);
	        },
	        error: function () {
	            var message = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                message[_i] = arguments[_i];
	            }
	            return logger.error(message);
	        },
	        debug: function () {
	            var message = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                message[_i] = arguments[_i];
	            }
	            return logger.verbose(message);
	        },
	        info: function () {
	            var message = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                message[_i] = arguments[_i];
	            }
	            return logger.verbose(message);
	        }
	    };
	};
	exports.toTelemetrySender = function (logger) {
	    return {
	        logEvent: function (clientEvent) { return logger.info(clientEvent); }
	    };
	};
	var constructIdentifierKindFromMri = function (mri) {
	    if (mri.startsWith(publicTeamsUserPrefix)) {
	        return {
	            kind: "microsoftTeamsUser",
	            rawId: mri,
	            microsoftTeamsUserId: mri.substring(publicTeamsUserPrefix.length),
	            isAnonymous: false,
	            cloud: "public"
	        };
	    }
	    else if (mri.startsWith(dodTeamsUserPrefix)) {
	        return {
	            kind: "microsoftTeamsUser",
	            rawId: mri,
	            microsoftTeamsUserId: mri.substring(dodTeamsUserPrefix.length),
	            isAnonymous: false,
	            cloud: "dod"
	        };
	    }
	    else if (mri.startsWith(gcchTeamsUserPrefix)) {
	        return {
	            kind: "microsoftTeamsUser",
	            rawId: mri,
	            microsoftTeamsUserId: mri.substring(gcchTeamsUserPrefix.length),
	            isAnonymous: false,
	            cloud: "gcch"
	        };
	    }
	    else if (mri.startsWith(teamsVisitorUserPrefix)) {
	        return {
	            kind: "microsoftTeamsUser",
	            rawId: mri,
	            microsoftTeamsUserId: mri.substring(teamsVisitorUserPrefix.length),
	            isAnonymous: true
	        };
	    }
	    else if (mri.startsWith(phoneNumberPrefix)) {
	        return {
	            kind: "phoneNumber",
	            rawId: mri,
	            phoneNumber: mri.substring(phoneNumberPrefix.length)
	        };
	    }
	    else if (mri.startsWith(acsUserPrefix)
	        || mri.startsWith(acsGcchUserPrefix)
	        || mri.startsWith(acsDodUserPrefix)
	        || mri.startsWith(spoolUserPrefix)) {
	        return { kind: "communicationUser", communicationUserId: mri };
	    }
	    else {
	        return { kind: "unknown", id: mri };
	    }
	};
	var parseMetadata = function (metadata) {
	    if (metadata === undefined || metadata === null || metadata === "" || metadata === "null") {
	        return {};
	    }
	    return JSON.parse(metadata);
	};
	function base64decode(encodedString) {
	    return !coreHttp.isNode ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
	}
	exports.base64decode = base64decode;
	var parseJWT = function (token) {
	    var _a = token === null || token === void 0 ? void 0 : token.split("."), payload = _a[1];
	    if (payload === undefined) {
	        throw new Error("Invalid token");
	    }
	    payload = payload.replace(/-/g, "+").replace(/_/g, "/");
	    return JSON.parse(decodeURIComponent(escape(base64decode(payload))));
	};
	exports.getCloudTypeFromCredential = function (credential) { return __awaiter(void 0, void 0, void 0, function () {
	    var accessToken, jwtToken, parsedJwtToken, identityMri;
	    return __generator(this, function (_a) {
	        switch (_a.label) {
	            case 0: return [4 /*yield*/, credential.getToken()];
	            case 1:
	                accessToken = _a.sent();
	                jwtToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.token;
	                parsedJwtToken = parseJWT(jwtToken);
	                identityMri = parsedJwtToken.skypeid;
	                return [2 /*return*/, getCloudTypeFromSkypeId(identityMri)];
	        }
	    });
	}); };
	function getCloudTypeFromSkypeId(skypeId) {
	    var cloudPrefix = skypeId.substring(0, skypeId.indexOf(":"));
	    switch (cloudPrefix) {
	        case constants.CloudPrefix.OrgId:
	        case constants.CloudPrefix.Acs:
	        case constants.CloudPrefix.Spool: {
	            return constants.CloudType.Public;
	        }
	        case constants.CloudPrefix.GccHigh:
	        case constants.CloudPrefix.GccHighAcs: {
	            return constants.CloudType.GccHigh;
	        }
	        case constants.CloudPrefix.Dod:
	        case constants.CloudPrefix.DodAcs: {
	            return constants.CloudType.Dod;
	        }
	        default: {
	            return constants.CloudType.Public;
	        }
	    }
	}
	});

	unwrapExports(TrouterUtils);
	var TrouterUtils_1 = TrouterUtils.toMessageHandler;
	var TrouterUtils_2 = TrouterUtils.toLogProvider;
	var TrouterUtils_3 = TrouterUtils.toTelemetrySender;
	var TrouterUtils_4 = TrouterUtils.base64decode;
	var TrouterUtils_5 = TrouterUtils.getCloudTypeFromCredential;

	var TrouterSettings = createCommonjsModule(function (module, exports) {
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	exports.__esModule = true;



	var defaultSettings = {
	    version: "1.0.0",
	    registrationId: "",
	    sessionId: "",
	    pnhAppId: "AcsWeb",
	    pnhTemplate: "AcsWeb_Chat_1.5",
	    platform: "SPOOL",
	    platformUIVersion: "0.0.0",
	    environment: "",
	    productName: "acs-chat-web",
	    trouterServiceUrl: constants.PUBLIC_TROUTER_SERVICE_URL,
	    registrarServiceUrl: constants.PUBLIC_REGISTRAR_SERVICE_URL,
	    registrarRefreshTimeoutInMs: 350000,
	    timeoutOptions: {
	        connectionTimeoutMs: 20000,
	        fetchTimeoutMs: 10000,
	        pingTimeoutMs: 40000,
	        pongTimeoutMs: 5000,
	        maxBackoffMs: 50000,
	        requestTimeoutMs: 5000
	    },
	    maxRegistrationTimeInMs: 7200000
	};
	var createDefaultSettings = function () {
	    var settings = defaultSettings;
	    settings.registrationId = coreHttp.generateUuid();
	    settings.sessionId = coreHttp.generateUuid();
	    return settings;
	};
	var createIntSettings = function () {
	    var settings = createDefaultSettings();
	    settings.pnhAppId = "cns-e2e-test";
	    settings.pnhTemplate = "cns-e2e-test:1.5";
	    settings.registrarServiceUrl = constants.INT_REGISTRAR_SERVICE_URL;
	    settings.trouterServiceUrl = constants.INT_TROUTER_SERVICE_URL;
	    return settings;
	};
	var createGcchSettings = function () {
	    var settings = createDefaultSettings();
	    settings.registrarServiceUrl = constants.GCCHIGH_REGISTRAR_SERVICE_URL;
	    settings.trouterServiceUrl = constants.GCCHIGH_TROUTER_SERVICE_URL;
	    return settings;
	};
	var createDodSettings = function () {
	    var settings = createDefaultSettings();
	    settings.registrarServiceUrl = constants.DOD_REGISTRAR_SERVICE_URL;
	    settings.trouterServiceUrl = constants.DOD_TROUTER_SERVICE_URL;
	    return settings;
	};
	exports.createSettings = function (credential, options) { return __awaiter(void 0, void 0, void 0, function () {
	    var settings, cloud;
	    var _a;
	    return __generator(this, function (_b) {
	        switch (_b.label) {
	            case 0:
	                if (!((options === null || options === void 0 ? void 0 : options.environment) === "INT")) return [3 /*break*/, 1];
	                settings = createIntSettings();
	                return [3 /*break*/, 3];
	            case 1: return [4 /*yield*/, TrouterUtils.getCloudTypeFromCredential(credential)];
	            case 2:
	                cloud = _b.sent();
	                if (cloud === constants.CloudType.GccHigh) {
	                    settings = createGcchSettings();
	                }
	                else if (cloud === constants.CloudType.Dod) {
	                    settings = createDodSettings();
	                }
	                else {
	                    settings = createDefaultSettings();
	                }
	                _b.label = 3;
	            case 3:
	                settings.maxRegistrationTimeInMs = (_a = options === null || options === void 0 ? void 0 : options.registrationTimeInMs) !== null && _a !== void 0 ? _a : defaultSettings.maxRegistrationTimeInMs;
	                return [2 /*return*/, settings];
	        }
	    });
	}); };
	exports.defaultTelemetrySettings = {
	    // TBD Can we hook up OpenTelemetry?
	    enabled: false
	};
	});

	unwrapExports(TrouterSettings);
	var TrouterSettings_1 = TrouterSettings.createSettings;
	var TrouterSettings_2 = TrouterSettings.defaultTelemetrySettings;

	var SignalingClient = createCommonjsModule(function (module, exports) {
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	exports.__esModule = true;




	var CommunicationSignalingClient = /** @class */ (function () {
	    function CommunicationSignalingClient(credential, logger, options) {
	        this.credential = credential;
	        this.logger = logger;
	        this.options = options;
	        this.stateChangedListener = null;
	        this.tokenFetchRetries = 0;
	        this.trouter = tstrouter.createTrouterService(TrouterUtils.toLogProvider(logger));
	    }
	    CommunicationSignalingClient.prototype.start = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var _a, _b;
	            var _this = this;
	            return __generator(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        if (!(this.config === undefined)) return [3 /*break*/, 2];
	                        _a = this;
	                        _b = {};
	                        return [4 /*yield*/, TrouterSettings.createSettings(this.credential, this.options)];
	                    case 1:
	                        _a.config = (_b.trouterSettings = _c.sent(),
	                            _b.skypeTokenProvider = function (forceRefresh) { return __awaiter(_this, void 0, void 0, function () {
	                                var _a, _b;
	                                return __generator(this, function (_c) {
	                                    switch (_c.label) {
	                                        case 0:
	                                            if (!forceRefresh) return [3 /*break*/, 3];
	                                            this.tokenFetchRetries += 1;
	                                            if (!(this.tokenFetchRetries > constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES)) return [3 /*break*/, 2];
	                                            return [4 /*yield*/, this.stop(true)];
	                                        case 1:
	                                            _c.sent();
	                                            throw new Error("Access token is expired and failed to fetch a valid one after " +
	                                                constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES +
	                                                " retries");
	                                        case 2: return [3 /*break*/, 4];
	                                        case 3:
	                                            this.tokenFetchRetries = 0;
	                                            _c.label = 4;
	                                        case 4:
	                                            _b = (_a = Promise).resolve;
	                                            return [4 /*yield*/, this.credential.getToken()];
	                                        case 5: return [2 /*return*/, _b.apply(_a, [(_c.sent()).token])];
	                                    }
	                                });
	                            }); },
	                            _b.telemetryConfig = {
	                                eventLogger: TrouterUtils.toTelemetrySender(this.logger),
	                                settings: TrouterSettings.defaultTelemetrySettings
	                            },
	                            _b);
	                        _c.label = 2;
	                    case 2:
	                        this.trouter.start(this.config);
	                        this.trouter.setUserActivityState(tstrouter.UserActivityState.Active);
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    CommunicationSignalingClient.prototype.stop = function (isTokenExpired) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                this.trouter.offStateChanged(this.stateChangedListener);
	                this.trouter.clearMessageHandlers();
	                this.trouter.stop(isTokenExpired !== null && isTokenExpired !== void 0 ? isTokenExpired : this.tokenFetchRetries > constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES);
	                return [2 /*return*/];
	            });
	        });
	    };
	    CommunicationSignalingClient.prototype.on = function (event, listener) {
	        if (event === "connectionChanged") {
	            this.trouter.offStateChanged(this.stateChangedListener);
	            this.stateChangedListener = function (state, _url) { return listener(state); };
	            this.trouter.onStateChanged(this.stateChangedListener);
	            return;
	        }
	        this.trouter.registerMessageHandler(TrouterUtils.toMessageHandler(event, listener));
	    };
	    return CommunicationSignalingClient;
	}());
	exports.CommunicationSignalingClient = CommunicationSignalingClient;
	});

	unwrapExports(SignalingClient);
	var SignalingClient_1 = SignalingClient.CommunicationSignalingClient;

	var src = createCommonjsModule(function (module, exports) {
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	exports.__esModule = true;
	__export(SignalingClient);
	});

	var index = unwrapExports(src);

	return index;

})));
//# sourceMappingURL=azure-communicationservices-signaling.js.map
